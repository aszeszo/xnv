commit 5dcad9e9d7d9993d65f989219bee94a060bbf476
Author: Alan Coopersmith <alan.coopersmith@sun.com>
Date:   Fri Feb 2 14:44:55 2007 -0800

    Fix bus error on startup in 64-bit Xephyr
    
    hostx_get_visual_masks takes unsigned long * arguments, but was being
    passed pointers to CARD32's.

diff --git a/hw/kdrive/ephyr/ephyr.c b/hw/kdrive/ephyr/ephyr.c
index 7db8675..2ca51c3 100644
--- a/hw/kdrive/ephyr/ephyr.c
+++ b/hw/kdrive/ephyr/ephyr.c
@@ -81,7 +81,8 @@ Bool
 ephyrScreenInitialize (KdScreenInfo *screen, EphyrScrPriv *scrpriv)
 {
   int width = 640, height = 480; 
-
+  unsigned long redMask, greenMask, blueMask;
+  
   if (hostx_want_screen_size(&width, &height) 
       || !screen->width || !screen->height)
     {
@@ -133,30 +134,24 @@ ephyrScreenInitialize (KdScreenInfo *scr
 	{
 	  screen->fb[0].depth = 15;
 	  screen->fb[0].bitsPerPixel = 16;
-	  
-	  hostx_get_visual_masks (&screen->fb[0].redMask,
-				  &screen->fb[0].greenMask,
-				  &screen->fb[0].blueMask);
-	  
 	}
       else if (screen->fb[0].depth <= 16)
 	{
 	  screen->fb[0].depth = 16;
 	  screen->fb[0].bitsPerPixel = 16;
-	  
-	  hostx_get_visual_masks (&screen->fb[0].redMask,
-				  &screen->fb[0].greenMask,
-				  &screen->fb[0].blueMask);
 	}
       else
 	{
 	  screen->fb[0].depth = 24;
 	  screen->fb[0].bitsPerPixel = 32;
-	  
-	  hostx_get_visual_masks (&screen->fb[0].redMask,
-				  &screen->fb[0].greenMask,
-				  &screen->fb[0].blueMask);
 	}
+
+      hostx_get_visual_masks (&redMask, &greenMask, &blueMask);
+
+      screen->fb[0].redMask = (Pixel) redMask;
+      screen->fb[0].greenMask = (Pixel) greenMask;
+      screen->fb[0].blueMask = (Pixel) blueMask;
+
     }
   
   scrpriv->randr = screen->randr;


--- xorg-server-1.2.0/hw/kdrive/ephyr/hostx.c~	2007-01-22 21:39:15.000000000 -0800
+++ xorg-server-1.2.0/hw/kdrive/ephyr/hostx.c	2007-02-02 16:03:09.840426000 -0800
@@ -40,6 +40,7 @@
 #include <X11/Xatom.h>
 #include <X11/keysym.h>
 #include <X11/extensions/XShm.h>
+#include <X11/Xmd.h>
 
 /*  
  * All xlib calls go here, which gets built as its own .a .
@@ -79,7 +80,8 @@
 
 extern KeySym         EphyrKeymap[];
 
-extern KeySym	      kdKeymap[];
+extern CARD32	      kdKeymap[];	/* really KeySym, but Xlib & Xserver
+					   use different sizes for that */
 extern int	      kdMinScanCode;
 extern int	      kdMaxScanCode;
 extern int	      kdMinKeyCode;


Backport to 7.2 of commit 47c1c948e69cfba950ad37a3133fa2db0bd0ff2c
Original Author: Daniel Stone <daniel@fooishbar.org>
Date:   Tue Aug 15 15:25:16 2006 +0300

    kdrive/input: only run special key behaviours on non-XKB
    Only attempt to manually deal with special key behaviours (e.g. terminating
    the server) when not using XKB, and leave locking behaviour up to GKVE.

--- xorg-server-1.2.0/hw/kdrive/src/kinput.c	2007-01-22 21:39:15.000000000 -0800
+++ xorg-server-1.2.0/hw/kdrive/src/kinput.c	2007-04-09 18:58:43.562841000 -0700
@@ -616,15 +616,6 @@
     RegisterKeyboardDevice(pKeyboard);
     miRegisterPointerDevice(screenInfo.screens[0], pPointer);
     mieqInit(&pKeyboard->public, &pPointer->public);
-#ifdef XINPUT
-    {
-	static long zero1, zero2;
-
-	//SetExtInputCheck (&zero1, &zero2);
-	ErrorF("Extended Input Devices not yet supported. Impelement it at line %d in %s\n",
-	       __LINE__, __FILE__);
-    }
-#endif
 }
 
 /*
@@ -1303,20 +1294,6 @@
 	    xE.u.u.type = KeyPress;
 	xE.u.u.detail = key_code;
 	
-	switch (KEYCOL1(key_code)) 
-	{
-	case XK_Num_Lock:
-	case XK_Scroll_Lock:
-	case XK_Shift_Lock:
-	case XK_Caps_Lock:
-	    if (xE.u.u.type == KeyRelease)
-		return;
-	    if (IsKeyDown (key_code))
-		xE.u.u.type = KeyRelease;
-	    else
-		xE.u.u.type = KeyPress;
-	}
-	
 	/*
 	 * Check pressed keys which are already down
 	 */
