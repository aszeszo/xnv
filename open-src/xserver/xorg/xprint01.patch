--- hw/xprint/pcl/PclArc.c	2009-01-09 14:17:56.330059000 -0800
+++ hw/xprint/pcl/PclArc.c.new	2009-01-09 14:17:56.344134000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -77,6 +106,11 @@ PclDoArc(
     XpContextPtr pCon;
     PclContextPrivPtr pConPriv;
     xRectangle repro;
+/*
+** Bug 4402208: CRT 00325: Circles are Squares. Remove old fix. Do Scaling
+*/
+    float scl_fact = 1;
+    XpClientDPIPtr pClientDPI;
     
     if( PclUpdateDrawableGC( pGC, pDrawable, &outFile ) == FALSE )
       return;
@@ -87,7 +121,10 @@ PclDoArc(
     pConPriv = (PclContextPrivPtr)
 	dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
     XpGetReproductionArea( pCon, &repro );
-    
+    pClientDPI = (XpClientDPIPtr) XpClientDPIGetRec(pCon);
+    if(pClientDPI)
+       scl_fact = pClientDPI->scale_factor;
+  
     /* 
      * Generate the PCL code to draw the collection of arcs, by
      * defining it as a macro which uses the HP-GL/2 arc drawing
@@ -133,8 +170,8 @@ PclDoArc(
 	  sprintf( t, "SC%.2f,%.2f,%d,%d;", 
 		  (repro.x - Arc.width / 2 - xoffset - Arc.x) * ratio,
 		  (repro.x - Arc.width / 2 - xoffset - Arc.x +
-		   repro.width) * ratio,
-		  repro.y - Arc.height / 2 - yoffset - Arc.y + repro.height,
+		   repro.width / scl_fact) * ratio,
+                  repro.y - Arc.height / 2 - yoffset - Arc.y + (int)(repro.height/scl_fact),
 		  repro.y - Arc.height / 2 - yoffset - Arc.y);
 	  SAVE_PCL( outFile, pConPriv, t );
 
@@ -173,10 +210,9 @@ PclDoArc(
 	  /*
 	   * Restore the coordinate system
 	   */
-	  sprintf( t, "\033%%0BSC%d,%d,%d,%d;\033%%0A", repro.x, 
-		  repro.x + repro.width, repro.y + repro.height, 
-		  repro.y );
-	  SEND_PCL( outFile, t );
+	  sprintf( t, "\033%%0BSC%d,%d,%d,%d;\033%%0A", repro.x,
+                  repro.x + repro.width/scl_fact, repro.y + repro.height/scl_fact,
+                  repro.y );
 	  
 	  /*
 	   * Clean up the temporary regions
--- hw/xprint/pcl/PclArea.c	2009-01-09 14:17:56.366749000 -0800
+++ hw/xprint/pcl/PclArea.c.new	2009-01-09 14:17:56.380165000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -145,6 +174,8 @@ PclPutImage(DrawablePtr pDrawable,
  *
  * Given a 1-bit-deep pixmap, send the appropriate part of it to the
  * output file as a PCL raster graphics command.
+ * Added scl_fact to pixmapFragment calls. This allows correct positioning to
+ * occur when Mozilla is running.
  */
 static void
 PclMonoPixmapFragment(FILE *outFile,
@@ -154,7 +185,8 @@ PclMonoPixmapFragment(FILE *outFile,
 		      short x2,
 		      short y2,
 		      short dstx,
-		      short dsty)
+		      short dsty,
+                      float scl_fact)
 {
     char *bits, t[80], *row;
     int h, w, i;
@@ -183,8 +215,8 @@ PclMonoPixmapFragment(FILE *outFile,
      * it's going to go down the wire without any compression.  That
      * will have to be good enough for the sample implementation.
      */
-    sprintf( t, "\033*t300R\033*r%dT\033*r%dS\033*r1A\033*b0M",
-	    h, x2 - x1 );
+    sprintf( t, "\033*t%dR\033*r%dT\033*r%dS\033*r1A\033*b0M",
+            (int)(300.0 / scl_fact), h, x2 - x1 );
     SEND_PCL( outFile, t );
 
     sprintf( t, "\033*b%dW", w );
@@ -210,7 +242,8 @@ PclColorPixmapFragment(FILE *outFile,
 		       short x2,
 		       short y2,
 		       short dstx,
-		       short dsty)
+		       short dsty,
+                       float scl_fact)
 {
     char *bits, t[80], *row;
     int h, w, i;
@@ -238,15 +271,25 @@ PclColorPixmapFragment(FILE *outFile,
      * it's going to go down the wire without any compression.  That
      * will have to be good enough for the sample implementation.
      */
-    sprintf( t, "\033*t300R\033*r%dt%ds1A\033*b0M",
-	    h, x2 - x1 );
+    sprintf( t, "\033*t%dR\033*r%dt%ds1A\033*b0M", (int)(300.0 / scl_fact),
+            h, x2);
     SEND_PCL( outFile, t );
 
     sprintf( t, "\033*b%dW", w );
     for( row = bits, i = 0; i < h; i++, row += w )
       {
-	  SEND_PCL( outFile, t );
-	  SEND_PCL_COUNT( outFile, row, w );
+	  extern int replace_white;
+          int x;
+
+          SEND_PCL( outFile, t );
+/*
+** 4402298: white pixels are transparent: UGLY FIX
+*/
+
+          for(x=0;x<w;x++)
+              if(row[x] == 0)
+                  row[x] = replace_white;
+          SEND_PCL_COUNT( outFile, row, w );
       }
 
     SEND_PCL( outFile, "\033*rC" );
@@ -276,12 +319,27 @@ PclCopyArea(DrawablePtr pSrc,
     FILE *dstFile;
     GC dstGC;
     unsigned long valid;
+    XpContextPtr pCon;
     RegionPtr drawRegion, region, whole, ret;
     BoxRec box;
     BoxPtr prect;
     int nrect;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
+    int changecolor = 1;
+    
     void (*doFragment)(FILE *, PixmapPtr, short, short, short, short,
-		       short, short );
+                       short, short, float );
+    
+    pCon = PclGetContextFromWindow( (WindowPtr)pDst );
+    pClientDPI = (XpClientDPIPtr) XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+        scl_fact = pClientDPI->scale_factor;
+    else
+/* Bug 4462837: Xprt does not display images with CopyArea */
+        changecolor = 0;
+
 
     /*
      * Since we don't store any information on a per-window basis, we
@@ -307,6 +365,12 @@ PclCopyArea(DrawablePtr pSrc,
      * drawing, instead of just handing it off to fb.  Start
      * by determining the region that will be drawn.
      */
+/*
+**  CRT 00308: Bug 4402782: Scale xprt output
+*/
+    {
+
+
     box.x1 = srcx;
     box.y1 = srcy;
     box.x2 = srcx + width;
@@ -332,15 +396,47 @@ PclCopyArea(DrawablePtr pSrc,
     nrect = REGION_NUM_RECTS( region );
     prect = REGION_RECTS( region );
 
-    while( nrect )
-      {
-	  (*doFragment)( dstFile, (PixmapPtr)pSrc, prect->x1 - dstx,
-			prect->y1 - dsty, prect->x2 - dstx,
-			prect->y2 - dsty, prect->x1, prect->y1 );
 
-	  nrect--;
-	  prect++;
-      }
+        /*
+         * If the scale factor is being used, then check to see if the bitmap is all
+         * black. If it is, then we do not want to show it. Just ignore the bitmap.
+         * This fix is for all of the clipping problems in Mozilla and mi/dix.
+         */
+        if(scl_fact != 1)
+        {
+            int nr = nrect;
+            BoxPtr pr = prect;
+            PixmapPtr pPix = (PixmapPtr)pSrc;
+            char *ch = pPix->devPrivate.ptr;
+            int wid = (int)((pr->x2-pr->x1)/4)*4+((pr->x2-pr->x1)%4 != 0)*4;
+
+            while(nr && changecolor)
+            {
+                int x, y;
+
+                for(x = 0;x< pr->x2 - pr->x1 && changecolor;x++)
+                    for(y=0;y<pr->y2 - pr->y1 && changecolor;y++)
+                        if(ch[x + y * wid] != 1)
+                            changecolor = 0;
+                nr--;
+                pr++;
+            }
+        }
+        else
+           changecolor = 0;
+
+	if(!changecolor)
+            while( nrect )
+              {
+            	  (*doFragment)( dstFile, (PixmapPtr)pSrc, prect->x1 - dstx,
+                        prect->y1 - dsty, prect->x2 - dstx,
+                        prect->y2 - dsty, prect->x1, prect->y1, scl_fact );
+
+                      nrect--;
+                      prect++;
+            	  }
+    }
+
 
     /*
      * Update the destination's GC to the source's GC.
--- hw/xprint/pcl/PclColor.c	2009-01-09 14:17:56.415136000 -0800
+++ hw/xprint/pcl/PclColor.c.new	2009-01-09 14:17:56.428389000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -74,6 +103,10 @@ static void trilinear(unsigned char *p,
 		unsigned char *d,
 		int dim,
 		unsigned char def);
+/*
+** Bug: 4402298: white pixels are transparenet: ULGY FIX
+*/
+int replace_white = 0;
 
 
 /*
@@ -196,7 +229,7 @@ PclDestroyColormap(ColormapPtr pColor)
 	  while( con )
 	    {
 		cPriv = dixLookupPrivate(&con->context->devPrivates,
-					 PclContextPrivateKey);
+                                         PclContextPrivateKey);
 		pPal = cPriv->palettes;
 		while( pPal )
 		  {
@@ -246,6 +279,27 @@ PclListInstalledColormaps(ScreenPtr pScr
     return 0;
 }
 
+/*
+ * The same code is in a few places, do it here and make sure it is consistent.
+ */
+void
+PclGetColors(ColormapPtr cmap, int i, unsigned short *r, unsigned short *g, 
+		unsigned short *b)
+{
+    if( cmap->red[i].fShared )
+    {
+        *r = cmap->red[i].co.shco.red->color;
+        *g = cmap->red[i].co.shco.green->color;
+        *b = cmap->red[i].co.shco.blue->color;
+    }
+    else
+    {
+        *r = cmap->red[i].co.local.red;
+        *g = cmap->red[i].co.local.green;
+        *b = cmap->red[i].co.local.blue;
+    }
+}
+
 void
 PclStoreColors(ColormapPtr pColor,
 	       int ndef,
@@ -279,7 +333,7 @@ PclStoreColors(ColormapPtr pColor,
 		 * appropriate palette.
 		 */
 		cPriv = dixLookupPrivate(&con->context->devPrivates,
-					 PclContextPrivateKey);
+                                         PclContextPrivateKey);
 		pMap = PclFindPaletteMap( cPriv, pColor, NULL );
 
 		/*
@@ -295,19 +349,7 @@ PclStoreColors(ColormapPtr pColor,
 		      for( i = 0; i < ndef; i++ )
 			{
 			    pID = pdefs[i].pixel;
-			    if ( pColor->red[i].fShared )
-			      {
-				  r = pColor->red[pID].co.shco.red->color;
-				  g = pColor->red[pID].co.shco.green->color;
-				  b = pColor->red[pID].co.shco.blue->color;
-			      }
-			    else
-			      {
-				  r = pColor->red[pID].co.local.red;
-				  g = pColor->red[pID].co.local.green;
-				  b = pColor->red[pID].co.local.blue;
-			      }
-
+			    PclGetColors(pColor, i, &r, &g, &b);
 			    if( pdefs[i].flags & DoRed )
 				  r = pdefs[i].red;
 			    if( pdefs[i].flags & DoGreen )
@@ -438,8 +480,8 @@ PclUpdateColormap(DrawablePtr pDrawable,
 	   * Add the colormap to the screen-level colormap<->context mapping.
 	   */
 	  sPriv = (PclScreenPrivPtr)
-	      dixLookupPrivate(&cmap->pScreen->devPrivates,
-			       PclScreenPrivateKey);
+		dixLookupPrivate(&cmap->pScreen->devPrivates,
+                               PclScreenPrivateKey);
 	  pCmap = sPriv->colormaps;
 	  while( pCmap && ( pCmap->colormapId != cmap->mid ) )
 		pCmap = pCmap->next;
@@ -498,19 +540,28 @@ PclUpdateColormap(DrawablePtr pDrawable,
 		
 		for(i = 0; i < cmap->pVisual->ColormapEntries; i++ )
 		  {
-		      if( cmap->red[i].fShared )
-			{
-			    r = cmap->red[i].co.shco.red->color;
-			    g = cmap->red[i].co.shco.green->color;
-			    b = cmap->red[i].co.shco.blue->color;
-			}
-		      else
-			{
-			    r = cmap->red[i].co.local.red;
-			    g = cmap->red[i].co.local.green;
-			    b = cmap->red[i].co.local.blue;
-			}
+		      /*
+                       * Bug: 4402298: White pixels are transparent.
+                       *	THIS FIX IS AN UGLY HACK!!! Should try to turn
+                       *	transparency off for bitmaps, here we are changing
+                       *	the last color in the colormap to be off white.
+                       *	Additionally, replace_white is set to this color
+                       *	but is not used until the bitmap is sent. This
+                       *	could happen after another app has called and set
+                       *	its GC values and changed replace_white to another
+                       *	value. replace_white should be in the client data,
+                       *	but no access is present in the PclArea.c code.
+                       */
+                      if(i == cmap->pVisual->ColormapEntries - 1)
+                      {
+                          replace_white = i;
+                          PclGetColors(cmap, 0, &r, &g, &b);
+                      }
+                      else
+                          PclGetColors(cmap, i, &r, &g, &b);
 		      PclLookUp(cmap, cPriv, &r, &g, &b);
+		      if(i == cmap->pVisual->ColormapEntries - 1)
+                          r--;
 		      sprintf( t, "\033*v%ua%ub%uc%dI", r, g, b, i );
 		      SEND_PCL( outFile, t );
 		  }
--- hw/xprint/pcl/PclGC.c	2009-01-09 14:17:56.454870000 -0800
+++ hw/xprint/pcl/PclGC.c.new	2009-01-09 14:17:56.468472000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -145,7 +174,7 @@ PclGetDrawablePrivateStuff(
 	  else
 	    {
 		cPriv = (PclContextPrivPtr)
-		    dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
+                    dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
 		*gc = cPriv->lastGC;
 		*valid = cPriv->validGC;
 		*file = cPriv->pPageFile;
@@ -173,7 +202,7 @@ PclSetDrawablePrivateGC(
 	case DRAWABLE_PIXMAP:
 	  pix = (PixmapPtr)pDrawable;
 	  pixPriv = (PclPixmapPrivPtr)
-	      dixLookupPrivate(&pix->devPrivates, PclPixmapPrivateKey);
+		dixLookupPrivate(&pix->devPrivates, PclPixmapPrivateKey);
 	  
 	  pixPriv->lastGC = gc;
 	  pixPriv->validGC = 1;
@@ -182,7 +211,7 @@ PclSetDrawablePrivateGC(
 	case DRAWABLE_WINDOW:
 	  pCon = PclGetContextFromWindow( (WindowPtr)pDrawable );
 	  pPriv = (PclContextPrivPtr)
-	      dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
+		dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
 	  
 	  pPriv->validGC = 1;
 	  pPriv->lastGC = gc;
@@ -318,7 +347,7 @@ PclUpdateDrawableGC(
     XpContextPtr pCon;
     PclContextPrivPtr cPriv;
     PclGCPrivPtr gcPriv = (PclGCPrivPtr)
-	dixLookupPrivate(&pGC->devPrivates, PclGCPrivateKey);
+      dixLookupPrivate(&pGC->devPrivates, PclGCPrivateKey);
     
     if( !PclGetDrawablePrivateStuff( pDrawable, &dGC, &valid, outFile ) )
       return FALSE;
@@ -804,6 +833,12 @@ PclComputeCompositeClip(
 {
     if (pDrawable->type == DRAWABLE_WINDOW)
     {
+	
+/*
+* CRT 00308: Bug 4402782: Scale xprt output
+*/
+	XpContextPtr pCon;
+        int client_dpi, scl_fact = 1;
 	WindowPtr       pWin = (WindowPtr) pDrawable;
 	RegionPtr       pregWin;
 	Bool            freeTmpClip, freeCompClip;
@@ -819,6 +854,19 @@ PclComputeCompositeClip(
 	    freeTmpClip = FALSE;
 	}
 	freeCompClip = pGC->freeCompClip;
+        /*
+   	 * Check to see if the application is scaling. If it is, then do not
+   	 * perform clipping on the images. (This is a hack, but the clipping
+   	 * is very broken. By checking the image for all black pixels, we can
+   	 * remove the artifacts that CT_NONE will cause, but not get the
+   	 * disappearing images that CT_REGION creates).
+   	 */
+   	pCon = PclGetContextFromWindow( (WindowPtr)pDrawable );
+   	XpClientDPIGetData(pCon, &client_dpi, &scl_fact);
+
+        if(scl_fact != 1.0)
+            pGC->clientClipType = CT_NONE;
+
 
 	/*
 	 * if there is no client clip, we can get by with just keeping the
--- hw/xprint/pcl/PclPrint.c	2008-11-05 08:52:17.000000000 -0800
+++ hw/xprint/pcl/PclPrint.c.new	2009-01-11 12:25:12.534336000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -120,6 +149,8 @@ PclStartJob(
     pal = &( pConPriv->specialTrueColorPalette );
     pal->paletteId = 3;
     pal->downloaded = 0;
+/* CRT 00308: Bug 4402782: Scale xprt output */
+    XpClientDPISet(pCon, 300);
 
     return Success;
 }
@@ -257,6 +288,14 @@ PclStartPage(
     char t[80];
     XpOid orient, plex, tray, medium;
     int dir, plexNum, num;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+	scl_fact = pClientDPI->scale_factor;
+
     
     /*
      * Put a pointer to the context in the window private structure
@@ -437,7 +476,8 @@ PclStartPage(
     SEND_PCL( pConPriv->pPageFile, t );
     
     sprintf( t, "\033%%0BSC%d,%d,%d,%d;\033%%0A", repro.x, repro.x +
-	    repro.width, repro.y + repro.height, repro.y );
+	    (int)(repro.width / scl_fact),
+            repro.y + (int)(repro.height / scl_fact), repro.y );
     SEND_PCL( pConPriv->pPageFile, t );
 
     return Success;
--- hw/xprint/pcl/PclText.c	2008-11-05 08:52:17.000000000 -0800
+++ hw/xprint/pcl/PclText.c.new	2009-01-13 13:03:58.238696000 -0800
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /*******************************************************************
 **
 **    *********************************************************
@@ -59,6 +88,10 @@ copyright holders.
 #include <X11/Xatom.h>
 
 #include "PclSFonts.h"
+/*
+** 00308: Bug 4402782: Scale xprt output
+*/
+#include "dpi.h"
 
 static PclFontHead8Ptr  makeFontHeader8 (FontPtr, PclSoftFontInfoPtr);
 static PclFontHead16Ptr makeFontHeader16(FontPtr, PclSoftFontInfoPtr);
@@ -112,12 +145,51 @@ BoxPtr pbox;
 BoxRec box;
 RegionPtr drawRegion, region;
 char font_type;
+XpClientDPIPtr pClientDPI;
+float scl_fact = 1;
+FontPtr useFont;
+int client_x, server_x;
+    
+    useFont = pGC->font;
 
     if( PclUpdateDrawableGC( pGC, pDrawable, &outFile ) == FALSE )
 	return x;
+    pCon = PclGetContextFromWindow( (WindowPtr)pDrawable );
+    pConPriv = (PclContextPrivPtr)
+	dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
 
-    GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
-						Linear8Bit, &n, charinfo);
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+    {
+        scl_fact = pClientDPI->scale_factor;
+
+        if(scl_fact != 1.0)
+        {
+            /*
+             * Get the positions based on the client DPI sized fonts, and the
+             * server DPI sized fonts. Note that server fonts have been scaled
+             * back so that the x position is in the same scale. This is done
+             * to fix the issue that 100 DPI fonts do not have the same spacing
+             * at 300 DPI as 300 DPI fonts do. (IE multiply 100 DPI font size
+             * by 3 does not give 300 DPI font sizes exactly). The X pos sent
+             * into this function is based on client DPI fonts. The characters
+             * used to print are server DPI fonts. The starting position may
+             * need to change if fonts on this line printed earlier did not
+             * match exactly.
+             */
+            XpClientDPIGetPos(pClientDPI, &client_x, &server_x);
+            if(x == client_x && client_x != server_x)
+                x = server_x;
+            else
+                client_x = x;
+
+            useFont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+        }
+    }
+
+    GetGlyphs(useFont, (unsigned long)count, (unsigned char *)string,
+                                                Linear8Bit, &n, charinfo);
     if ( n == 0 )
 	return x;
 
@@ -125,12 +197,12 @@ char font_type;
     pConPriv = (PclContextPrivPtr)
 	dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
     pSoftFontInfo = pConPriv->pSoftFontInfo;
-    font_type = isInternal(pGC->font);
+    font_type = isInternal(useFont);
     if ( font_type == DOWNLOAD_FONT ) {
 	/*
  	 * Create Soft Font Header Information
  	 */
-	pfh8 = makeFontHeader8(pGC->font, pSoftFontInfo);
+	pfh8 = makeFontHeader8(useFont, pSoftFontInfo);
 	if (!pfh8)
 	    return x;
 
@@ -152,8 +224,8 @@ char font_type;
 	 */
 	MACRO_START( outFile, pConPriv );
 	sprintf(t, "\033%%0B;PU%d,%dPD;TD1;DT%c,1;",
-                x + pDrawable->x, y + pDrawable->y + pGC->font->info.fontAscent,
-		ETX);
+                x + pDrawable->x, y + pDrawable->y, ETX);    
+        /* Bug: Lines too low */
 	SAVE_PCL( outFile, pConPriv, t );
 	SAVE_PCL_COUNT( outFile, pConPriv, "FI0;SS;LB", 9 );
 
@@ -186,7 +258,7 @@ char font_type;
     } else {
 	int fid = 0;
 
-	pin = makeInternalFont(pGC->font, pSoftFontInfo);
+	pin = makeInternalFont(useFont, pSoftFontInfo);
 	if (!pin)
 	    return x;
 
@@ -197,8 +269,8 @@ char font_type;
 	 */
 	MACRO_START( outFile, pConPriv );
 	sprintf(t, "\033%%0B;PU%d,%dPD;TD1;DT%c,1;",
-		x + pDrawable->x, y + pDrawable->y + pGC->font->info.fontAscent,
-		ETX);
+                x + pDrawable->x, y + pDrawable->y, ETX);       
+        /* Bug: Lines too low */
 	SAVE_PCL( outFile, pConPriv, t );
 	selectSize(outFile, pConPriv, pin);
 	SAVE_PCL_COUNT( outFile, pConPriv, "FI0;SS;LB", 9 );
@@ -220,15 +292,38 @@ char font_type;
 	SAVE_PCL( outFile, pConPriv, t );
 	MACRO_END( outFile );
     }
+    
+    /*
+     * Calculate the size of the client DPI fonts. We already know w is the size
+     * of the server sized fonts. So server_x gets w/scl_fact added to the start
+     * position. client_x gets its value incremented by the size of the client
+     * fonts. (client_x may need to be set above to x instead of only in the else??)
+     */
+    if(useFont != pGC->font)
+    {
+        CharInfoPtr charinfoC[255];
+        int w2;
+
+        server_x = x+w / scl_fact;
+        GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
+                                        Linear8Bit, &n, charinfoC);
+        w2 = 0;
+        for (i=0; i<n; i++) w2 += charinfoC[i]->metrics.characterWidth;
+        client_x += w2;
+
+        if(pClientDPI)
+           XpClientDPISetPos(pClientDPI, client_x, server_x);
+    }
+
 
     /*
      * Convert the collection of rectangles into a proper region, then
      * intersect it with the clip region.
      */
     box.x1 = x +  pDrawable->x;
-    box.y1 = y - max_ascent + pDrawable->y + pGC->font->info.fontAscent;
+    box.y1 = y - max_ascent + pDrawable->y;     /* Bug: Lines Too Low */
     box.x2 = x + w + pDrawable->x;
-    box.y2 = y + max_descent + pDrawable->y + pGC->font->info.fontAscent;
+    box.y2 = y + max_descent + pDrawable->y;    /* Bug: Lines Too Low */
 
     drawRegion = miRegionCreate( &box, 0 );
     region = miRegionCreate( NULL, 0 );
@@ -283,32 +378,59 @@ BoxPtr pbox;
 BoxRec box;
 RegionPtr drawRegion, region;
 char font_type;
+XpClientDPIPtr pClientDPI;
+float scl_fact = 1;
+FontPtr useFont;
+int client_x, server_x;
+
+/*
+**  Bug 4402782: Scale xprt output
+*/
+    useFont = pGC->font;
 
     if( PclUpdateDrawableGC( pGC, pDrawable, &outFile ) == FALSE )
 	return x;
 
-    GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
-		(FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
-		&n, charinfo);
-
     pCon = PclGetContextFromWindow( (WindowPtr)pDrawable );
     pConPriv = (PclContextPrivPtr)
 	dixLookupPrivate(&pCon->devPrivates, PclContextPrivateKey);
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+    {
+        scl_fact = pClientDPI->scale_factor;
+
+        if(scl_fact != 1.0)
+        {
+            XpClientDPIGetPos(pClientDPI, &client_x, &server_x);
+            if(x == client_x && client_x != server_x)
+                x = server_x;
+            else
+                client_x = x;
+
+            useFont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+        }
+    }
+
+    GetGlyphs(useFont, (unsigned long)count, (unsigned char *)string,
+                (FONTLASTROW(useFont) == 0) ? Linear16Bit : TwoD16Bit,
+                &n, charinfo);
+
     pSoftFontInfo = pConPriv->pSoftFontInfo;
+    font_type = isInternal(useFont);
 
-    font_type = isInternal(pGC->font);
     if ( font_type == DOWNLOAD_FONT ) {
 	/*
 	 * Create Soft Font Header Information
 	 */
-	pfh16 = makeFontHeader16(pGC->font, pSoftFontInfo);
-	if (!pfh16)
-	    return x;
-
+	pfh16 = makeFontHeader16(useFont, pSoftFontInfo);
+        if (!pfh16)
+            return x;
 	/*
 	 * exec Soft Font Downloading
 	 */
-	pfi = (FontInfoRec *)&pGC->font->info;
+	pfi = (FontInfoRec *)&useFont->info;
 	p = (char *)string;
 	for (i=0, p=(char *)string, chinfo=charinfo; i<n; i++, p+=2, chinfo++) {
 	    row = *p & 0xff;
@@ -335,8 +457,9 @@ char font_type;
 	 */
 	MACRO_START( outFile, pConPriv );
 	sprintf(t, "\033%%0B;PU%d,%dPD;TD1;DT%c,1;",
-		x + pDrawable->x, y + pDrawable->y + pGC->font->info.fontAscent,
-		ETX);
+                x + pDrawable->x, y + pDrawable->y, ETX);       
+	/* Bug: Lines Too Low */
+
 	SAVE_PCL( outFile, pConPriv, t );
 	SAVE_PCL_COUNT( outFile, pConPriv, "FI0;SS;LB", 9 );
 
@@ -381,7 +504,7 @@ char font_type;
 	PclInternalFontPtr pin;
 	int fid = 0;
 
-	pin = makeInternalFont(pGC->font, pSoftFontInfo);
+	pin = makeInternalFont(useFont, pSoftFontInfo);
 	if (!pin)
 	    return x;
 
@@ -393,8 +516,8 @@ char font_type;
 	 */
 	MACRO_START( outFile, pConPriv );
 	sprintf(t, "\033%%0B;PU%d,%dPD;TD1;DT%c,1;",
-		x + pDrawable->x, y + pDrawable->y + pGC->font->info.fontAscent,
-		ETX);
+                x + pDrawable->x, y + pDrawable->y, ETX);       
+	/* Bug: Lines Too Low */
 	SAVE_PCL( outFile, pConPriv, t );
 	sprintf(t, "TD0;\033%%1A");
 	SAVE_PCL( outFile, pConPriv, t );
@@ -405,7 +528,7 @@ char font_type;
 	max_descent = charinfo[0]->metrics.descent;
 	for (i=0, p=(char *)string, chinfo=charinfo; i<n; i++, p+=2, chinfo++) {
 	    char tobuf[3];
-	    code_conv(pSoftFontInfo, pGC->font, (char *)p, tobuf);
+	    code_conv(pSoftFontInfo, useFont, (char *)p, tobuf);
 	    fprintf(outFile, "%c%c", tobuf[0], tobuf[1]);
 
 	    w += (*chinfo)->metrics.characterWidth;
@@ -417,15 +540,31 @@ char font_type;
 	return x;
 #endif /* DO_TWO_BYTE_PCL */
     }
+    
+    if(useFont != pGC->font)
+    {
+        CharInfoPtr charinfoC[255];
+        int w2;
+
+        server_x = x+w / scl_fact;
+        GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
+                                        Linear8Bit, &n, charinfoC);
+        w2 = 0;
+        for (i=0; i<n; i++) w2 += charinfoC[i]->metrics.characterWidth;
+        client_x += w2;
+
+        if(pClientDPI)
+           XpClientDPISetPos(pClientDPI, client_x, server_x);
+    }
 
     /*
      * Convert the collection of rectangles into a proper region, then
      * intersect it with the clip region.
      */
     box.x1 = x + pDrawable->x;
-    box.y1 = y - max_ascent + pDrawable->y + pGC->font->info.fontAscent;
+    box.y1 = y - max_ascent + pDrawable->y;     /* Bug: Lines Too Low */
     box.x2 = x + w + pDrawable->x;
-    box.y2 = y + max_descent + pDrawable->y + pGC->font->info.fontAscent;
+    box.y2 = y + max_descent + pDrawable->y;    /* Bug: Lines Too Low */
 
     drawRegion = miRegionCreate( &box, 0 );
     region = miRegionCreate( NULL, 0 );
