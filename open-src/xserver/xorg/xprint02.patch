--- hw/xprint/ps/PsArea.c	2006-09-17 23:04:18.000000000 -0700
+++ hw/xprint/ps/PsArea.c.new	2008-09-24 10:53:55.994077000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 
 Copyright 1996, 1998  The Open Group
 
@@ -228,6 +257,8 @@ PsPutScaledImageIM(DrawablePtr pDrawable
   {
     int          i, j;
     int          r, c;
+    int		 swap;
+    char	*pt;
     PsOutPtr     psOut;
     ColormapPtr  cMap;
     int          pageRes, sw, sh;
@@ -245,6 +276,9 @@ PsPutScaledImageIM(DrawablePtr pDrawable
         sh = (float)h * (float)pageRes / (float)imageRes + 0.5;
     }
     PsOut_Offset(psOut, pDrawable->x, pDrawable->y);
+/*
+** bug4356265:PS driver of Xprt doesn't support transparent bitmap font printing*/
+    pt = (char *)(&i); i = 1; if( pt[0]=='\001' ) swap = 1; else swap = 0;
 
 #ifdef BM_CACHE
     cache_id = PsBmIsImageCached(w, h, pImage);
@@ -258,36 +292,97 @@ PsPutScaledImageIM(DrawablePtr pDrawable
 
       PsOut_BeginImageCache(psOut, cache_id);
 #endif
-      if( depth!=1 )
+            if( depth==24 )
       {
         PsOut_BeginImageIM(psOut, 0, 0, x, y, w, h, sw, sh, 3);
-
-        for( r=0 ; r<h ; r++ )
+        if( format==XYPixmap )
         {
-          for( c=0 ; c<w ; c++ )
-          {         
-            unsigned long pv = PsGetImagePixel(pImage, depth, w, h, leftPad, format, c, r);
-            PsOutColor clr = PsGetPixelColor(cMap, pv);
-            /* XXX: This needs to be fixed for endian swapping and to support
-             * depths deeper than 8bit per R-,G-,B-gun... */
-            unsigned long val = PSOUTCOLOR_TO_RGB24BIT(clr);
-            char      *ipt = (char *)&val;
-/* XXX: Is this the right way to detect the platform endianess ? */
-#if IMAGE_BYTE_ORDER == LSBFirst
+          int   rowsiz = PixmapBytePad(w, depth);
+          char *planes[3];
+          planes[0] = pImage;
+          planes[1] = &pImage[rowsiz*h];
+          planes[2] = &pImage[rowsiz*h*2];
+          for( r=0 ; r<h ; r++ )
           {
-            long l;
-            swapl(&val, l);
+            char *pt[3];
+            for( i=0 ; i<3 ;  i++ ) pt[i] = &planes[i][rowsiz*r];
+            for( c=0 ; c<w ; c++ )
+            {
+              for( i=0 ; i<3 ; i++ )
+                { PsOut_OutImageBytes(psOut, 1, &pt[i][c]); pt[i]++; }
+            }
           }
-#elif IMAGE_BYTE_ORDER == MSBFirst
-#else
-#error Unsupported byte order
-#endif
-            PsOut_OutImageBytes(psOut, 3, &ipt[1]);
+        }
+        else if( format==ZPixmap )
+        {
+          int  rowsiz = PixmapBytePad(w, depth);
+          for( r=0 ; r<h ; r++ )
+          {
+            char *pt = &pImage[rowsiz*r];
+            for( c=0 ; c<w ; c++,pt+=4 )
+            {
+              if( swap )
+              {
+                char tmp[4];
+                tmp[0] = pt[3]; tmp[1] = pt[2]; tmp[2] = pt[1]; tmp[3] = pt[0];                PsOut_OutImageBytes(psOut, 3, &tmp[1]);
+              }
+              else
+                PsOut_OutImageBytes(psOut, 3, &pt[1]);
+            }
+          }
+        }
+        else goto error;
+        PsOut_EndImage(psOut);
+      }
+      else if( depth==8 )
+      {
+        int  rowsiz = PixmapBytePad(w, depth);
+        PsOut_BeginImageIM(psOut, 0, 0, x, y, w, h, sw, sh, 3);
+        for( r=0 ; r<h ; r++ )
+        {
+          char *pt = &pImage[rowsiz*r];
+          for( c=0 ; c<w ; c++,pt++ )
+          {
+            int   val = PsGetPixelColor(cMap, (int)(*pt)&0xFF);
+            char *ipt = (char *)&val;
+            if( swap )
+            {
+              char tmp[4];
+              tmp[0] = ipt[3]; tmp[1] = ipt[2]; tmp[2] = ipt[1]; tmp[3] = ipt[0];
+              PsOut_OutImageBytes(psOut, 3, &tmp[1]);
+            }
+            else
+              PsOut_OutImageBytes(psOut, 3, &ipt[1]);
           }
         }
-
         PsOut_EndImage(psOut);
       }
+      else if( depth==1 )
+      {
+        {
+          int  rowsiz = BitmapBytePad(w);
+          int  psrsiz = (w+7)/8;
+          PsOut_BeginImageIM(psOut, PsGetPixelColor(cMap, pGC->bgPixel),
+                           PsGetPixelColor(cMap, pGC->fgPixel),
+                           x, y, w, h, sw, sh, 1);
+          for( r=0 ; r<h ; r++ )
+          {
+            char *pt = &pImage[rowsiz*r];
+            for( i=0 ; i<psrsiz ; i++ )
+            {
+              int  iv_, iv = (int)pt[i]&0xFF;
+              char c;
+              if( swap )
+                { for( j=0,iv_=0 ; j<8 ; j++ ) iv_ |= (((iv>>j)&1)<<(7-j)); }
+              else
+                iv_ = iv;
+              c = iv_;
+              PsOut_OutImageBytes(psOut, 1, &c);
+            }
+          }
+          PsOut_EndImage(psOut);
+        }
+      }
       else
       {
         int  rowsiz = BitmapBytePad(w);
@@ -323,6 +418,8 @@ PsPutScaledImageIM(DrawablePtr pDrawable
                            PsGetPixelColor(cMap, pGC->fgPixel));
 #endif
   }
+error:
+  return;
 }
 void
 PsPutImage(DrawablePtr pDrawable, GCPtr pGC, int depth, int x, int y,
@@ -355,11 +452,54 @@ PsCopyArea(DrawablePtr pSrc, DrawablePtr
   {
     PsOutPtr     psOut;
     ColormapPtr  cMap;
+/*
+** Bug 4402782: Scale xprt output
+*
+* For applications using the scaling factor, the images that are full black,
+* will not be shown. This is to prevent the spacers that are used from being
+* displayed. (This should have been taken care of with CT_REGION, but Mozilla
+* does not appear to have that done/set correctly.)
+*/
+    char *ch = src->devPrivate.ptr;
+    int wid = (int)(width/4)*4+(width%4!=0)*4;
+    int changecolor = 1;
+    int done = 0;
+    XpContextPtr pcon;
+
     if( PsUpdateDrawableGC(pGC, pDst, &psOut, &cMap)==FALSE ) return NULL;
-    PsOut_Offset(psOut, pDst->x, pDst->y);
-    PsOut_BeginFrame(psOut, dstx-srcx, dsty-srcy, dstx, dsty, width, height);
-    PsReplayPixmap(src, pDst);
-    PsOut_EndFrame(psOut);
+    if (requestingClient && (pcon = XpGetPrintContext(requestingClient)))
+    {
+      XpClientDPIPtr pClientDPI = XpClientDPIGetRec(pcon);
+      if(pClientDPI)
+      {
+        int scl_fact = pClientDPI->scale_factor;
+
+        if(scl_fact != 1.0)
+          while(changecolor && !done)
+          {
+            int x, y;
+            for(y=0;y<height && changecolor;y++)
+              for(x=0;x<width && changecolor;x++)
+                if(ch[x+y*wid] != 0)
+                   changecolor = 0;
+            done = 1;
+          }
+      }
+      else
+/*
+** Bug 4462837: Xprt does not display images with CopyArea
+*/
+         changecolor = 0;
+    }
+    if(!changecolor)
+    {
+        PsOut_Offset(psOut, pDst->x, pDst->y);
+        PsOut_BeginFrame(psOut,dstx-srcx, dsty-srcy, dstx, dsty, width, height);
+        PsReplayPixmap(src, pDst);
+        PsOut_EndFrame(psOut);
+    }
+ 
+
   }
   else PsCopyDisplayList(src, dst, dstx-srcx, dsty-srcy, dstx, dsty,
                          width, height);
--- hw/xprint/ps/PsFonts.c	2006-09-17 23:04:18.000000000 -0700
+++ hw/xprint/ps/PsFonts.c.new	2008-09-24 10:53:56.019378000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 
 Copyright 1996, 1998  The Open Group
 
@@ -155,7 +184,8 @@ PsGetPSFontName(FontPtr pFont)
   FontPropPtr props  = pFont->info.props;
   /* "_ADOBE_POSTSCRIPT_FONTNAME" maps directly to a PMF OBJ_NAME attribute
    * name - changing the name will break printer-builtin fonts. */
-  Atom        name   = MakeAtom("_ADOBE_POSTSCRIPT_FONTNAME", 26, True); 
+  /* bug4312893:Xprt:PS driver can't handle pmf font proprtly */
+  Atom        name   = MakeAtom("PRINTER_RESIDENT_FONT", 21, True);
   Atom        value  = (Atom)0;
 
   for( i=0 ; i<nprops ; i++ )
--- hw/xprint/ps/PsText.c	2006-09-17 23:04:18.000000000 -0700
+++ hw/xprint/ps/PsText.c.new	2008-09-24 10:53:56.035282000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 
 Copyright 1996, 1998  The Open Group
 
@@ -83,6 +112,47 @@ in this Software without prior written a
 #include <X11/fonts/fntfil.h>
 #include <X11/fonts/fntfilst.h>
 #include <limits.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+static int readFontName(char *fileName, char *file_name, char *dlfnam)
+{
+    FILE        *file;
+    struct stat statb;
+    int         count, i, status;
+    char        buf[256];
+    char        *front, *end, *fn;
+
+    file = fopen(fileName, "r");
+    if(file)
+    {
+        if (fstat (fileno(file), &statb) == -1)
+            return 0;
+        while(fgets(buf, 255, file))
+        {
+            if((fn = strstr(buf, " -")))
+            {
+                strcpy(file_name, buf);
+                file_name[fn - buf - 4] = '\0';
+                fn++;
+                if((front = strstr(fn, "normal-")))
+                {
+                    fn[front - fn] = '\0';
+                    if(strstr(dlfnam, fn))
+                    {
+                        fclose(file);
+                        return 1;
+                    }
+                }
+            }
+        }
+    }
+    file_name[0] = '\0';
+    fclose(file);
+    return 0;
+}
+
 
 int
 PsPolyText8(
@@ -93,6 +163,8 @@ PsPolyText8(
   int         count,
   char       *string)
 {
+  FontPtr useFont;
+
   if( pDrawable->type==DRAWABLE_PIXMAP )
   {
     DisplayElmPtr   elm;
@@ -185,26 +257,123 @@ PsPolyText8(
 
 	return x;	
     }    
-    
-    /* Render glyphs as bitmaps */
+/* Xprt should support the download Type1 font in PS mode */
+/* 00308: Bug 4402782: Scale xprt output */
+    char  *fnam, ffname[512], *dlfnam;
+    FontDirectoryPtr	dir;
+    char	file_name[MAXFONTNAMELEN];
+    XpContextPtr pCon;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
+    int client_x, server_x;
+
+    useFont = pGC->font;
+
+    pCon = PsGetContextFromWindow((WindowPtr)pDrawable);
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
     {
-        unsigned long n, i;
-        int w;
-        CharInfoPtr charinfo[255];  
+        scl_fact = pClientDPI->scale_factor;
 
-        GetGlyphs(pGC->font, (unsigned long)count, 
-            (unsigned char *)string, Linear8Bit, &n, charinfo);
-        w = 0;
-        for (i=0; i < n; i++)
-          w += charinfo[i]->metrics.characterWidth;
+        if(scl_fact != 1.0)
+        {
+            XpClientDPIGetPos(pClientDPI, &client_x, &server_x);
+            if(x == client_x && client_x != server_x)
+               x = server_x;
+            else
+            {
+               client_x = x;
+               x *= scl_fact;
+            }
+            y *= scl_fact;
 
-        if (n != 0)
-            PsPolyGlyphBlt(pDrawable, pGC, x, y, n, 
-                    charinfo, FONTGLYPHS(pGC->font));
-        x += w;
-        
-        return x;
-    }  
+            useFont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+        }
+    }
+    dir = useFont->fpe->private;
+    sprintf(ffname, "%s%s", dir->directory,
+                            "fonts.dir");
+    fnam = PsGetPSFontName(useFont);
+    if(!fnam){
+	if(!(dlfnam = PsGetFontName(useFont)))
+            return x;
+
+	/* If Type1 font, try to download to printer first */
+        if(strstr(ffname, "Type1") && readFontName(ffname, file_name, dlfnam))
+        {
+            {
+       		int		iso;
+		int		siz;
+		float		mtx[4];
+		PsOutPtr	psOut;
+		ColormapPtr  cMap;
+
+		if( PsUpdateDrawableGC(pGC, pDrawable, &psOut, &cMap)==FALSE )
+                    return x;
+       		sprintf(ffname, "%s%s%s", dir->directory, file_name, ".pfa");
+       		PsOut_DownloadType1(psOut,"PsPolyText8", file_name, ffname);
+       		PsOut_Offset(psOut, pDrawable->x, pDrawable->y);
+       		PsOut_Color(psOut, PsGetPixelColor(cMap, pGC->fgPixel));
+		siz = PsGetFontSize(useFont, mtx);
+		iso = PsIsISOLatin1Encoding(useFont);
+		if( !siz ) PsOut_TextAttrsMtx(psOut, file_name, mtx, 1);
+		else PsOut_TextAttrs(psOut, file_name, siz, 1);
+		PsOut_Text(psOut, x, y, string, count, -1);
+		if(pClientDPI)
+                   XpClientDPISetPos(pClientDPI, -1, -1);
+       		return x;
+            }
+        }
+	{
+            /* changes for supporting multibytes locales */
+            unsigned long n, i;
+            int w;
+            CharInfoPtr charinfoC[255], charinfoS[255];
+
+            GetGlyphs(useFont, (unsigned long)count,
+       		(unsigned char *)string, Linear8Bit,&n, charinfoS);
+            w = 0;
+            for (i=0; i < n; i++) w += charinfoS[i]->metrics.characterWidth;
+            if (n != 0)
+       		PsPolyGlyphBlt(pDrawable, pGC, x, y, n,
+       			charinfoS, FONTGLYPHS(useFont));
+            x += w;
+            server_x = x;
+
+            if(useFont != pGC->font)
+            {
+		GetGlyphs(pGC->font, (unsigned long)count,
+                   (unsigned char *)string, Linear8Bit,&n, charinfoC);
+       		w = 0;
+       		for (i=0; i < n; i++) w += charinfoC[i]->metrics.characterWidth;
+       		client_x += w;
+       		if(pClientDPI)
+                  XpClientDPISetPos(pClientDPI, client_x, server_x);
+            }
+	}
+   }else{
+	int		iso;
+        int		siz;
+        float		mtx[4];
+        PsOutPtr	psOut;
+        ColormapPtr  cMap;
+
+	if( PsUpdateDrawableGC(pGC, pDrawable, &psOut, &cMap)==FALSE ) return x;
+        PsOut_Offset(psOut, pDrawable->x, pDrawable->y);
+        PsOut_Color(psOut, PsGetPixelColor(cMap, pGC->fgPixel));
+        siz = PsGetFontSize(useFont, mtx);
+        iso = PsIsISOLatin1Encoding(useFont);
+        if( !siz ) PsOut_TextAttrsMtx(psOut, fnam, mtx, iso);
+        else	   PsOut_TextAttrs(psOut, fnam, siz, iso);
+        PsOut_Text(psOut, x, y, string, count, -1);
+/* CRT 00360: Xprt dies with B39 */
+        if(pClientDPI)
+           XpClientDPISetPos(pClientDPI, -1, -1);
+    }
+    
+    /* Render glyphs as bitmaps */
   }
   return x;
 }
@@ -218,6 +387,12 @@ PsPolyText16(
   int             count,
   unsigned short *string)
 {
+ 
+/*
+** Bug 4402782: Scale xprt output
+*/
+  FontPtr useFont;
+  
   if( pDrawable->type==DRAWABLE_PIXMAP )
   {
     DisplayElmPtr   elm;
@@ -347,25 +522,67 @@ PsPolyText16(
         
 	return x;	
     }
-    
-    /* Render glyphs as bitmaps */
+   
+/* 
+** Bug 4402782: Scale xprt output
+** 4457081: CRT 00360: Xprt dies with B39
+*/
+    unsigned long n, i;
+    int w;
+    CharInfoPtr charinfoC[255], charinfoS[255];	 /* encoding only has 1 byte for
+count */
+    XpContextPtr pCon;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
+    int client_x, server_x;
+
+    useFont = pGC->font;
+
+    pCon = PsGetContextFromWindow((WindowPtr)pDrawable);
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
     {
-        unsigned long n, i;
-        int w;
-        CharInfoPtr charinfo[255];  /* encoding only has 1 byte for count */
-
-        GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
-                  (FONTLASTROW(pGC->font) == 0) ? Linear16Bit : TwoD16Bit,
-                  &n, charinfo);
-        w = 0;
-        for (i=0; i < n; i++)
-          w += charinfo[i]->metrics.characterWidth;
-        if (n != 0)
-	    PsPolyGlyphBlt(pDrawable, pGC, x, y, n, charinfo, FONTGLYPHS(pGC->font));
-        x += w;
-        
-        return x;
-    }  
+	scl_fact = pClientDPI->scale_factor;
+
+	if(scl_fact != 1.0)
+	{
+            XpClientDPIGetPos(pClientDPI, &client_x, &server_x);
+            if(x == client_x && client_x != server_x)
+        	x = server_x;
+            else
+            {
+        	client_x = x;
+        	x *= scl_fact;
+            }
+            y *= scl_fact;
+            useFont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+        }
+    }
+    GetGlyphs(useFont, (unsigned long)count, (unsigned char *)string,
+        	(FONTLASTROW(useFont) == 0) ? Linear16Bit : TwoD16Bit,
+        	&n, charinfoS);
+    w = 0;
+    for (i=0; i < n; i++) w += charinfoS[i]->metrics.characterWidth;
+    if (n != 0)
+        PsPolyGlyphBlt(pDrawable, pGC, x, y, n, charinfoS, FONTGLYPHS(useFont));
+    x += w;
+    server_x = x;
+
+    if(useFont != pGC->font)
+    {
+       GetGlyphs(pGC->font, (unsigned long)count, (unsigned char *)string,
+        	 (FONTLASTROW(useFont) == 0) ? Linear16Bit : TwoD16Bit,
+        	 &n, charinfoC);
+       w = 0;
+       for (i=0; i < n; i++) w += charinfoC[i]->metrics.characterWidth;
+       client_x += w;
+       if(pClientDPI)
+          XpClientDPISetPos(pClientDPI, client_x, server_x);
+    }
+ 
+    /* Render glyphs as bitmaps */
   }
   return x;
 }
@@ -379,6 +596,12 @@ PsImageText8(
   int         count,
   char       *string)
 {
+  
+/*
+** CRT 00308: Bug 4402782: Scale xprt output
+*/
+  FontPtr useFont;
+
   if( pDrawable->type==DRAWABLE_PIXMAP )
   {
     DisplayElmPtr   elm;
@@ -409,14 +632,33 @@ PsImageText8(
     char        *fnam;
     PsOutPtr     psOut;
     ColormapPtr  cMap;
+    XpContextPtr pCon;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
+
+    useFont = pGC->font;
+
+    pCon = PsGetContextFromWindow((WindowPtr)pDrawable);
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+    {
+    	scl_fact = pClientDPI->scale_factor;
+
+	x *= scl_fact;
+        y *= scl_fact;
+        if(scl_fact != 1.0)
+            useFont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+    }
 
     if( PsUpdateDrawableGC(pGC, pDrawable, &psOut, &cMap)==FALSE ) return;
     PsOut_Offset(psOut, pDrawable->x, pDrawable->y);
     PsOut_Color(psOut, PsGetPixelColor(cMap, pGC->fgPixel));
-    fnam = PsGetPSFontName(pGC->font);
+    fnam = PsGetPSFontName(useFont);
     if( !fnam ) fnam = "Times-Roman";
-    siz = PsGetFontSize(pGC->font, mtx);
-    iso = PsIsISOLatin1Encoding(pGC->font);
+    siz = PsGetFontSize(useFont, mtx);
+    iso = PsIsISOLatin1Encoding(useFont);
     if( !siz ) PsOut_TextAttrsMtx(psOut, fnam, mtx, iso);
     else       PsOut_TextAttrs(psOut, fnam, siz, iso);
     PsOut_Text(psOut, x, y, string, count, PsGetPixelColor(cMap, pGC->bgPixel));
@@ -506,8 +748,24 @@ PsPolyGlyphBlt(
     int nbyPadGlyph;                    /* server padded line of glyph */
     int w, tmpx;
     XID gcvals[3];
+    XpContextPtr pCon;
+    XpClientDPIPtr pClientDPI;
+    float scl_fact = 1;
 
     pfont = pGC->font;
+
+    pCon = PsGetContextFromWindow((WindowPtr)pDrawable);
+
+    pClientDPI = XpClientDPIGetRec(pCon);
+
+    if(pClientDPI)
+    {
+    	scl_fact = pClientDPI->scale_factor;
+
+	if(scl_fact != 1.0)
+            pfont = XpClientDPIGrabFont(pClientDPI, pGC->font);
+    }
+
     width = FONTMAXBOUNDS(pfont,rightSideBearing) -
             FONTMINBOUNDS(pfont,leftSideBearing);
     height = FONTMAXBOUNDS(pfont,ascent) +
@@ -567,12 +825,26 @@ PsPolyGlyphBlt(
                         *pb++ = *pglyph++;
                 pb = pbits;
             }
+/*
+** CRT 00308: Bug 4402782: Scale xprt output
+** BUG: 4402350: Bitmap cache needs to send color along with uid
+*/
+
+            gcvals[0] = GXcopy;
+            gcvals[1] = pGC->fgPixel;
+            gcvals[2] = pGC->bgPixel;
+            DoChangeGC(pGCtmp, GCFunction|GCForeground|GCBackground, gcvals, 0);
+
 
 	    PsPutImageMask((DrawablePtr)pDrawable, pGCtmp, 
 		   1, x + pci->metrics.leftSideBearing, 
 		   y - pci->metrics.ascent, gWidth, gHeight,
                    0, XYBitmap, (char *)pb);
-	}
+            gcvals[0] = GXcopy;
+            gcvals[1] = 1;
+            gcvals[2] = 0;
+            DoChangeGC(pGCtmp, GCFunction|GCForeground|GCBackground, gcvals, 0);
+        }
         
         x  += pci->metrics.characterWidth;
     }
--- hw/xprint/ps/psout.h	2006-09-17 23:04:18.000000000 -0700
+++ hw/xprint/ps/psout.h.new	2008-09-24 11:00:54.446307000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 
 Copyright 1996, 1998  The Open Group
 
@@ -81,6 +110,7 @@ in this Software without prior written a
 #define _psout_
 
 #include <stdio.h>
+#include <X11/extensions/Printstr.h>
 
 typedef enum PsCapEnum_  { PsCButt=0,   PsCRound, PsCSquare    } PsCapEnum;
 typedef enum PsJoinEnum_ { PsJMiter=0,  PsJRound, PsJBevel     } PsJoinEnum;
@@ -249,11 +279,9 @@ typedef struct PsOutRec_
   int         ImgH;
   int         SclW;
   int         SclH;
-
   Bool        isRaw;
-  
   int         pagenum;
-
+  XpClientDPIPtr ClientDpi;
   int         start_image;
 } PsOutRec;
 
--- hw/xprint/ps/psout.c	2006-09-17 23:04:18.000000000 -0700
+++ hw/xprint/ps/psout.c.new	2008-09-24 11:19:44.573129000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 
 Copyright 1996, 1998  The Open Group
 
@@ -89,6 +118,18 @@ in this Software without prior written a
 #endif /* XP_USE_FREETYPE */
 /* For VENDOR_STRING and VENDOR_RELEASE */
 #include "site.h"
+/* 
+** CRT 00308: Bug 4402782: Scale xprt outpu
+*/
+#include <X11/X.h>
+#include <X11/Xproto.h>
+#include "misc.h"
+#include "windowstr.h"
+#include "scrnintstr.h"
+#include "pixmapstr.h"
+#include "extnsionst.h"
+#include "dixstruct.h"
+#include <X11/Xatom.h>
 
 /*
  *  Standard definitions
@@ -584,6 +625,13 @@ S_SetPageDevice(PsOutPtr self, int orien
  *                        PUBLIC FUNCTIONS                         *
  *******************************************************************/
 
+void
+PsOut_SetClientDPI(PsOutPtr self, XpClientDPIPtr client_dpi)
+{
+  self->ClientDpi = client_dpi;
+}
+
+
 FILE *
 PsOut_ChangeFile(PsOutPtr self, FILE *fp)
 {
@@ -695,6 +743,7 @@ PsOut_EndFile(PsOutPtr self, int closeFi
   if( self->Patterns ) xfree(self->Patterns);
   if( self->Clip.rects ) xfree(self->Clip.rects);
   if( closeFile ) fclose(self->Fp);
+  self->pagenum = 0;
   xfree(self);
 }
 
@@ -779,6 +828,10 @@ PsOut_Clip(PsOutPtr self, int clpTyp, Ps
   int  changed = 0;
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InTile ) return;
   if( self->InFrame ) xo = yo = 0;
@@ -869,10 +922,10 @@ PsOut_Clip(PsOutPtr self, int clpTyp, Ps
   {
     for( i=0 ; i<self->Clip.nOutterClips ; i++ )
     {
-      S_OutNum(self, (float)(self->Clip.outterClips[i].x));
-      S_OutNum(self, (float)(self->Clip.outterClips[i].y));
-      S_OutNum(self, (float)self->Clip.outterClips[i].w);
-      S_OutNum(self, (float)self->Clip.outterClips[i].h);
+      S_OutNum(self, (float)(self->Clip.outterClips[i].x)* scl_fact);
+      S_OutNum(self, (float)(self->Clip.outterClips[i].y)* scl_fact);
+      S_OutNum(self, (float)self->Clip.outterClips[i].w * scl_fact);
+      S_OutNum(self, (float)self->Clip.outterClips[i].h * scl_fact);
       S_OutTok(self, "R", 1);
     }
     S_OutTok(self, "cl n", 1);
@@ -881,10 +934,10 @@ PsOut_Clip(PsOutPtr self, int clpTyp, Ps
   {
     for( i=0 ; i<self->Clip.nRects ; i++ )
     {
-      S_OutNum(self, (float)(self->Clip.rects[i].x+xo));
-      S_OutNum(self, (float)(self->Clip.rects[i].y+yo));
-      S_OutNum(self, (float)self->Clip.rects[i].w);
-      S_OutNum(self, (float)self->Clip.rects[i].h);
+      S_OutNum(self, (float)(self->Clip.rects[i].x * scl_fact + xo));
+      S_OutNum(self, (float)(self->Clip.rects[i].y * scl_fact + yo));
+      S_OutNum(self, (float)self->Clip.rects[i].w * scl_fact);
+      S_OutNum(self, (float)self->Clip.rects[i].h * scl_fact);
       S_OutTok(self, "R", 1);
     }
     S_OutTok(self, "cl n", 1);
@@ -899,31 +952,35 @@ PsOut_Clip(PsOutPtr self, int clpTyp, Ps
         case PSOUT_POINTS:
           for( k=0 ; k<elm->nPoints ; k++ )
           {
-            S_OutNum(self, (float)elm->c.points[k].x+xo);
-            S_OutNum(self, (float)elm->c.points[k].y+yo);
+            S_OutNum(self, ((float)elm->c.points[k].x * scl_fact + xo));
+            S_OutNum(self, ((float)elm->c.points[k].y * scl_fact + yo));
             if( k==0 ) S_OutTok(self, "m", 0);
             else       S_OutTok(self, "l", 0);
           }
           S_OutTok(self, "cp", 1);
           break;
         case PSOUT_RECT:
-          S_OutNum(self, (float)elm->c.rect.x+xo);
-          S_OutNum(self, (float)elm->c.rect.y+yo);
-          S_OutNum(self, (float)elm->c.rect.w);
-          S_OutNum(self, (float)elm->c.rect.h);
+	  S_OutNum(self, ((float)elm->c.rect.x * scl_fact + xo));
+          S_OutNum(self, ((float)elm->c.rect.y * scl_fact + yo));
+          S_OutNum(self, (float)elm->c.rect.w * scl_fact);
+          S_OutNum(self, (float)elm->c.rect.h * scl_fact);
           S_OutTok(self, "R", 1);
           break;
         case PSOUT_ARC:
           if( elm->c.arc.style==PsPieSlice )
           {
-            S_OutNum(self, (float)elm->c.arc.x+xo+(float)elm->c.arc.w/2.);
-            S_OutNum(self, (float)elm->c.arc.y+yo+(float)elm->c.arc.h/2.);
+            S_OutNum(self, ((float)elm->c.arc.x+(float)elm->c.arc.w/2.) *
+                     scl_fact + xo);
+            S_OutNum(self, ((float)elm->c.arc.y+(float)elm->c.arc.h/2.) *
+                     scl_fact + yo);
             S_OutTok(self, "m", 0);
           }
-          S_OutNum(self, (float)elm->c.arc.x+xo+(float)elm->c.arc.w/2.);
-          S_OutNum(self, (float)elm->c.arc.y+yo+(float)elm->c.arc.h/2.);
-          S_OutNum(self, (float)elm->c.arc.w);
-          S_OutNum(self, (float)elm->c.arc.h);
+          S_OutNum(self, ((float)elm->c.arc.x+(float)elm->c.arc.w/2.) *
+                   scl_fact + xo);
+          S_OutNum(self, ((float)elm->c.arc.y+(float)elm->c.arc.h/2.) *
+                   scl_fact + yo);
+          S_OutNum(self, (float)elm->c.arc.w * scl_fact);
+          S_OutNum(self, (float)elm->c.arc.h * scl_fact);
           S_OutNum(self, (float)elm->c.arc.a1/64.);
           S_OutNum(self, (float)elm->c.arc.a1/64.+(float)elm->c.arc.a2/64.);
           if( elm->c.arc.a2<0 ) S_OutTok(self, "An cp", 1);
@@ -1052,13 +1109,18 @@ PsOut_Polygon(PsOutPtr self, int nPts, P
   int  i;
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
+
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
   if( nPts<=2 ) return;
   for( i=0 ; i<nPts ; i++ )
   {
-    S_OutNum(self, (float)(pts[i].x+xo));
-    S_OutNum(self, (float)(pts[i].y+yo));
+    S_OutNum(self, (float)(pts[i].x * scl_fact +xo) );
+    S_OutNum(self, (float)(pts[i].y * scl_fact +yo) );
     if( i==0 ) S_OutTok(self, "m", 0);
     else       S_OutTok(self, "l", 0);
   }
@@ -1071,13 +1133,18 @@ PsOut_FillRect(PsOutPtr self, int x, int
 {
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
+
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
-  x += xo; y += yo;
+  x = x * scl_fact + xo; y = y * scl_fact + yo;
   S_OutNum(self, (float)x);
   S_OutNum(self, (float)y);
-  S_OutNum(self, (float)w);
-  S_OutNum(self, (float)h);
+  S_OutNum(self, (float)w * scl_fact);
+  S_OutNum(self, (float)h * scl_fact);
   S_OutTok(self, "R fl", 1);
 }
 
@@ -1087,19 +1154,23 @@ PsOut_FillArc(PsOutPtr self, int x, int 
 {
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
   x += xo; y += yo;
   if( style==PsPieSlice )
   {
-    S_OutNum(self, (float)x+(float)w/2.);
-    S_OutNum(self, (float)y+(float)h/2.);
+    S_OutNum(self, ((float)x+(float)w/2.) * scl_fact + xo);
+    S_OutNum(self, ((float)y+(float)h/2.) * scl_fact + yo);
     S_OutTok(self, "m", 0);
   }
-  S_OutNum(self, (float)x+(float)w/2.);
-  S_OutNum(self, (float)y+(float)h/2.);
-  S_OutNum(self, (float)w);
-  S_OutNum(self, (float)h);
+  S_OutNum(self, ((float)x+(float)w/2.) * scl_fact + xo);
+  S_OutNum(self, ((float)y+(float)h/2.) * scl_fact + yo);
+  S_OutNum(self, ((float)w) * scl_fact);
+  S_OutNum(self, ((float)h) * scl_fact);
   S_OutNum(self, ang1);
   S_OutNum(self, ang1+ang2);
   if( ang2<0 ) S_OutTok(self, "An cp fl", 1);
@@ -1112,13 +1183,18 @@ PsOut_Lines(PsOutPtr self, int nPts, PsP
   int  i;
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
+
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
   if( nPts<1 ) return;
   for( i=0 ; i<nPts ; i++ )
   {
-    S_OutNum(self, (float)(pts[i].x+xo));
-    S_OutNum(self, (float)(pts[i].y+yo));
+    S_OutNum(self, (float)(pts[i].x * scl_fact + xo) );
+    S_OutNum(self, (float)(pts[i].y * scl_fact + yo) );
     if( i==0 ) S_OutTok(self, "m", 0);
     else       S_OutTok(self, "l", 0);
   }
@@ -1137,13 +1213,17 @@ PsOut_Points(PsOutPtr self, int nPts, Ps
   int  i;
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
   if( nPts<1 ) return;
   for( i=0 ; i<nPts ; i++ )
   {
-    S_OutNum(self, (float)(pts[i].x+xo));
-    S_OutNum(self, (float)(pts[i].y+yo));
+    S_OutNum(self, (float)(pts[i].x * scl_fact + xo) );
+    S_OutNum(self, (float)(pts[i].y * scl_fact + yo) );
     S_OutTok(self, "P", 1);
   }
 }
@@ -1153,13 +1233,17 @@ PsOut_DrawRect(PsOutPtr self, int x, int
 {
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
-  x += xo; y += yo;
+  x = x * scl_fact + xo; y = y * scl_fact + yo;
   S_OutNum(self, (float)x);
   S_OutNum(self, (float)y);
-  S_OutNum(self, (float)w);
-  S_OutNum(self, (float)h);
+  S_OutNum(self, (float)w * scl_fact);
+  S_OutNum(self, (float)h * scl_fact);
   S_OutTok(self, "R", 0);
   if( self->LineBClr != PSOUTCOLOR_NOCOLOR )
   {
@@ -1176,13 +1260,17 @@ PsOut_DrawArc(PsOutPtr self, int x, int 
 {
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
-  x += xo; y += yo;
-  S_OutNum(self, (float)x+(float)w/2.);
-  S_OutNum(self, (float)y+(float)h/2.);
-  S_OutNum(self, (float)w);
-  S_OutNum(self, (float)h);
+  x = x * scl_fact + xo; y = y * scl_fact + yo;
+  S_OutNum(self, ((float)x+(float)w/2.) );
+  S_OutNum(self, ((float)y+(float)h/2.) );
+  S_OutNum(self, (float)w * scl_fact);
+  S_OutNum(self, (float)h * scl_fact);
   S_OutNum(self, ang1);
   S_OutNum(self, ang1+ang2);
   if( ang2<0 ) S_OutTok(self, "An", 0);
@@ -1269,7 +1357,7 @@ PsOut_ImageCache(PsOutPtr self, int x, i
     int ib = PSOUTCOLOR_TO_BLUEBITS(bclr);
 
     if( ir==ig && ig==ib )
-      S_OutNum(self, PSOUTCOLOR_BITS_TO_PSFLOAT(ir));
+      S_OutNum(self, (float)ir/255.);
     else
       S_OutNum(self, (float)0);
       self->RevImage = 1;
@@ -1281,7 +1369,7 @@ PsOut_ImageCache(PsOutPtr self, int x, i
     int ib = PSOUTCOLOR_TO_BLUEBITS(fclr);
 
     if( ir==ig && ig==ib )
-      S_OutNum(self, PSOUTCOLOR_BITS_TO_PSFLOAT(ir));
+      S_OutNum(self, (float)ir/255.);
     else
       S_OutNum(self, (float)0);
   }
@@ -1313,14 +1401,20 @@ PsOut_BeginImage(PsOutPtr self, PsOutCol
   PsOutColor savClr = self->CurColor;
   int xo = self->XOff;
   int yo = self->YOff;
+  int x1, y1;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
 
   if( self->InFrame || self->InTile ) xo = yo = 0;
+  x1 = x * scl_fact + xo; y1 = y * scl_fact + yo;
   x += xo; y += yo;
   if( self->InTile )
   {
     if( self->InTile>=PsStip && format!=1 ) { self->ImgSkip = 1; return; }
     self->ImgBClr = bclr; self->ImgFClr = fclr;
-    self->ImgX    = x;    self->ImgY    = y;
+    self->ImgX    = x1;    self->ImgY    = y1;
     self->ImgW    = w;    self->ImgH    = h;
     self->SclW    = sw;   self->SclH    = sh;
     S_OutTok(self, "<", 0);
@@ -1349,8 +1443,8 @@ PsOut_BeginImage(PsOutPtr self, PsOutCol
       PsOut_Color(self, fclr);
     }
   }
-  S_OutNum(self, (float)x);
-  S_OutNum(self, (float)y);
+  S_OutNum(self, (float)x1);
+  S_OutNum(self, (float)y1);
   S_OutNum(self, (float)w);
   S_OutNum(self, (float)h);
   S_OutNum(self, (float)sw);
@@ -1530,15 +1624,20 @@ PsOut_BeginFrame(PsOutPtr self, int xoff
 {
   int  xo = self->XOff;
   int  yo = self->YOff;
+  float scl_fact = 1;
+
+  if(self->ClientDpi)
+    scl_fact = self->ClientDpi->scale_factor;
+
 
   if( self->InFrame ) xo = yo = 0;
   S_OutTok(self, "gs", 0);
-  S_OutNum(self, (float)(x+xo));
-  S_OutNum(self, (float)(y+yo));
-  S_OutNum(self, (float)w);
-  S_OutNum(self, (float)h);
+  S_OutNum(self, (float)(x * scl_fact + xo));
+  S_OutNum(self, (float)(y * scl_fact + yo));
+  S_OutNum(self, (float)w * scl_fact);
+  S_OutNum(self, (float)h * scl_fact);
   S_OutTok(self, "R cl n", 0);
-  xoff += xo; yoff += yo;
+  xoff = xoff * scl_fact + xo; yoff = yoff * scl_fact + yo;
   if( xoff || yoff )
   {
     S_OutNum(self, (float)xoff);
