--- dix/xpstubs.c	2008-09-04 11:36:37.719156000 -0700
+++ dix/xpstubs.c.1	2008-09-04 11:38:51.427569000 -0700
@@ -35,9 +35,9 @@ from The Open Group.
 #ifdef XPRINT
 #include "DiPrint.h"
 #else
+#if 0
 extern Bool XpClientIsBitmapClient(ClientPtr client);
 extern Bool XpClientIsPrintClient(ClientPtr client, FontPathElementPtr fpe);
-#endif
 
 Bool
 XpClientIsBitmapClient(
@@ -53,6 +53,9 @@ XpClientIsPrintClient(
 {
     return FALSE;
 }
+#endif
+#endif
+
 #ifdef XPRINT
 int
 PrinterOptions(
--- include/dpi.h	1969-12-31 16:00:00.000000000 -0800
+++ include/dpi.h.new	2008-09-24 09:56:39.448121000 -0700
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/* $XConsortium: dpi.h /main/9 1995/09/22 10:23:04 dpw $ */
+/***********************************************************
+
+Copyright (c) 1987  X Consortium
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
+X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+Except as contained in this notice, the name of the X Consortium shall not be
+used in advertising or otherwise to promote the sale, use or other dealings
+in this Software without prior written authorization from the X Consortium.
+
+
+Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of Digital not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+******************************************************************/
+#ifndef DPI_H
+#define DPI_H
+
+extern Bool XpClientDPIAdd(
+#if NeedFunctionPrototypes
+XpContextPtr, int, int
+#endif
+);
+
+extern Bool XpClientDPIGetData(
+#if NeedFunctionPrototypes
+XpContextPtr, int *, int *
+#endif
+);
+
+extern Bool XpClientDPIFindData(
+#if NeedFunctionPrototypes
+int, int *, int *
+#endif
+);
+
+extern XpClientDPIPtr XpClientDPIGetRec(
+#if NeedFunctionPrototypes
+XpContextPtr
+#endif
+);
+
+extern XpClientDPIPtr XpClientDPIFindRec(
+#if NeedFunctionPrototypes
+int
+#endif
+);
+
+extern Bool XpClientDPISet(
+#if NeedFunctionPrototypes
+XpContextPtr, int
+#endif
+);
+
+extern FontPtr XpClientDPIGrabFont(
+#if NeedFunctionPrototypes
+XpClientDPIPtr, FontPtr
+#endif
+);
+
+#endif
--- dix/dispatch.c	2008-09-23 20:00:53.010137000 -0700
+++ dix/dispatch.c.new	2008-09-24 10:10:13.109578000 -0700
@@ -1,3 +1,33 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+
 /************************************************************
 
 Copyright 1987, 1989, 1998  The Open Group
@@ -3545,6 +3575,21 @@ InitProcVectors(void)
     
 }
 
+/*
+ * BUG: 4402782: This code is called by Xext/xprint (XpExtensionInit) to
+ * change the X_OpenFont to ProcXpOpenFont and SProcOpenFont. This allows
+ * apps using scaling to load two fonts.
+ */
+void
+ChangeProcVector(int vector, int (* proc)(), int (* sproc)())
+{
+    if (vector >= 0 && vector < 256 && proc && sproc)
+    {
+	ProcVector[vector] = proc;
+	SwappedProcVector[vector] = sproc;
+    }
+} /* BUG 4402782: */
+
 /**********************
  * CloseDownClient
  *
--- dix/dixfonts.c	2008-09-23 20:00:58.340424000 -0700
+++ dix/dixfonts.c.new	2008-09-24 10:21:40.683384000 -0700
@@ -1,3 +1,32 @@
+/*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
 /************************************************************************
 Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.
 
@@ -95,6 +124,8 @@ static int  size_slept_fpes = 0;
 static FontPathElementPtr *slept_fpes = (FontPathElementPtr *) 0;
 static FontPatternCachePtr patternCache;
 
+static void (*XpSetFont)();     /* BUG 4402782: clientDPI */
+
 _X_EXPORT int
 FontToXError(err)
     int         err;
@@ -226,6 +257,20 @@ FreeFPE (FontPathElementPtr fpe)
     }
 }
 
+/*
+ * BUG: 4402782: This function is called by Xext/xprint.c (ProcXpOpenFont) to set
+ * the callback for opening a font with a scale factor. This can be done this way
+ * (IE static local variable) because it is turned on and off in the same server
+ * call, so no other job could inadvertently get the wrong value. We do not need
+ * to have this information dependent on the clientID
+ */
+void
+SetXpFontFunc(void (*func)())
+{
+    XpSetFont = func;
+}       /* BUG: 4402782 */
+
+
 static Bool
 doOpenFont(ClientPtr client, OFclosurePtr c)
 {
@@ -361,6 +406,15 @@ doOpenFont(ClientPtr client, OFclosurePt
     if (patternCache && pfont != c->non_cachable_font)
 	CacheFontPattern(patternCache, c->origFontName, c->origFontNameLen,
 			 pfont);
+    /*
+     * BUG: 4402782: Store the font pointer in the data struct. This is OK since
+     * it is only set in xprint.c (ProcXpOpenFont) and turned off immediately
+     * after as a single processing line. This means that no other print jobs
+     * could use the wrong value.
+     */
+    if (XpSetFont)
+        (* XpSetFont)(client, pfont);
+
 bail:
     if (err != Successful && c->client != serverClient) {
 	SendErrorToClient(c->client, X_OpenFont, 0,
--- Xext/xprint.c	2008-09-27 08:56:13.159552000 -0700
+++ Xext/xprint.c.new	2008-09-27 08:56:13.183691000 -0700
@@ -1,4 +1,33 @@
 /*
+ * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.
+ * Use is subject to license terms.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, and/or sell copies of the Software, and to permit persons
+ * to whom the Software is furnished to do so, provided that the above
+ * copyright notice(s) and this permission notice appear in all copies of
+ * the Software and that both the above copyright notice(s) and this
+ * permission notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
+ * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+ * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
+ * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
+ * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
+ * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder
+ * shall not be used in advertising or otherwise to promote the sale, use
+ * or other dealings in this Software without prior written authorization
+ * of the copyright holder.
+ */
+/*
 (c) Copyright 1996 Hewlett-Packard Company
 (c) Copyright 1996 International Business Machines Corp.
 (c) Copyright 1996 Sun Microsystems, Inc.
@@ -68,7 +97,7 @@ copyright holders.
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
-
+#include <stdio.h>
 #include <X11/X.h>
 #include <X11/Xos.h>
 #define NEED_EVENTS
@@ -86,6 +115,7 @@ copyright holders.
 #include "../hw/xprint/DiPrint.h"
 #include "../hw/xprint/attributes.h"
 #include "modinit.h"
+#include "resource.h"
 
 static void XpResetProc(ExtensionEntry *);
 
@@ -117,6 +147,8 @@ static int ProcXpQueryScreens(ClientPtr)
 static int ProcXpGetPageDimensions(ClientPtr);
 static int ProcXpSetImageResolution(ClientPtr);
 static int ProcXpGetImageResolution(ClientPtr);
+static int ProcXpClientDpi();           /* BUG: 4402782 */
+int ProcXpOpenFont();           /* BUG: 4402782 */
 
 static void SwapXpNotifyEvent(xPrintPrintEvent *, xPrintPrintEvent *);
 static void SwapXpAttributeEvent(xPrintAttributeEvent *, xPrintAttributeEvent *);
@@ -144,6 +176,7 @@ static int SProcXpRehashPrinterList(Clie
 static int SProcXpGetPageDimensions(ClientPtr);
 static int SProcXpSetImageResolution(ClientPtr);
 static int SProcXpGetImageResolution(ClientPtr);
+static int SProcXpClientDpi();
 
 static void SendXpNotify(XpContextPtr, int, int);
 static void SendAttributeNotify(XpContextPtr, int);
@@ -169,6 +202,8 @@ typedef struct  _xpScreen {
     struct _driver *drivers;
 } XpScreenRec, *XpScreenPtr;
 
+static XpClientDPIPtr client_dpi_head;          /* BUG: 4402782 */
+
 /*
  * Each context has a list of XpClients indicating which clients have
  * associated this context with their connection.
@@ -236,6 +271,8 @@ static int XpErrorBase;
 static unsigned long XpGeneration = 0;
 static int XpClientPrivateIndex;
 
+static int client_server_font;          /* BUG: 4402782 */
+
 /* Variables for the context private machinery. 
  * These must be initialized at compile time because
  * main() calls InitOutput before InitExtensions, and the
@@ -270,6 +307,287 @@ static RESTYPE RTclient, RTcontext, RTpa
  */
 static CARD32 allEvents = XPPrintMask | XPAttributeMask;
 
+/*******************************************************************************
+ *
+ * BUG: 4402782: ClientDPI Add, Remove, Search
+ *
+ ******************************************************************************/
+
+/*
+ * Create an entry for the clientDPI to be stored. This entry will hold lookup
+ * information (context and clientAsMask), and the font and scaling information.
+ */
+Bool
+XpClientDPIAdd(context, clientAsMask, client_dpi)       /* Bug: 4402782 */
+XpContextPtr context;
+int clientAsMask;
+int client_dpi;
+{
+    XpClientDPIPtr new;
+    XpClientDPIPtr temp = client_dpi_head;
+    int found = 0;
+
+    /*
+     * Check if the client already has an entry in the list
+     */
+    while(temp != NULL)
+    {
+        if(temp->context == context)
+            found = 1;
+        temp = temp->pNext;
+    }
+
+    /*
+     * If not, then create a new entry
+     */
+    if (!found)
+    {
+        new = (XpClientDPIPtr)malloc(sizeof(XpClientDPIRec));
+
+        if(new == NULL)
+            return FALSE;
+
+        new->pNext = client_dpi_head;
+        new->pPrev = NULL;
+        new->head  = NULL;
+        new->context = context;
+        new->client_dpi = client_dpi;
+        new->clientAsMask = clientAsMask;
+        new->scale_factor = 1;
+        new->client_x = -1;
+        new->server_x = -1;
+
+        /*
+         * Put the new entry at the head of the list
+         */
+        client_dpi_head = new;
+    }
+
+    return TRUE;
+}       /* Bug: 4402782 */
+
+/*
+ * This function is currently not called. This is not a good state, but we cannot
+ * call the function at the end of the document since the client is still connected
+ * and believe that fonts that were opened are still open for it. (They are, but this * list contains the links to go between the fonts). Need to check if there is a way
+ * to remove the client when the client terminates its connection with Xprt?
+ */
+static Bool
+XpClientDPIRemove(context)      /* Bug: 4402782 */
+XpContextPtr context;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    /*
+     * Search the list for the correct context
+     */
+    while(!found && temp != NULL)
+    {
+        if(temp->context != context)
+            temp = temp->pNext;
+        else
+        {
+            XpClientFontsPtr temp2;
+
+            /*
+             * Once it is found, then remove it from this list
+             */
+            found = TRUE;
+            if(temp->pPrev != NULL)
+                temp->pPrev->pNext = temp->pNext;
+            else
+                client_dpi_head = temp->pNext;
+
+            if(temp->pNext != NULL)
+                temp->pNext->pPrev = temp->pPrev;
+
+            temp2 = temp->head;
+
+            /*
+             * Free the fonts??
+             */
+            while(temp2 != NULL)
+            {
+                XpClientFontsPtr item_free = temp2;
+                temp2 = temp2->pNext;
+
+                /*
+                 * Do we need to actually free the font here, or will the
+                 * client dying take care of that?
+                 */
+                free(item_free);
+            }
+
+
+            free(temp);
+        }
+    }
+
+    return found;
+}       /* Bug: 4402782 */
+
+/*
+ * Return the DPI and scale factor the the caller
+ */
+Bool
+XpClientDPIGetData(context, pDPI, pSF)  /* Bug: 4402782 */
+XpContextPtr context;
+int *pDPI;
+float *pSF;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    while(!found && temp != NULL)
+    {
+        if(temp->context != context)
+            temp = temp->pNext;
+        else
+        {
+            found = TRUE;
+            *pDPI = temp->client_dpi;
+            *pSF  = temp->scale_factor;
+        }
+    }
+
+    return found;
+}       /* Bug: 4402782 */
+
+/*
+ * Return the DPI and scale factor the the caller
+ */
+Bool
+XpClientDPIFindData(clientAsMask, pDPI, pSF)    /* Bug: 4402782 */
+int clientAsMask;
+int *pDPI;
+float *pSF;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    while(!found && temp != NULL)
+    {
+        if(temp->clientAsMask != clientAsMask)
+            temp = temp->pNext;
+        else
+        {
+            found = TRUE;
+            *pDPI = temp->client_dpi;
+            *pSF  = temp->scale_factor;
+        }
+    }
+    return found;
+}       /* Bug: 4402782 */
+
+/*
+ * Return the DPI and scale factor the the caller
+ */
+XpClientDPIPtr
+XpClientDPIGetRec(context)      /* Bug: 4402782 */
+XpContextPtr context;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    while(!found && temp != NULL)
+    {
+        if(temp->context != context)
+            temp = temp->pNext;
+        else
+            found = TRUE;
+    }
+
+    if(!found)
+        temp = NULL;
+
+    return temp;
+}       /* Bug: 4402782 */
+
+XpClientDPIPtr
+XpClientDPIFindRec(clientAsMask)        /* Bug: 4402782 */
+int clientAsMask;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    while(!found && temp != NULL)
+    {
+        if(temp->clientAsMask != clientAsMask)
+            temp = temp->pNext;
+        else
+            found = TRUE;
+    }
+
+    if(!found)
+        temp = NULL;
+
+    return temp;
+}       /* Bug: 4402782 */
+
+Bool
+XpClientDPISet(context, serverDPI)      /* Bug: 4402782 */
+XpContextPtr context;
+int serverDPI;
+{
+    XpClientDPIPtr temp = client_dpi_head;
+    Bool found = FALSE;
+
+    while(!found && temp != NULL)
+    {
+        if(temp->context != context)
+            temp = temp->pNext;
+        else
+        {
+            found = TRUE;
+            temp->scale_factor = (float)serverDPI/(float)temp->client_dpi;
+        }
+    }
+
+    return found;
+}       /* Bug: 4402782 */
+
+FontPtr
+XpClientDPIGrabFont(pClientDPI, pFont)  /* Bug: 4402782 */
+XpClientDPIPtr pClientDPI;
+FontPtr pFont;
+{
+    FontPtr tempFont = pFont;
+    Bool found = FALSE;
+    XpClientFontsPtr temp = pClientDPI->head;
+
+    while(temp != NULL && !found)
+        if(temp->client_font == pFont)
+        {
+            tempFont = temp->server_font;
+            found = TRUE;
+        }
+        else
+            temp = temp->pNext;
+
+    return tempFont;
+}       /* Bug: 4402782 */
+
+void
+XpClientDPIGetPos(pClientDPI, pCx, pSx) /* Bug: 4402782 */
+XpClientDPIPtr pClientDPI;
+int *pCx;
+int *pSx;
+{
+    *pCx = pClientDPI->client_x;
+    *pSx = pClientDPI->server_x;
+}
+
+void
+XpClientDPISetPos(pClientDPI, Cx, Sx)   /* Bug 4402782 */
+XpClientDPIPtr pClientDPI;
+int Cx;
+int Sx;
+{
+    pClientDPI->client_x = Cx;
+    pClientDPI->server_x = Sx;
+}
+
 
 /*******************************************************************************
  *
@@ -336,6 +654,15 @@ XpExtensionInit(INITARGS)
 	}
     }
     DeclareExtensionSecurity(XP_PRINTNAME, TRUE);
+    /*
+     * BUG: 4402782: Client DPI. Set the font open function to new Xprt functions
+     *               that will do font renaming/ double opening if necessary.
+     */
+    {
+        extern int SProcOpenFont();
+
+        ChangeProcVector(X_OpenFont, ProcXpOpenFont, SProcOpenFont);
+    } /* BUG: 4402782 */
 }
 
 static void
@@ -495,6 +822,8 @@ ProcXpDispatch(ClientPtr client)
             return ProcXpSetImageResolution(client);
 	case X_PrintGetImageResolution:
             return ProcXpGetImageResolution(client);
+	case X_PrintClientDpi:
+            return ProcXpClientDpi(client);
 	default:
 	    return BadRequest;
     }
@@ -560,8 +889,10 @@ ProcXpSwappedDispatch(ClientPtr client)
             return SProcXpSetImageResolution(client);
 	case X_PrintGetImageResolution:
             return SProcXpGetImageResolution(client);
-	default:
-	    return BadRequest;
+	case X_PrintClientDpi:
+            return SProcXpClientDpi(client);
+        default:
+            return BadRequest;
     }
 }
 
@@ -742,7 +1073,9 @@ ProcXpGetPageDimensions(ClientPtr client
     xRectangle rect;
     xPrintGetPageDimensionsReply rep;
     XpContextPtr pContext;
+    XpClientDPIPtr pClientDPI;
     int result;
+    float scl_fact = 1;
 
     REQUEST_SIZE_MATCH(xPrintGetPageDimensionsReq);
 
@@ -760,6 +1093,13 @@ ProcXpGetPageDimensions(ClientPtr client
        (pContext->funcs.GetReproducibleArea == 0))
         return BadImplementation;
 
+    /*
+     * BUG: 4402782: Client DPI: Get the scale factor for this client
+     */
+    pClientDPI = XpClientDPIGetRec(pContext);
+    if(pClientDPI)
+        scl_fact = pClientDPI->scale_factor;
+
     result = pContext->funcs.GetMediumDimensions(pContext, &width, &height);
     if(result != Success)
         return result;
@@ -771,12 +1111,12 @@ ProcXpGetPageDimensions(ClientPtr client
     rep.type = X_Reply;
     rep.sequenceNumber = client->sequence;
     rep.length = 0;
-    rep.width = width;
-    rep.height = height;
+    rep.width = (CARD16)(width / scl_fact);     /* BUG: 4402782 */
+    rep.height = (CARD16)(height / scl_fact);   /* BUG: 4402782 */
     rep.rx = rect.x;
     rep.ry = rect.y;
-    rep.rwidth = rect.width;
-    rep.rheight = rect.height;
+    rep.rwidth = (CARD16)(rect.width / scl_fact);       /* BUG: 4402782 */
+    rep.rheight = (CARD16)(rect.height / scl_fact);     /* BUG: 4402782 */
 
     if(client->swapped)
     {
@@ -885,6 +1225,220 @@ ProcXpGetImageResolution(ClientPtr clien
     return client->noClientException;
 }
 
+static int
+ProcXpClientDpi(client) /* BUG: 4402782: Accept the client DPI request */
+    ClientPtr client;
+{
+    REQUEST(xPrintClientDpiReq);
+    xPrintClientDpiReply rep;
+    XpContextPtr pContext;
+    Bool status;
+
+    REQUEST_SIZE_MATCH(xPrintClientDpiReq);
+
+    if((pContext = (XpContextPtr)client->devPrivates[XpClientPrivateIndex].ptr)
+       == (XpContextPtr)NULL)
+    {
+        client->errorValue = stuff->printContext;
+        return XpErrorBase+XPBadContext;
+    }
+
+    /*
+     * Create a new client entry with the specified DPI
+     */
+    status = XpClientDPIAdd(pContext, client->clientAsMask, stuff->clientDPI);
+
+    /*
+     * Send a response back to the client application
+     */
+    rep.type = X_Reply;
+    rep.sequenceNumber = client->sequence;
+    rep.length = 0;
+    rep.status = status;
+
+    WriteToClient(client, sz_xPrintClientDpiReply, (char *)&rep);
+    return client->noClientException;
+}       /* BUG: 4402782 */
+
+void
+ProcXpSetFont(client, pFont)    /* BUG: 4402782: Store the client or server font */
+    register ClientPtr client;
+    FontPtr pFont;
+{
+    XpClientDPIPtr clientDPI;
+
+    clientDPI = XpClientDPIFindRec(client->clientAsMask);
+
+    /*
+     * This static local variable is set below and is a straight processing line.
+     * No other processes could break in and misuse this.
+     */
+    if(client_server_font == 1)
+        clientDPI->head->client_font = pFont;
+    else
+        clientDPI->head->server_font = pFont;
+}       /* BUG: 4402782 */
+
+void
+ProcXpMakeFontName(font_name, font_len, base_name, base_len, client_dpi)/* BUG: 4402782 */
+    char *font_name;
+    int  *font_len;
+    char *base_name;
+    int   base_len;
+    int   client_dpi;
+{
+    int x, num = 0;
+
+    /*
+     * Create a new font name (xlfd) using the clients DPI values.
+     */
+    for(x=0;x<base_len;x++)
+        if(base_name[x] == '-')
+            if(++num == 7)
+            {
+                strncpy(font_name, base_name, x+1);
+                strcat(font_name, "0-");
+                *font_len = x + 3;
+            }
+            else if( num == 8)
+            {
+                char size[10];
+                int  pixels;
+
+                sscanf(&base_name[x+1], "%d", &pixels);
+                sprintf(size, "%d", pixels);
+                strcat(font_name, size);
+                strcat(font_name, "-");
+                *font_len += strlen(size) + 1;
+            }
+            else if( num == 9 || num == 10)
+            {
+                char size[10];
+
+                sprintf(size, "%d", client_dpi);
+                strcat(font_name, size);
+                strcat(font_name, "-");
+                *font_len += strlen(size) + 1;
+            }
+            else if( num == 11)
+            {
+                strncat(font_name, &base_name[x+1], base_len - x);
+                *font_len += (base_len - x - 1);
+            }
+            else
+	    {
+	    }
+}       /* BUG: 4402782 */
+
+
+int
+ProcXpOpenFont(client)  /* BUG: 4402782 */
+    register ClientPtr client;
+{
+    int err;
+    int client_dpi;
+    float scl_fact = 1;
+    int open_two = 0;
+    int new_fid;
+    XpClientDPIPtr clientDPI;
+
+    /*
+     * Basically this function replaces ProcOpenFont for Xp. It serves the same
+     * purpose, but if the client has specified a scale factor other than 1.0,
+     * this function will create two xlfd font names and open both fonts.
+     */
+    REQUEST(xOpenFontReq);
+
+    REQUEST_FIXED_SIZE(xOpenFontReq, stuff->nbytes);
+    client->errorValue = stuff->fid;
+    LEGAL_NEW_RESOURCE(stuff->fid, client);
+
+    /*
+     * Create the second file id just in case it is necessary
+     */
+    new_fid = 2 * client->clientAsMask | RESOURCE_ID_MASK - stuff->fid;
+
+    /*
+     * Get the data on whether we need to load two fonts
+     */
+    clientDPI = XpClientDPIFindRec(client->clientAsMask);
+
+    if(clientDPI != NULL)
+    {
+        client_dpi = clientDPI->client_dpi;
+        scl_fact   = clientDPI->scale_factor;
+
+        /*
+         * If the scale factor is not 1, then find a free, valid new_fid.
+         */
+        if(scl_fact != 1)
+        {
+            while(!LegalNewID(new_fid, client) &&
+                   new_fid > stuff->fid)
+                new_fid--;
+
+            if(new_fid > stuff->fid)
+                open_two = 1;
+        }
+    }
+
+    /*
+     * Check if we need to open the second font
+     */
+    if (open_two)
+    {
+        XpClientFontsPtr new;
+        char *font_name;
+        int   font_len = 0;
+        int   x, num = 0;
+
+        font_name = (char *)malloc(sizeof(char)*stuff->nbytes+4);
+        memset(font_name, 0, stuff->nbytes+4);
+
+        new = (XpClientFontsPtr)malloc(sizeof(XpClientFontsRec));
+
+        if(font_name && new)
+        {
+            new->pNext = clientDPI->head;
+            clientDPI->head = new;
+
+            ProcXpMakeFontName(font_name, &font_len, &stuff[1], stuff->nbytes, client_dpi);
+
+            /*
+             * This is the part that gets interesting. We set the callback to store
+             * the font data in the clientDPI entry. First open the client font.
+             */
+            SetXpFontFunc(ProcXpSetFont);
+            client_server_font = 1;
+            err = OpenFont(client, stuff->fid, (Mask) 0, font_len, font_name);
+
+            /*
+             * Next open the server font (the big one), then cancel the callback
+             */
+            client_server_font = 2;
+            err = OpenFont(client, new_fid, (Mask) 0, stuff->nbytes, (char *)&stuff[1]);
+            SetXpFontFunc(NULL);
+
+            /*
+             * Add the new fids to the DPI structure
+             */
+            new->client_fid = stuff->fid;
+            new->server_fid = new_fid;
+        }
+    }
+    /*
+     * Just open the one font. No need to open two.
+     */
+    else
+        err = OpenFont(client, stuff->fid, (Mask) 0, stuff->nbytes, (char *)&stuff[1]);
+
+
+    if (err == Success)
+        return(client->noClientException);
+    else
+        return err;
+}       /* BUG: 4402782 */
+
 /*******************************************************************************
  *
  * RehashPrinterList : Cause the server's list of printers to be rebuilt.
@@ -1497,7 +2051,7 @@ ProcXpStartJob(ClientPtr client)
 {
     REQUEST(xPrintStartJobReq);
     XpContextPtr pContext;
-    int result = Success;
+    int ires, result = Success;         /* BUG: 4402782 */
 
     REQUEST_SIZE_MATCH(xPrintStartJobReq);
 
@@ -1528,6 +2082,13 @@ ProcXpStartJob(ClientPtr client)
 
     SendXpNotify(pContext, XPStartJobNotify, FALSE);
 
+    /*
+     * BUG: 4402782: Get the target printer DPI. Use this information to set the
+     * scale factor in the client entry
+     */
+    ires = XpGetResolution(pContext);
+    XpClientDPISet(pContext, ires);
+
     if (client->noClientException != Success)
         return client->noClientException;
     else
@@ -2724,6 +3285,20 @@ SProcXpGetImageResolution(ClientPtr clie
     return ProcXpGetImageResolution(client);
 }
 
+static int
+SProcXpClientDpi(client)        /* BUG: 4402782 */
+    ClientPtr client;
+{
+    long n;
+    int i;
+
+    REQUEST(xPrintClientDpiReq);
+    swaps(&stuff->length, i);
+    swapl(&stuff->printContext, n);
+    return ProcXpClientDpi(client);
+}       /* BUG: 4402782 */
+
+
 static void
 SwapXpNotifyEvent(xPrintPrintEvent *src, xPrintPrintEvent *dst)
 {
