# Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
# Use subject to license terms.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, provided that the above
# copyright notice(s) and this permission notice appear in all copies of
# the Software and that both the above copyright notice(s) and this
# permission notice appear in supporting documentation.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
# OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
# INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# 
# Except as contained in this notice, the name of a copyright holder
# shall not be used in advertising or otherwise to promote the sale, use
# or other dealings in this Software without prior written authorization
# of the copyright holder.

diff -urp -x '*~' -x '*.orig' Xext/Makefile.am Xext/Makefile.am
--- Xext/Makefile.am	2007-09-20 14:28:19.261551000 -0700
+++ Xext/Makefile.am	2007-09-20 14:28:43.819660000 -0700
@@ -153,6 +153,12 @@ endif
 TSOL_SRCS = tsolCompat.c
 BUILTIN_SRCS += $(TSOL_SRCS)
 
+# Project Looking Glass Extension
+LGE_SRCS = lge.c
+if LGE
+BUILTIN_SRCS += $(LGE_SRCS)
+endif
+
 # Now take all of the above, mix well, bake for 10 minutes and get libXext*.la
 
 libXext_la_SOURCES =		$(BUILTIN_SRCS) $(MODULE_SRCS)
@@ -182,5 +188,6 @@ EXTRA_DIST = \
 	$(EXTRA_MULTIBUFFER_SRCS) \
 	$(FONTCACHE_SRCS) \
 	$(BIGFONT_SRCS) \
-	$(DPMS_SRCS)
+	$(DPMS_SRCS) \
+	$(LGE_SRCS) 
 
diff -urp -x '*~' -x '*.orig' configure.ac configure.ac
--- configure.ac	2007-09-20 14:28:19.766564000 -0700
+++ configure.ac	2007-09-20 14:28:43.826445000 -0700
@@ -444,6 +444,7 @@ AC_ARG_ENABLE(appgroup,       AS_HELP_ST
 AC_ARG_ENABLE(xcalibrate,     AS_HELP_STRING([--enable-xcalibrate], [Build XCalibrate extension (default: disabled)]), [XCALIBRATE=$enableval], [XCALIBRATE=no])
 AC_ARG_ENABLE(tslib,          AS_HELP_STRING([--enable-tslib], [Build kdrive tslib touchscreen support (default: disabled)]), [TSLIB=$enableval], [TSLIB=no])
 AC_ARG_ENABLE(xevie,          AS_HELP_STRING([--disable-xevie], [Build XEvIE extension (default: enabled)]), [XEVIE=$enableval], [XEVIE=yes])
+AC_ARG_ENABLE(lge,            AS_HELP_STRING([--disable-lge], [Build Project Looking Glass extension (default: enabled)]), [LGE=$enableval], [LGE=yes])
 AC_ARG_ENABLE(cup,            AS_HELP_STRING([--disable-cup], [Build TOG-CUP extension (default: enabled)]), [CUP=$enableval], [CUP=yes])
 AC_ARG_ENABLE(evi,            AS_HELP_STRING([--disable-evi], [Build Extended-Visual-Information extension (default: enabled)]), [EVI=$enableval], [EVI=yes])
 AC_ARG_ENABLE(multibuffer,    AS_HELP_STRING([--enable-multibuffer], [Build Multibuffer extension (default: disabled)]), [MULTIBUFFER=$enableval], [MULTIBUFFER=no])
@@ -674,6 +675,12 @@ if test "x$XEVIE" = xyes; then
 	REQUIRED_MODULES="$REQUIRED_MODULES evieproto"
 fi
 
+AM_CONDITIONAL(LGE, [test "x$LGE" = xyes])
+if test "x$LGE" = xyes; then
+	AC_DEFINE(LGE, 1, [Build Project Looking Glass extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES lg3dproto"
+fi
+
 AM_CONDITIONAL(APPGROUP, [test "x$APPGROUP" = xyes])
 if test "x$APPGROUP" = xyes; then
 	if test "x$XACE" != xyes || test "x$XCSECURITY" != xyes; then
@@ -897,7 +904,7 @@ CORE_INCS='-I$(top_srcdir)/include -I$(t
 PKG_CHECK_MODULES([XSERVERCFLAGS], [$REQUIRED_MODULES $REQUIRED_LIBS])
 PKG_CHECK_MODULES([XSERVERLIBS], [$REQUIRED_LIBS])
 
-XSERVER_CFLAGS="${XSERVERCFLAGS_CFLAGS}"
+XSERVER_CFLAGS="${XSERVERCFLAGS_CFLAGS} -DLG3D"
 LIBS="${LIBS} -lproject"
 XSERVER_LIBS="${XSERVERLIBS_LIBS} ${SYS_LIBS} ${LIBS}"
 AC_SUBST([SYS_LIBS])
diff -urp -x '*~' -x '*.orig' dix/Makefile.am dix/Makefile.am
--- dix/Makefile.am	2007-09-20 14:28:18.529208000 -0700
+++ dix/Makefile.am	2007-09-20 14:28:43.826833000 -0700
@@ -30,7 +30,8 @@ libdix_la_SOURCES = 	\
 	swapreq.c	\
 	tables.c	\
 	window.c	\
-	strcasecmp.c
+	strcasecmp.c    \
+        xytosubwin.c
 
 libxpstubs_la_SOURCES =	\
 	xpstubs.c
diff -urp -x '*~' -x '*.orig' dix/events.c dix/events.c
--- dix/events.c	2007-09-20 14:28:19.287006000 -0700
+++ dix/events.c	2007-09-20 14:28:43.829681000 -0700
@@ -167,6 +167,23 @@ xEvent *xeviexE;
 #include "dixgrabs.h"
 #include "dispatch.h"
 
+#ifdef LG3D
+
+#include <X11/extensions/damagewire.h>
+#include "../Xext/lgeint.h"
+
+extern void
+fillSpriteTraceFromRootToWin (WindowPtr pWin);
+
+extern WindowPtr XYToSubWindow (WindowPtr pWin, int x, int y, 
+				int *xWinRel, int *yWinRel);
+
+Bool PointInBorderSize(WindowPtr pWin, int x, int y);
+
+extern Window GetLgPrwFromSprite(void);
+
+#endif /* LG3D */
+
 #define EXTENSION_EVENT_BASE  64
 
 #define NoSuchEvent 0x80000000	/* so doesn't match NoEventMask */
@@ -230,10 +247,18 @@ static struct {
  * windows between the root and the current pointer window each time a button
  * or key goes down. The grabs on each of those windows must be checked.
  */
+#ifdef LG3D
+WindowPtr *spriteTrace = (WindowPtr *)NULL;
+WindowPtr lgeCurrentRootWin;
+#define ROOT spriteTrace[0]
+int spriteTraceSize = 0;
+int spriteTraceGood;
+#else
 static WindowPtr *spriteTrace = (WindowPtr *)NULL;
 #define ROOT spriteTrace[0]
 static int spriteTraceSize = 0;
 static int spriteTraceGood;
+#endif /* LG3D */
 
 static  struct {
     CursorPtr	current;
@@ -255,6 +280,15 @@ static  struct {
 #endif
 } sprite;			/* info about the cursor sprite */
 
+#ifdef LG3D
+typedef struct virtual_sprite {
+    WindowPtr win;              /* The top-level window the sprite is in (or PRW) */
+    HotSpot   hot;		/* Sprite location relative to win */
+} VirtualSprite;
+
+static VirtualSprite virtualSprite = { NULL, {0, 0} };
+#endif /* LG3D */
+
 #ifdef XEVIE
 _X_EXPORT WindowPtr xeviewin;
 _X_EXPORT HotSpot xeviehot;
@@ -1160,7 +1194,28 @@ ComputeFreezes()
 	count = replayDev->sync.evcount;
 	syncEvents.replayDev = (DeviceIntPtr)NULL;
 
+#ifdef LG3D	
+	{ WindowPtr pWin = (WindowPtr) LookupIDByType(XE_KBPTR.event, RT_WINDOW);
+	  if (lgeDisplayServerIsAlive && GetLgePRWForRoot(pWin)) {
+	      if (sprite.hotPhys.pScreen != pWin->drawable.pScreen) {
+		  w = XYToSubWindow(pWin, 
+				    xE->u.keyButtonPointer.eventX, xE->u.keyButtonPointer.eventY,
+				    &virtualSprite.hot.x, &virtualSprite.hot.y);
+		  if (IsWinLgePRWOne(w->drawable.id)) {
+		      ErrorF("ComputeFreezes %d %d seq %d\n", (int)xE->u.keyButtonPointer.event,
+			     (int)w->drawable.id, xE->u.u.sequenceNumber);
+		  }
+	      } else {
+    	    	w = XYToWindow( XE_KBPTR.rootX, XE_KBPTR.rootY);	
+	      }
+	  } else {
+	      w = XYToWindow( XE_KBPTR.rootX, XE_KBPTR.rootY);	
+	  }
+	}
+#else
         w = XYToWindow( XE_KBPTR.rootX, XE_KBPTR.rootY);
+#endif /* LG3D */
+
 	for (i = 0; i < spriteTraceGood; i++)
 	{
 	    if (syncEvents.replayWin == spriteTrace[i])
@@ -1770,6 +1825,151 @@ MaybeDeliverEventsToClient(register Wind
     return 2;
 }
 
+#ifdef LG3D
+
+/*
+** Returns true if the event type is one which was generated
+** by an input device. These are the only types of events
+** which been sent to the Display Server so they are the only
+** types of events which have the event field already set.
+**
+** TODO: this macro does not yet support XINPUT devices.
+*/
+
+#define EVENT_IS_DEVICE_EVENT(e) \
+    ((e)->u.u.type == KeyPress      || \
+     (e)->u.u.type == KeyRelease    || \
+     (e)->u.u.type == ButtonPress   || \
+     (e)->u.u.type == ButtonRelease || \
+     (e)->u.u.type == MotionNotify)
+
+static void
+lgeFixUpEventFromPRW(
+    xEvent *xE,
+    WindowPtr pWin,
+    Window child,
+    Bool calcChild)
+{
+    XE_KBPTR.root = ROOT->drawable.id;
+
+    /* 
+    ** If the non-3D event is going to the DS (e.g. because 
+    ** of a grab) make the the coordinates relative to the PRW 
+    ** (that is, screen absolute),
+    */
+
+    if (!IsWinLgePRWOne(XE_KBPTR.event)) {
+	WindowPtr pOldWin = (WindowPtr) LookupIDByType(XE_KBPTR.event, RT_WINDOW);
+	if (pOldWin != NULL) {
+	    XE_KBPTR.eventX = XE_KBPTR.rootX;
+	    XE_KBPTR.eventY = XE_KBPTR.rootY;
+	}
+    }
+
+    XE_KBPTR.event = pWin->drawable.id;
+
+    if (sprite.hot.pScreen != pWin->drawable.pScreen)
+    {
+	XE_KBPTR.sameScreen = xFalse;
+        /*
+	XE_KBPTR.child = None;
+	XE_KBPTR.eventX = 0;
+	XE_KBPTR.eventY = 0;
+	*/
+    } else {
+	XE_KBPTR.sameScreen = xTrue;
+    }
+}
+
+static void
+lgeFixUpEventFromXWindow(
+    xEvent *xE,
+    WindowPtr pWin,
+    Window child,
+    Bool calcChild)
+{
+    Window eventWindowOld = INVALID;
+
+    if (calcChild)
+    {
+        WindowPtr w=spriteTrace[spriteTraceGood-1];
+	/* If the search ends up past the root should the child field be 
+	   set to none or should the value in the argument be passed 
+	   through. It probably doesn't matter since everyone calls 
+	   this function with child == None anyway. */
+
+        while (w) 
+        {
+            /* If the source window is same as event window, child should be
+	       none.  Don't bother going all all the way back to the root. */
+
+ 	    if (w == pWin)
+	    { 
+   		child = None;
+ 		break;
+	    }
+	    
+	    if (w->parent == pWin)
+	    {
+		child = w->drawable.id;
+		break;
+            }
+ 	    w = w->parent;
+        } 	    
+    }
+
+    XE_KBPTR.root = WindowTable[sprite.hotPhys.pScreen->myNum]->drawable.id;    
+    eventWindowOld = XE_KBPTR.event;
+    XE_KBPTR.event = pWin->drawable.id;
+
+    XE_KBPTR.sameScreen = xTrue;
+    if (sprite.hot.pScreen != pWin->drawable.pScreen)
+    {
+	XE_KBPTR.sameScreen = xFalse;
+	/*
+	XE_KBPTR.child = None;
+	XE_KBPTR.eventX = 0;
+	XE_KBPTR.eventY = 0;
+	*/
+	/* TODO: Amir commented this out. Does we really want to not return? */
+	return;
+    }
+
+    XE_KBPTR.child = child;
+
+    /* 
+    ** The only events needing fixup at this point are mouse events
+    ** where the event window has been changed.
+    */
+    if ((xE->u.u.type == ButtonPress   ||
+	 xE->u.u.type == ButtonRelease  ||
+	 xE->u.u.type == MotionNotify)  &&
+	eventWindowOld != XE_KBPTR.event) {
+
+	/* TODO: it would be good to avoid a resource lookup here. Some sort of 
+	   caching might optimize this */
+	WindowPtr pOuterWin = (WindowPtr) LookupIDByType(eventWindowOld, RT_WINDOW);
+	if (pOuterWin == NULL) {
+	    /*
+	    ** This can happen if the window has died since the pick on the window
+	    ** occurred. So we don't need to be verbose about it.
+	    ErrorF("Error: FixupEventFromWindow: outer window %d, not found. No XY fix up occuring.\n",
+	           eventWindowOld);
+	    */
+	} else {
+	    /* 
+	    ** Make the event coords relative to the destination window
+	    ** instead of relative to the outer window.
+	    */
+	    XE_KBPTR.eventX -= pWin->drawable.x - pOuterWin->drawable.x;
+	    XE_KBPTR.eventY -= pWin->drawable.y - pOuterWin->drawable.y;
+	    /*ErrorF("new eventxy = %d, %d", XE_KBPTR.eventX, XE_KBPTR.eventY);*/
+	}		    
+    }
+}
+
+#endif /* LG3D */
+
 static void
 FixUpEventFromWindow(
     xEvent *xE,
@@ -1777,6 +1977,17 @@ FixUpEventFromWindow(
     Window child,
     Bool calcChild)
 {
+#ifdef LG3D
+    if (lgeDisplayServerIsAlive && GetLgePRWForRoot(pWin)) {
+	if (EVENT_IS_DEVICE_EVENT(xE) && IsWinLgePRWOne(pWin->drawable.id)) {
+	    lgeFixUpEventFromPRW(xE, pWin, child, calcChild);
+	} else {
+	    lgeFixUpEventFromXWindow(xE, pWin, child, calcChild);
+	}
+	return;
+    }
+#endif /* LG3D */
+
     if (calcChild)
     {
         WindowPtr w=spriteTrace[spriteTraceGood-1];
@@ -1824,6 +2035,163 @@ FixUpEventFromWindow(
     }
 }
 
+#ifdef LG3D
+
+/* 
+** Fix LG3D bug 293.
+** This is similar to CheckMotion, but for button events 
+*/
+
+static WindowPtr
+lg3dDetermineButtonDestWindow (xEvent *xE, WindowPtr spriteWin)
+{
+   WindowPtr pEventWin;
+   WindowPtr pDestWin;
+   int       xDummy, yDummy;
+
+   if (!lgeDisplayServerIsAlive) {
+       /* Backwards compatibility: the LG DS isn't running */
+       return spriteWin;
+   } 
+
+   if (IsWinLgePRWOne(XE_KBPTR.event)) {
+       /* This is a 3D event. Always send these to the PRW */
+       return GetLgePRWWinFor(XE_KBPTR.event);
+   }
+
+   /* 
+   ** At this point, we know that it is a 2D native window event.
+   ** Determine the appropriate subwindow to which the event should be sent.
+   */
+   pEventWin = (WindowPtr) LookupIDByType(XE_KBPTR.event, RT_WINDOW); 
+   if (pEventWin == NULL) {
+       /* 
+       ** This may happen if the top-level destination window has been destroyed
+       ** since the pick was performed. So just make sure that the event is discarded.
+       */
+       return NULL;
+   }
+
+   pDestWin = XYToSubWindow(pEventWin, XE_KBPTR.eventX, XE_KBPTR.eventY,
+			    &xDummy, &yDummy);
+
+   return pDestWin;
+}
+
+static int
+DeliverDeviceEventsXorg(register WindowPtr pWin, register xEvent *xE, GrabPtr grab, 
+			register WindowPtr stopAt, DeviceIntPtr dev, int count)
+{
+    Window child = None;
+    int type = xE->u.u.type;
+    Mask filter = filters[type];
+    int deliveries = 0;
+#ifdef LG3D
+    WindowPtr tmpWin;
+#endif /* LG3D */
+
+    if (type & EXTENSION_EVENT_BASE)
+    {
+	register OtherInputMasks *inputMasks;
+	int mskidx = dev->id;
+
+	inputMasks = wOtherInputMasks(pWin);
+	if (inputMasks && !(filter & inputMasks->deliverableEvents[mskidx]))
+	    return 0;
+	while (pWin)
+	{
+	    if (inputMasks && (inputMasks->inputEvents[mskidx] & filter))
+	    {
+		FixUpEventFromWindow(xE, pWin, child, FALSE);
+		deliveries = DeliverEventsToWindow(pWin, xE, count, filter,
+						   grab, mskidx);
+		if (deliveries > 0)
+		    return deliveries;
+	    }
+#ifdef LG3D
+	    tmpWin = (pWin->parent) ? pWin->parent : pWin;
+#endif /* LG3D */
+	    if ((deliveries < 0) ||
+		(pWin == stopAt) ||
+#ifdef LG3D
+		/*
+		** Stop propogating when the parent of the window is the PRW.
+		** This prevents events that are not caught by any X11 window from
+		** being sent back to the the Display Server, because the DS can
+		** misinterpret these.
+		** TODO: we need to decide if a server change is the best way to 
+		** deal with this problem, or whether the DS or WM can do something 
+		** about it.
+		*/
+		(lgeDisplayServerIsAlive && (pWin->parent)
+		&& pWin->parent->drawable.id == IsWinLgePRWOne(tmpWin->drawable.id)) ||
+#endif /* LG3D */
+		(inputMasks &&
+		 (filter & inputMasks->dontPropagateMask[mskidx])))
+		return 0;
+	    child = pWin->drawable.id;
+	    pWin = pWin->parent;
+	    if (pWin)
+		inputMasks = wOtherInputMasks(pWin);
+	}
+    }
+    else
+    {
+	if (!(filter & pWin->deliverableEvents))
+	    return 0;
+	while (pWin)
+	{
+	    if ((wOtherEventMasks(pWin)|pWin->eventMask) & filter)
+	    {
+		FixUpEventFromWindow(xE, pWin, child, FALSE);
+		deliveries = DeliverEventsToWindow(pWin, xE, count, filter,
+						   grab, 0);
+		if (deliveries > 0)
+		    return deliveries;
+	    }
+#ifdef LG3D
+	    tmpWin = (pWin->parent) ? pWin->parent : pWin;
+#endif /* LG3D */
+	    if ((deliveries < 0) ||
+		(pWin == stopAt) ||
+#ifdef LG3D
+		/* See comment above */		
+		(lgeDisplayServerIsAlive 		
+		&& pWin->parent->drawable.id == IsWinLgePRWOne(tmpWin->drawable.id)) ||
+#endif /* LG3D */
+		(filter & wDontPropagateMask(pWin)))
+		return 0;
+	    child = pWin->drawable.id;
+	    pWin = pWin->parent;
+	}
+    }
+    return 0;
+}
+
+int
+DeliverDeviceEvents (WindowPtr pSpriteWin, xEvent *xE, GrabPtr grab, 
+		     WindowPtr stopAt, DeviceIntPtr dev, int count)
+{
+    int ret;
+
+    /* 
+    ** Fix LG3D bug 293: make sure that we send button events for
+    ** 2D to a subwindow of the top-level window that the DS Picker
+    ** has chosen.
+    */
+    if (xE->u.u.type == ButtonPress || xE->u.u.type == ButtonRelease) {
+	WindowPtr pDestWin = lg3dDetermineButtonDestWindow(xE, pSpriteWin);
+	if (pDestWin == NULL) return 0;
+	ret = DeliverDeviceEventsXorg(pDestWin, xE, grab, stopAt, dev, count);
+    } else {
+	ret = DeliverDeviceEventsXorg(pSpriteWin, xE, grab, stopAt, dev, count);
+    }
+
+    return ret;
+}
+
+#else
+
 int
 DeliverDeviceEvents(register WindowPtr pWin, register xEvent *xE, GrabPtr grab, 
                     register WindowPtr stopAt, DeviceIntPtr dev, int count)
@@ -1887,6 +2255,8 @@ DeliverDeviceEvents(register WindowPtr p
     return 0;
 }
 
+#endif /* LG3D */
+
 /* not useful for events that propagate up the tree or extension events */
 _X_EXPORT int
 DeliverEvents(register WindowPtr pWin, register xEvent *xE, int count, 
@@ -1927,7 +2297,11 @@ DeliverEvents(register WindowPtr pWin, r
 }
 
 
+#ifdef LG3D
+Bool 
+#else
 static Bool 
+#endif /* LG3D */
 PointInBorderSize(WindowPtr pWin, int x, int y)
 {
     BoxRec box;
@@ -2052,10 +2426,58 @@ CheckMotion(xEvent *xE)
 	XE_KBPTR.rootY = sprite.hot.y;
     }
 
+#ifdef LG3D
+   if (lgeDisplayServerIsAlive
+       && (GetLgPrwFromSprite() != INVALID)) {
+
+	if (xE == NULL) {
+	    /* WindowsRestructured case */
+	    /* TODO: this may change */
+	    sprite.win = XYToWindow(sprite.hot.x, sprite.hot.y);
+	    virtualSprite.hot.x = sprite.hot.x - sprite.win->drawable.x;
+	    virtualSprite.hot.y = sprite.hot.y - sprite.win->drawable.y;
+	} else if (XE_KBPTR.event == IsWinLgePRWOne(XE_KBPTR.event)) {
+	    /* 3D Event */
+	    sprite.win = GetLgePRWWinFor(XE_KBPTR.event);
+	    virtualSprite.hot.x = sprite.hot.x;
+	    virtualSprite.hot.y = sprite.hot.y;
+
+	    /* We must keep the sprite trace up-to-date */
+	    if (sprite.win != NULL) {
+		fillSpriteTraceFromRootToWin(sprite.win);
+	    }
+	} else {
+	    /* Normal X Event */
+	    WindowPtr pEventWin = (WindowPtr) LookupIDByType(XE_KBPTR.event, RT_WINDOW); 
+	    if (pEventWin == NULL) {
+		/* 
+		** TODO: this may not be the best way to handle this case,
+		** but it's better than doing an XYToWindow, because XYToWindow
+		** may return the PRW, and if we send a native window event to 
+		** the PRW there won't be a corresponding evinfo, so the DS will crash.
+		*/
+		return FALSE;
+	    }
+	    lgeCurrentRootWin = WindowTable[sprite.hotPhys.pScreen->myNum];
+	    sprite.win = XYToSubWindow(pEventWin, 
+				       XE_KBPTR.eventX, XE_KBPTR.eventY,
+				       &virtualSprite.hot.x, &virtualSprite.hot.y);
+	}
+	virtualSprite.win = sprite.win;
+
+    } else {
+	sprite.win = XYToWindow(sprite.hot.x, sprite.hot.y);
+    }
+#ifdef XEVIE
+    xeviewin = sprite.win;
+#endif
+#else
 #ifdef XEVIE
     xeviewin =
 #endif
     sprite.win = XYToWindow(sprite.hot.x, sprite.hot.y);
+#endif /* LG3D */
+
 #ifdef notyet
     if (!(sprite.win->deliverableEvents &
 	  Motion_Filter(inputInfo.pointer->button))
@@ -2861,7 +3283,16 @@ drawable.id:0;
     else
 	DeliverFocusedEvent(keybd, xE, sprite.win, count);
     if (deactivateGrab)
+#ifdef LG3D
+    /* Make sure any queued events which are released are sent to the DS */
+    { int prevComesFromDS = lgeEventComesFromDS;
+      lgeEventComesFromDS = 0;   
+      (*keybd->DeactivateGrab)(keybd);
+      lgeEventComesFromDS = prevComesFromDS;
+    }
+#else
         (*keybd->DeactivateGrab)(keybd);
+#endif /* LG3D */
 
 #ifdef XACE
     XaceHook(XACE_KEY_AVAIL, xE, keybd, count);
@@ -2930,6 +3361,36 @@ ProcessPointerEvent (register xEvent *xE
     }
 #endif
 
+#ifdef LG3D
+    if (lgeDisplayServerIsAlive && 
+	!lgePickerClient->clientGone &&
+	!lgeEventComesFromDS) {
+	Window prw = GetLgPrwFromSprite();
+	if (prw != INVALID) {
+	    xEvent *e = xE;
+	    int i;
+
+	    for (i = 0; i < count; i++, e++) {
+		/*
+		  ErrorF("Send event XS->DS, type = %d xy = %d, %d, state = 0x%x\n", 
+		  e->u.u.type, e->u.keyButtonPointer.rootX, 
+		  e->u.keyButtonPointer.rootY,
+		  e->u.keyButtonPointer.state);
+		  */
+		
+		/* Note: the root id of raw device events on LG screens is the prw */
+		e->u.keyButtonPointer.root = prw;
+
+		e->u.keyButtonPointer.child = 0;
+
+		WriteEventsToClient(lgePickerClient, 1, e);
+	    }
+
+	    return;
+	}
+    }
+#endif /* LG3D */
+
     if (!syncEvents.playingEvents)
 	NoticeTime(xE)
     XE_KBPTR.state = (butc->state | (
@@ -3011,7 +3472,16 @@ ProcessPointerEvent (register xEvent *xE
 	DeliverDeviceEvents(sprite.win, xE, NullGrab, NullWindow,
 			    mouse, count);
     if (deactivateGrab)
+#ifdef LG3D
+    /* Make sure any queued events which are released are sent to the DS */
+    { int prevComesFromDS = lgeEventComesFromDS;
+      lgeEventComesFromDS = 0;   
+      (*mouse->DeactivateGrab)(mouse);
+      lgeEventComesFromDS = prevComesFromDS;
+    }
+#else
         (*mouse->DeactivateGrab)(mouse);
+#endif /* LG3D */
 }
 
 #define AtMostOneClient \
@@ -3995,8 +4465,29 @@ ProcQueryPointer(ClientPtr client)
     if (sprite.hot.pScreen == pWin->drawable.pScreen)
     {
 	rep.sameScreen = xTrue;
+#ifdef LG3D
+	/* 
+	** TODO: this only works when pWin is the top-level
+        ** window (or a descendent of the top level window)
+	** of the current virtual sprite window. We haven't
+	** yet figured out what the semantics should be for
+	** the case where this is not true.
+	*/
+        if (lgeDisplayServerIsAlive &&
+    	    (GetLgPrwFromSprite() != INVALID) &&
+	    virtualSprite.win != NULL) {
+	    rep.winX = virtualSprite.win->drawable.x + virtualSprite.hot.x -
+		       pWin->drawable.x;
+            rep.winY = virtualSprite.win->drawable.y + virtualSprite.hot.y -
+		       pWin->drawable.y;
+	} else {
+	    rep.winX = sprite.hot.x - pWin->drawable.x;
+	    rep.winY = sprite.hot.y - pWin->drawable.y;
+	}
+#else
 	rep.winX = sprite.hot.x - pWin->drawable.x;
 	rep.winY = sprite.hot.y - pWin->drawable.y;
+#endif /* LG3D */
 	for (t = sprite.win; t; t = t->parent)
 	    if (t->parent == pWin)
 	    {
@@ -4621,3 +5112,17 @@ WriteEventsToClient(ClientPtr pClient, i
 	(void)WriteToClient(pClient, count * sizeof(xEvent), (char *) events);
     }
 }
+
+#ifdef LG3D
+
+Window
+GetLgPrwFromSprite(void)
+{
+    WindowPtr pWin = GetLgePRWForRoot(WindowTable[sprite.hotPhys.pScreen->myNum]);
+    if (pWin == NULL) {
+	return INVALID;
+    }
+    return pWin->drawable.id;
+}
+
+#endif /* LG3D */
diff -urp -x '*~' -x '*.orig' dix/extension.c dix/extension.c
--- dix/extension.c	2007-09-20 14:28:18.534141000 -0700
+++ dix/extension.c	2007-09-20 14:28:43.830242000 -0700
@@ -63,6 +63,10 @@ SOFTWARE.
 #include "xace.h"
 #endif
 
+#ifdef LG3D
+#include "../Xext/lgeint.h"
+#endif /* LG3D */
+
 #define EXTENSION_BASE  128
 #define EXTENSION_EVENT_BASE  64
 #define LAST_EVENT  128
@@ -70,11 +74,19 @@ SOFTWARE.
 
 ScreenProcEntry AuxillaryScreenProcs[MAXSCREENS];
 
+#ifdef LG3D
+ExtensionEntry **extensions = (ExtensionEntry **)NULL;
+#else 
 static ExtensionEntry **extensions = (ExtensionEntry **)NULL;
+#endif /* LG3D */
 
 int lastEvent = EXTENSION_EVENT_BASE;
 static int lastError = FirstExtensionError;
+#ifdef LG3D
+unsigned int NumExtensions = 0;
+#else
 static unsigned int NumExtensions = 0;
+#endif /* LG3D */
 
 extern int extensionPrivateLen;
 extern unsigned *extensionPrivateSizes;
@@ -381,6 +393,12 @@ ProcListExtensions(ClientPtr client)
 	    if (!XaceHook(XACE_EXT_ACCESS, client, extensions[i]))
 		continue;
 #endif
+#ifdef LG3D
+	    if (lgeDisplayServerIsAlive &&
+		!lgeCompatibleExtension(extensions[i])) {
+		continue;
+	    }
+#endif /* LG3D */
 	    total_length += strlen(extensions[i]->name) + 1;
 	    reply.nExtensions += 1 + extensions[i]->num_aliases;
 	    for (j = extensions[i]->num_aliases; --j >= 0;)
@@ -397,6 +415,12 @@ ProcListExtensions(ClientPtr client)
 	    if (!XaceHook(XACE_EXT_ACCESS, client, extensions[i]))
 		continue;
 #endif
+#ifdef LG3D
+	    if (lgeDisplayServerIsAlive &&
+		!lgeCompatibleExtension(extensions[i])) {
+		continue;
+	    }
+#endif /* LG3D */
             *bufptr++ = len = strlen(extensions[i]->name);
 	    memmove(bufptr, extensions[i]->name,  len);
 	    bufptr += len;
diff -urp -x '*~' -x '*.orig' include/globals.h include/globals.h
--- include/globals.h	2006-09-17 23:04:18.000000000 -0700
+++ include/globals.h	2007-09-20 14:28:43.830529000 -0700
@@ -184,4 +184,8 @@ extern Bool noXIdleExtension;
 extern Bool noXvExtension;
 #endif
 
+#ifdef LG3D
+extern Bool noLgeExtension;
+#endif
+
 #endif /* !_XSERV_GLOBAL_H_ */
diff -urp -x '*~' -x '*.orig' mi/miinitext.c mi/miinitext.c
--- mi/miinitext.c	2007-09-20 14:28:19.434320000 -0700
+++ mi/miinitext.c	2007-09-20 14:28:43.892780000 -0700
@@ -90,6 +90,11 @@ SOFTWARE.
 #include "extnsionst.h"
 #endif
 
+#ifdef LG3D
+#include "scrnintstr.h"
+#include "../miext/damage/damage.h"
+#endif /* LG3D */
+
 #if defined(QNX4) /* sleaze for Watcom on QNX4 ... */
 #undef GLXEXT
 #endif
@@ -116,6 +121,7 @@ SOFTWARE.
 #undef XFIXES
 #undef XEVIE
 #undef SolarisIAExtension
+#undef LG3D
 #else
 #ifndef LOADABLEPRINTDDX
 #undef XPRINT
@@ -188,6 +194,9 @@ extern Bool noXCMiscExtension;
 #ifdef XEVIE
 extern Bool noXevieExtension;
 #endif
+#ifdef LG3D
+extern Bool noLgeExtension;
+#endif /* LG3D */
 #ifdef XF86BIGFONT
 extern Bool noXFree86BigfontExtension;
 #endif
@@ -410,6 +419,9 @@ extern void IAExtensionInit(void);
 #ifdef TSOL
 extern void TsolExtensionInit(void);
 #endif
+#ifdef LG3D
+extern void LgeExtensionInit(INITARGS);
+#endif
 
 /* The following is only a small first step towards run-time
  * configurable extensions.
@@ -525,6 +537,9 @@ static ExtensionToggle ExtensionToggleLi
 #ifdef XV
     { "XVideo", &noXvExtension },
 #endif
+#ifdef LG3D
+    { "LGE", &noLgeExtension },
+#endif /* LG3D */
     { NULL, NULL }
 };
 
@@ -561,6 +576,53 @@ InitExtensions(argc, argv)
     int		argc;
     char	*argv[];
 {
+#ifdef LG3D
+    /*
+    ** This is a workaround for LG bug 488.
+    ** 
+    ** Problem: 
+    ** 
+    ** 1. Damage must be initialized before composite, otherwise you get that garbage rectangle.
+    ** 
+    ** 2. For Solaris Xorg, I implemented a wa for another bug which forced damage to be initialized 
+    ** after InitOutput. Part 1 of the wa was in miSpriteInitialize where I skipped DamageSetup
+    ** and Part 2 was in the -DXFree86LOADER version of InitExtensions, where I called
+    ** DamageSetup before any other extensions are initialized. The -DXFree86LOADER case
+    ** is the case used by Xorg.
+    ** 
+    ** 3. I skipped the workaround in the Xvfb case. DamageSetup was still being called from 
+    ** InitOutput and therefore was getting called before InitExtensions. 
+    ** 
+    ** 4. The skipping was achieved by eliminating Part 1 of my wa when -DXVFB. In 6.8.2,
+    ** this caused InitOutput to call DamageSetup, thereby ensuring that it was called
+    ** before composite was initialized.
+    ** 
+    ** 5. THE PROBLEM - Part A: in 6.9, Xvfb is no longer compiled with -DXVFB. Therefore Part 1
+    ** of my workaround was getting applied to both Xorg and Xvfb. So, in Xvfb 6.9,
+    ** InitOutput no longer calls DamageSetup.
+    ** 
+    ** 6. THE PROBLEM - Part B: The other part of the problem is that I had put Part 2
+    ** of the original bug wa only in the -DXFree86LOADER case of InitExtensions. 
+    ** Unfortunately, Xvfb uses the -UXFree86LOADER case. Also unfortunately, 
+    ** composite appears before damage in this function. So composite was getting 
+    ** initialized BEFORE damage, not after it.
+    ** 
+    ** 7. THE FIX: since the only way we can distinguish between Xorg and Xvfb 
+    ** initialization is in the version of InitExtension used, we will make
+    ** Part 1 of the original bug wa (the one in miSpriteInitialize) apply 
+    ** to both Xorg and Xvfb (we can't distinguish them in this function
+    ** anyway). Then we will make sure that DamageSetup gets called first in 
+    ** BOTH versions of InitExtension. This will fix the bug.
+    */
+    int	s;
+
+    for (s = 0; s < screenInfo.numScreens; s++) {
+	if (!DamageSetup (screenInfo.screens[s])) {
+	    FatalError("DamageSetup: initialization failed for screen %d.\n", s);
+	}
+    }
+#endif /* LG3D */
+
 #ifdef XCSECURITY
     SecurityExtensionSetup();
 #endif
@@ -706,6 +768,9 @@ InitExtensions(argc, argv)
 	}
     }
 #endif
+#ifdef LG3D
+    if (!noLgeExtension) LgeExtensionInit();
+#endif
 }
 
 void
@@ -776,6 +841,9 @@ static ExtensionModule staticExtensions[
 #ifdef XEVIE
     { XevieExtensionInit, "XEVIE", &noXevieExtension, NULL },
 #endif 
+#ifdef LG3D
+    { LgeExtensionInit, "LGE", &noLgeExtension, NULL },
+#endif 
     { NULL, NULL, NULL, NULL, NULL }
 };
     
@@ -789,6 +857,21 @@ InitExtensions(argc, argv)
     ExtensionModule *ext;
     static Bool listInitialised = FALSE;
 
+#ifdef LG3D
+    /*
+    ** Workaround for LG3D bug 329 (Part 2 of 2. For Part 1, 
+    ** Refer to misprite.c). DamageSetup must be called after
+    ** InitOutput is complete, but before CompositeExtensionInit.
+    */
+    int	s;
+
+    for (s = 0; s < screenInfo.numScreens; s++) {
+	if (!DamageSetup (screenInfo.screens[s])) {
+	    FatalError("DamageSetup: initialization failed for screen %d.\n", s);
+	}
+    }
+#endif /* LG3D */
+
     if (!listInitialised) {
 	/* Add built-in extensions to the list. */
 	for (i = 0; staticExtensions[i].name; i++)
diff -urp -x '*~' -x '*.orig' mi/misprite.c mi/misprite.c
--- mi/misprite.c	2006-09-17 23:04:18.000000000 -0700
+++ mi/misprite.c	2007-09-20 14:28:43.893409000 -0700
@@ -156,8 +156,23 @@ miSpriteInitialize (pScreen, cursorFuncs
     miSpriteScreenPtr	pScreenPriv;
     VisualPtr		pVisual;
     
+#if !defined(LG3D)
+    /*
+    ** Workaround for LG3D bug 329 (Part 1 of 2. For Part 2, 
+    ** Refer to xf86IniExt.c). DamageSetup must be called after
+    ** InitOutput is complete, but before CompositeExtensionInit.
+    **
+    ** Calling DamageSetup here causes screen op wrapping to occur during 
+    ** InitOutput. The Solaris x86 Nvidia driver changes the screen ops 
+    ** after calling miSpriteInitialize and this messes up the wrapping. 
+    ** To achieve the proper wrapping, we don't want to initialize the 
+    ** Damage and Composite Wrapper wrappers here, but rather, we want 
+    ** to initialize them during InitExtensions. So skip this 
+    ** initialization call.
+    */
     if (!DamageSetup (pScreen))
 	return FALSE;
+#endif /* !LG3D */
 
     if (miSpriteGeneration != serverGeneration)
     {
diff -urp -x '*~' -x '*.orig' os/utils.c os/utils.c
--- os/utils.c	2007-09-20 14:28:19.683418000 -0700
+++ os/utils.c	2007-09-20 14:28:43.900842000 -0700
@@ -236,6 +236,9 @@ _X_EXPORT Bool noXIdleExtension = FALSE;
 #ifdef XV
 _X_EXPORT Bool noXvExtension = FALSE;
 #endif
+#ifdef LG3D
+Bool noLgeExtension = FALSE;
+#endif 
 
 #define X_INCLUDE_NETDB_H
 #include <X11/Xos_r.h>
diff -urp -x '*~' -x '*.orig' xkb/xkbPrKeyEv.c xkb/xkbPrKeyEv.c
--- xkb/xkbPrKeyEv.c	2006-09-17 23:04:18.000000000 -0700
+++ xkb/xkbPrKeyEv.c	2007-09-20 14:28:43.901278000 -0700
@@ -39,6 +39,10 @@ THE USE OR PERFORMANCE OF THIS SOFTWARE.
 #include <X11/extensions/XKBsrv.h>
 #include <ctype.h>
 
+#ifdef LG3D
+#include "../Xext/lgeint.h"
+extern Window GetLgPrwFromSprite();
+#endif /* LG3D */
 
 /***====================================================================***/
 
@@ -51,6 +55,35 @@ int		key;
 XkbBehavior	behavior;
 unsigned        ndx;
 
+#ifdef LG3D
+    if (lgeDisplayServerIsAlive && 
+	!lgePickerClient->clientGone &&
+	!lgeEventComesFromDS) {
+	Window prw = GetLgPrwFromSprite();
+	if (prw != INVALID) {
+	    xEvent *e = xE;
+	    int i;
+
+	    for (i = 0; i < count; i++, e++) {
+		/*
+		  ErrorF("Send event XS->DS, type = %d xy = %d, %d, state = 0x%x\n", 
+		  e->u.u.type, e->u.keyButtonPointer.rootX, 
+		  e->u.keyButtonPointer.rootY,
+		  e->u.keyButtonPointer.state);
+		  */
+			   
+		/* Note: the root id of raw device events on LG screens is the prw */
+		e->u.keyButtonPointer.root = prw;
+
+		e->u.keyButtonPointer.child = 0;
+
+		WriteEventsToClient(lgePickerClient, 1, xE);
+	    }
+	    return;
+	}
+    }
+#endif /* LG3D */
+
     xkbi= keyc->xkbInfo;
     key= xE->u.u.detail;
 #ifdef DEBUG
