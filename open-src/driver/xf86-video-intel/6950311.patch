--- src/pch_crt.c	Thu May 27 09:22:55 2010
+++ src/pch_crt.c	Thu May 27 09:31:35 2010
@@ -40,10 +40,15 @@
 {
     ScrnInfoPtr	    pScrn = output->scrn;
     I830Ptr	    pI830 = I830PTR(pScrn);
-    uint32_t	    temp;
+    uint32_t	    temp, reg;
 
+    if (IS_IGDNG(pI830))
+        reg = PCH_ADPA;
+    else
+    	reg = ADPA;
+   
+    temp = INREG(reg);
 
-    temp = INREG(PCH_ADPA);
     temp &= ~(ADPA_HSYNC_CNTL_DISABLE | ADPA_VSYNC_CNTL_DISABLE);
     temp &= ~ADPA_DAC_ENABLE;
 
@@ -67,7 +72,7 @@
     }
 
     _debug("crt dpms 0x%x", temp);
-    OUTREG(PCH_ADPA, temp);
+    OUTREG(reg, temp);
 }
 
 static void
@@ -129,26 +134,49 @@
     I830Ptr		    pI830 = I830PTR(pScrn);
     xf86CrtcPtr		    crtc = output->crtc;
     I830CrtcPrivatePtr	    i830_crtc = crtc->driver_private;
-    uint32_t		    adpa = 0;
+    int                            dpll_md_reg;
+    uint32_t               adpa, dpll_md;
+    uint32_t               adpa_reg;
+    
+    if (i830_crtc->pipe == 0)
+          dpll_md_reg = DPLL_A_MD;
+    else
+        dpll_md_reg = DPLL_B_MD;
+    
+    if (IS_IGDNG(pI830))
+        adpa_reg = PCH_ADPA;
+    else
+        adpa_reg = ADPA;
 
-    /*
-    adpa = INREG(PCH_ADPA);
+    /* Disable separate mode multiplier used when cloning SDVO to CRT
+     * XXX this needs to be adjusted when we really are cloning
+     */
+    if (IS_I965G(pI830) && !IS_IGDNG(pI830)) {
+     	dpll_md = INREG(dpll_md_reg);
+     	OUTREG(dpll_md_reg,
+        dpll_md & ~DPLL_MD_UDI_MULTIPLIER_MASK);
+    }
+
+    adpa = 0;
+
     if (adjusted_mode->Flags & V_PHSYNC)
 	adpa |= ADPA_HSYNC_ACTIVE_HIGH;
     if (adjusted_mode->Flags & V_PVSYNC)
 	adpa |= ADPA_VSYNC_ACTIVE_HIGH;
-	*/
 
-    /* This is trancoder_A/B actually, although keep to use
-       origin bit definition here */
-    if (i830_crtc->pipe == 0)
-	adpa |= ADPA_PIPE_A_SELECT;
-    else
-	adpa |= ADPA_PIPE_B_SELECT;
+    if (i830_crtc->pipe == 0) {
+          adpa |= ADPA_PIPE_A_SELECT;
+          if (!IS_IGDNG(pI830))
+                OUTREG(BCLRPAT_A, 0);
+    } else {
+          adpa |= ADPA_PIPE_B_SELECT;
+          if (!IS_IGDNG(pI830))
+                OUTREG(BCLRPAT_B, 0);
+    }
 
     _debug("crt mode_set 0x%x", adpa);
 
-    OUTREG(PCH_ADPA, adpa);
+    OUTREG(adpa_reg, adpa);
 }
 
 /**
@@ -162,12 +190,12 @@
 {
     ScrnInfoPtr	pScrn = output->scrn;
     I830Ptr	pI830 = I830PTR(pScrn);
-    uint32_t	adpa, temp;
+    uint32_t	adpa;
     Bool	ret;
 
     /* PCH CRT hotplug is within PCH_ADPA itself */
 
-    temp = adpa = INREG(PCH_ADPA);
+    adpa = INREG(PCH_ADPA);
 
     adpa &= ~ADPA_CRT_HOTPLUG_MASK;
 
@@ -181,19 +209,18 @@
     _debug("pch crt adpa 0x%x", adpa);
     OUTREG(PCH_ADPA, adpa);
 
-    /* This might not be needed as not specified in spec...*/
-    usleep(1000);
+    while ((INREG(PCH_ADPA) & ADPA_CRT_HOTPLUG_FORCE_TRIGGER) != 0)
+        ;
 
     /* Check the status to see if both blue and green are on now */
     adpa = INREG(PCH_ADPA);
-    if ((adpa & ADPA_CRT_HOTPLUG_MONITOR_MASK) ==
-	    ADPA_CRT_HOTPLUG_MONITOR_COLOR)
+    adpa &= ADPA_CRT_HOTPLUG_MONITOR_MASK;
+    if ((adpa == ADPA_CRT_HOTPLUG_MONITOR_COLOR) ||
+           (adpa == ADPA_CRT_HOTPLUG_MONITOR_COLOR))
 	ret = TRUE;
     else
 	ret = FALSE;
 
-    /* restore origin register */
-    OUTREG(PCH_ADPA, temp);
     return ret;
 }
 
--- src/i810_reg.h	Thu May 27 10:20:20 2010
+++ src/i810_reg.h	Thu May 27 10:26:48 2010
@@ -57,6 +57,37 @@
 #define DACWX    0x3C8		/* p233 */
 #define DACDATA  0x3C9		/* p233 */
 
+/* VGA stuff */
+
+#define VGA_ST01_MDA 0x3ba
+#define VGA_ST01_CGA 0x3da
+
+#define VGA_MSR_WRITE 0x3c2
+#define VGA_MSR_READ 0x3cc
+#define   VGA_MSR_MEM_EN (1<<1)
+#define   VGA_MSR_CGA_MODE (1<<0)
+
+#define VGA_SR_INDEX 0x3c4
+#define VGA_SR_DATA 0x3c5
+
+#define VGA_AR_INDEX 0x3c0
+#define   VGA_AR_VID_EN (1<<5)
+#define VGA_AR_DATA_WRITE 0x3c0
+#define VGA_AR_DATA_READ 0x3c1
+
+#define VGA_GR_INDEX 0x3ce
+#define VGA_GR_DATA 0x3cf
+
+#define VGA_DACMASK 0x3c6
+#define VGA_DACRX 0x3c7
+#define VGA_DACWX 0x3c8
+#define VGA_DACDATA 0x3c9
+
+#define VGA_CR_INDEX_MDA 0x3b4
+#define VGA_CR_DATA_MDA 0x3b5
+#define VGA_CR_INDEX_CGA 0x3d4
+#define VGA_CR_DATA_CGA 0x3d5
+
 /* CRT Controller Registers (CRX) */
 #define START_ADDR_HI        0x0C /* p246 */
 #define START_ADDR_LO        0x0D /* p247 */
@@ -137,6 +168,9 @@
 #define STANDARD_VGA_MODE      0x00
 #define HIRES_MODE             0x01
 
+#define VGA_SR_INDEX 0x3c4
+#define VGA_SR_DATA 0x3c5
+
 /* p375
  */
 #define PIXPIPE_CONFIG_0   0x70009
@@ -917,6 +951,13 @@
 #define PP_OFF_DELAYS	0x6120c
 #define PP_DIVISOR	0x61210
 
+#define PCH_PP_STATUS          0xc7200
+#define PCH_PP_CONTROL         0xc7204
+
+#define PCH_PP_ON_DELAYS       0xc7208
+#define PCH_PP_OFF_DELAYS      0xc720c
+#define PCH_PP_DIVISOR         0xc7210
+
 #define PFIT_CONTROL	0x61230
 # define PFIT_ENABLE				(1 << 31)
 /* Pre-965 */
@@ -1196,6 +1237,13 @@
 #define BLC_PWM_CTL		0x61254
 #define BACKLIGHT_MODULATION_FREQ_SHIFT		(17)
 #define BACKLIGHT_MODULATION_FREQ_SHIFT2	(16)
+
+#define BLC_PWM_CPU_CTL                0x48254
+#define BLC_PWM_CPU_CTL2       0x48250
+
+#define BLC_PWM_PCH_CTL1       0xc8250
+#define BLC_PWM_PCH_CTL2       0xc8254
+
 /**
  * This is the most significant 15 bits of the number of backlight cycles in a
  * complete cycle of the modulated backlight control.
@@ -1365,6 +1413,10 @@
 #define ADPA_HSYNC_ACTIVE_HIGH	(1<<3)
 #define ADPA_HSYNC_ACTIVE_LOW	0
 
+#define PCH_eDP_A               0x64000
+#define PCH_DP_B                0xe4100
+#define PCH_DP_C                0xe4200
+#define PCH_DP_D                0xe4300
 
 #define DVOA			0x61120
 #define DVOB			0x61140
@@ -1418,9 +1470,15 @@
 /** Selects pipe B for LVDS data.  Must be set on pre-965. */
 # define LVDS_PIPEB_SELECT		(1 << 30)
 
+/* LVDS dithering flag on 965/g4x platform */
+#define   LVDS_ENABLE_DITHER           (1 << 25)
+
 /* on 965, dithering is enabled in this register, not PFIT_CONTROL */
 # define LVDS_DITHER_ENABLE		(1 << 25)
 
+/* Enable border for unscaled (or aspect-scaled) display */
+#define   LVDS_BORDER_ENABLE           (1 << 15)
+
 /*
  * Selects between .0 and .1 formats:
  *
@@ -2140,6 +2198,9 @@
 #define TV_V_CHROMA_42		0x684a8
 /** @} */
 
+/* dithering flag on IGDNG */
+#define PIPE_ENABLE_DITHER     (1 << 4)
+
 #define PIPEA_DSL		0x70000
 
 #define PIPEACONF 0x70008
@@ -2180,6 +2241,11 @@
 #define PIPECONF_DITHER_ST2		(2<<2)
 #define PIPECONF_DITHER_TEMPORAL	(3<<2)
 
+#define   PIPE_BPC_MASK                        (7 << 5) /* IGDNG */
+#define   PIPE_8BPC                            (0 << 5)
+#define   PIPE_10BPC                           (1 << 5)
+#define   PIPE_6BPC                            (2 << 5)
+#define   PIPE_12BPC                           (3 << 5)
 
 #define PIPEAGCMAXRED		0x70010
 #define PIPEAGCMAXGREEN		0x70014
@@ -2304,7 +2370,10 @@
 /* IGDNG */
 #define DISPPLANE_X_TILE			(1<<10)
 #define DISPPLANE_LINEAR			(0<<10)
+#define DISPPLANE_TRICKLE_FEED_DISABLE (1<<14) /* IGDNG */
+#define   DISPPLANE_TILED                      (1<<10)
 
+#define DSPAADDR               0x70184
 #define DSPABASE		0x70184
 /* IGDNG */
 #define DSPALINOFF		0x70184
@@ -3011,6 +3080,17 @@
 #define PFB_CTL_1		0x68880
 #define  PF_ENABLE		(1<<31)
 
+#define  PF_FILTER_MASK                (3<<23)
+#define  PF_FILTER_PROGRAMMED  (0<<23)
+#define  PF_FILTER_MED_3x3     (1<<23)
+#define  PF_FILTER_EDGE_ENHANCE        (2<<23)
+#define  PF_FILTER_EDGE_SOFTEN (3<<23)
+
+#define PFA_WIN_SZ             0x68074
+#define PFB_WIN_SZ             0x68874
+#define PFA_WIN_POS            0x68070
+#define PFB_WIN_POS            0x6887
+
 /* CPU panel fitter */
 #define PFA_CTRL_1		0x68080
 #define PFB_CTRL_1		0x68880
@@ -3060,6 +3140,9 @@
 #define GTIIR	0x44018
 #define GTIER	0x4401c
 
+#define DISP_ARB_CTL   0x45000
+#define  DISP_TILE_SURFACE_SWIZZLING   (1<<13)
+
 /* PCH */
 
 /* south display engine interrupt */
@@ -3131,9 +3214,12 @@
 #define  DREF_CPU_SOURCE_OUTPUT_NONSPREAD	(3<<13)
 #define  DREF_SSC_SOURCE_DISABLE		(0<<11)
 #define  DREF_SSC_SOURCE_ENABLE			(2<<11)
+#define  DREF_SSC_SOURCE_MASK                  (3<<11)
 #define  DREF_NONSPREAD_SOURCE_DISABLE		(0<<9)
 #define  DREF_NONSPREAD_SOURCE_ENABLE		(2<<9)
 #define  DREF_SUPERSPREAD_SOURCE_DISABLE	(0<<7)
+#define  DREF_NONSPREAD_CK505_ENABLE           (1<<9)
+#define  DREF_NONSPREAD_SOURCE_MASK            (3<<9)
 #define  DREF_SUPERSPREAD_SOURCE_ENABLE		(2<<7)
 #define  DREF_SSC4_DOWNSPREAD			(0<<6)
 #define  DREF_SSC4_CENTERSPREAD			(1<<6)
@@ -3348,5 +3434,15 @@
 #define HDMIC	0xe1150
 #define HDMID	0xe1160
 #define PCH_LVDS 0xe1180
+#define  LVDS_DETECTED (1 << 1)
 
+#define WM0_PIPEA_ILK   0x45100
+#define WM0_PIPEB_ILK   0x45104
+#define WM1_LP_ILK     0x45108
+
+#define DISPLAY_CHICKEN1_DEB   0x42000
+#define DISPLAY_CHICKEN2_DEB    0x42004
+#define DISPLAY_DSPCLK_GATE    0x42020
+#define DISPLAY_ARB_CTRL       0x45000
+
 #endif /* _I810_REG_H */
--- src/i830.h	Thu May 27 10:20:22 2010
+++ src/i830.h	Thu May 27 10:28:14 2010
@@ -376,6 +376,14 @@
     DRI_DRI2
 };
 
+struct sdvo_device_mapping {
+    uint8_t dvo_port;
+    uint8_t slave_addr;
+    uint8_t dvo_wiring;
+    uint8_t initialized;
+};
+
+
 typedef struct _I830Rec {
    unsigned char *MMIOBase;
    unsigned char *GTTBase;
@@ -629,6 +637,7 @@
    int lvds_ssc_freq; /* in MHz */
    Bool lvds_dither;
    DisplayModePtr lvds_fixed_mode;
+   DisplayModePtr sdvo_lvds_fixed_mode;
    Bool skip_panel_detect;
 
    Bool tv_present; /* TV connector present (from VBIOS) */
@@ -733,6 +742,7 @@
 
    /* new for Ilk */
    uint32_t savePCH_DREF_CONTROL;
+   uint32_t saveDISP_ARB_CTL;
    uint32_t saveFDI_RXA_CTL;
    uint32_t saveFDI_TXA_CTL;
    uint32_t saveTRANSACONF;
@@ -759,6 +769,8 @@
    uint32_t saveTRANSA_LINK_M2;
    uint32_t saveTRANSA_LINK_N2;
    uint32_t savePFA_CTL_1;
+   uint32_t savePFA_WIN_SZ;
+   uint32_t savePFA_WIN_POS;
    uint32_t saveFDI_RXA_TUSIZE1;
    uint32_t saveFDI_RXA_TUSIZE2;
 
@@ -788,8 +800,21 @@
    uint32_t saveTRANSB_LINK_M2;
    uint32_t saveTRANSB_LINK_N2;
    uint32_t savePFB_CTL_1;
+   uint32_t savePFB_WIN_SZ;
+   uint32_t savePFB_WIN_POS;
    uint32_t saveFDI_RXB_TUSIZE1;
    uint32_t saveFDI_RXB_TUSIZE2;
+
+   uint32_t saveBLC_CPU_PWM_CTL;
+   uint32_t saveBLC_CPU_PWM_CTL2;
+   uint8_t saveMSR;
+   uint8_t saveSR[8];
+   uint8_t saveGR[25];
+   uint8_t saveAR_INDEX;
+   uint8_t saveAR[22];
+   uint8_t saveDACMASK;
+   uint8_t saveCR[38];
+
    enum last_3d *last_3d;
 
    Bool use_drm_mode;
@@ -804,6 +829,7 @@
    Bool force_sdvo_detect;
     /** User option to print acceleration fallback info to the server log. */
    Bool fallback_debug;
+   struct sdvo_device_mapping sdvo_mappings[2];
 } I830Rec;
 
 #define I830PTR(p) ((I830Ptr)((p)->driverPrivate))
--- src/cpu_display.c	Thu May 27 10:20:22 2010
+++ src/cpu_display.c	Thu May 27 10:33:15 2010
@@ -86,7 +86,7 @@
 #define VCO_MIN		1760000
 #define VCO_MAX		3510000
 #define N_MIN		1	
-#define N_MAX		8
+#define N_MAX		6
 #define M_MIN		79
 #define M_MAX		127
 #define M1_MIN		12
@@ -111,7 +111,10 @@
 static Bool
 intel_find_pll_ilk(const intel_limit_t *, xf86CrtcPtr,
                              int, int, intel_clock_t *);
+static void
+ilk_crtc_load_lut(xf86CrtcPtr crtc);
 
+
 static const intel_limit_t intel_limits[] = {
     { /* INTEL_LIMIT_SDVO_DAC */
         .dot = { .min = DOT_MIN,		.max = DOT_MAX },
@@ -225,8 +228,8 @@
     ScrnInfoPtr pScrn = crtc->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
     intel_clock_t clock;
-    int  max_n;
     Bool found = FALSE;
+int err_min = 10000;
     int err_most = target * 0.0049;
 
     if (target < limit->p2.dot_limit)
@@ -234,9 +237,8 @@
     else
 	clock.p2 = limit->p2.p2_fast;
 
-    max_n = limit->n.max;
     /* based on hardware requirement prefer smaller n to precision */
-    for (clock.n = limit->n.min; clock.n <= max_n; clock.n++) {
+for (clock.n = limit->n.min; clock.n <= limit->n.max; clock.n++) {
         /* based on hardware requirement prefere larger m1,m2, p1*/
         for (clock.m1 = limit->m1.max;
             clock.m1 >= limit->m1.min; clock.m1--) {
@@ -252,13 +254,10 @@
                     this_err = abs(clock.dot - target) ;
                     if (this_err < err_most) {
                         memcpy(best_clock, &clock, sizeof(intel_clock_t));
-                        err_most = this_err;
-                        /* prefer smaller n to precision */
-                        max_n = clock.n; /* just may outside cycle return,
-					    true return clock is in 'best_clock' already,
-					    so clock.n++ no problem */
-                        found = TRUE;
 			goto out; /* IGDNG: jump out in first match like vbios does */
+                    } else if (this_err < err_min) {
+                       memcpy(best_clock, &clock, sizeof(intel_clock_t));
+                        err_min = this_err;
                     }
                 }
             }
@@ -265,7 +264,7 @@
         }
     }
 out:
-    return found;
+    return TRUE;
 }
 
 /**
@@ -284,6 +283,7 @@
     int dspsurf = (plane == 0 ? DSPASURF : DSPBSURF);
     int dsptileoff = (plane == 0 ? DSPATILEOFF : DSPBTILEOFF);
     int dspstride = (plane == 0) ? DSPASTRIDE : DSPBSTRIDE;
+uint32_t dspcntr;
 
     Offset = ((y * pScrn->displayWidth + x) * pI830->cpp);
     Stride = pScrn->displayWidth * pI830->cpp;
@@ -299,7 +299,7 @@
 	Offset = 0;
 	Stride = intel_crtc->rotate_mem->pitch;
     } else {
-	Start = pI830->front_buffer->offset;
+	Start = pI830->front_buffer->offset ;
     }
 
     crtc->x = x;
@@ -374,15 +374,8 @@
     OUTREG8(SRX, 1);
     sr01 = INREG8(SRX + 1);
     OUTREG8(SRX + 1, sr01 | (1 << 5));
-    usleep(30);
-    /* disable center mode on 965GM and G4X platform */
-    if (IS_I965GM(pI830) || IS_G4X(pI830)
-	    || IS_IGDNG(pI830))
-        vgacntrl &= ~(3 << 24);
-
-    vgacntrl |= VGA_DISP_DISABLE;
-
-    OUTREG(CPU_VGACNTRL, vgacntrl);
+    usleep(100);
+    OUTREG(CPU_VGACNTRL, VGA_DISP_DISABLE);
     i830WaitForVblank(pScrn);
 }
 
@@ -404,13 +397,16 @@
     int pch_dpll_reg = (pipe == 0) ? PCH_DPLL_A : PCH_DPLL_B;
     int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
     int dspcntr_reg = (plane == 0) ? DSPACNTR : DSPBCNTR;
-    int dspbase_reg = (plane == 0) ? DSPABASE : DSPBBASE;
+    int dspbase_reg = (plane == 0) ? DSPAADDR : DSPBADDR;
     int fdi_tx_reg = (pipe == 0) ? FDI_TXA_CTL : FDI_TXB_CTL;
     int fdi_rx_reg = (pipe == 0) ? FDI_RXA_CTL : FDI_RXB_CTL;
     int fdi_rx_chicken_reg = (pipe == 0) ? FDI_RXA_CHICKEN : FDI_RXB_CHICKEN;
     int fdi_rx_iir_reg = (pipe == 0) ? FDI_RXA_IIR : FDI_RXB_IIR;
+int fdi_rx_imr_reg = (pipe == 0) ? FDI_RXA_IMR : FDI_RXB_IMR;
     int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
     int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1;
+int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
+    int pf_win_pos = (pipe == 0) ? PFA_WIN_POS : PFB_WIN_POS;
     uint32_t temp;
     int cpu_htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;
     int cpu_hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;
@@ -424,9 +420,31 @@
     int trans_vtot_reg = (pipe == 0) ? TRANS_VTOTAL_A : TRANS_VTOTAL_B;
     int trans_vblank_reg = (pipe == 0) ? TRANS_VBLANK_A : TRANS_VBLANK_B;
     int trans_vsync_reg = (pipe == 0) ? TRANS_VSYNC_A : TRANS_VSYNC_B;
+    uint32_t pipe_bpc;
 
+    temp = INREG(pipeconf_reg);
+    pipe_bpc = temp & PIPE_BPC_MASK;
+
+
+
     _debug("cpu crtc %d enable", pipe);
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+       temp = INREG(PCH_LVDS);
+       if ((temp & LVDS_PORT_EN) == 0) {
+              OUTREG(PCH_LVDS, temp | LVDS_PORT_EN);
+              POSTING_READ(PCH_LVDS);
+       }
+    }
 
+    /* enable PCH DPLL */
+    temp = INREG(pch_dpll_reg);
+    if ((temp & DPLL_VCO_ENABLE) == 0) {
+       OUTREG(pch_dpll_reg, temp | DPLL_VCO_ENABLE);
+       POSTING_READ(pch_dpll_reg);
+    }
+
+
+
     /* enable PCH SSC modulator, looks not needed for CRT */
     /* enable PCH clock reference source */
     temp = INREG(PCH_DREF_CONTROL);
@@ -462,9 +480,44 @@
         intel_wait_warmup(WARMUP_CPU_FDI_TRANSMITTER_PLL);
     }
 
+    /* enable PCH FDI RX PLL, wait warmup plus DMI latency */
+    temp = INREG(fdi_rx_reg);
+    /*
+     * make the BPC in FDI Rx be consistent with that in
+     * pipeconf reg.
+     */
+    temp &= ~(0x07 << 16);
+    temp |= (pipe_bpc << 11);
+    OUTREG(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE |
+                       FDI_SEL_PCDCLK |
+                       FDI_DP_PORT_WIDTH_X4); /* default 4 lanes */
+    POSTING_READ(fdi_rx_reg);
+    usleep(200);
 
-    /* ignore eDP now */
+    /* Enable CPU FDI TX PLL, always on for IGDNG */
+    temp = INREG(fdi_tx_reg);
+    if ((temp & FDI_TX_PLL_ENABLE) == 0) {
+       OUTREG(fdi_tx_reg, temp | FDI_TX_PLL_ENABLE);
+       POSTING_READ(fdi_tx_reg);
+       usleep(100);
+    }
 
+
+    /* Enable panel fitting for LVDS */
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+        temp = INREG(pf_ctl_reg);
+        OUTREG(pf_ctl_reg, temp | PF_ENABLE | PF_FILTER_MED_3x3);
+
+    /* enable CPU FDI TX and PCH FDI RX */
+        /* currently full aspect */
+        OUTREG(pf_win_pos, 0);
+
+        OUTREG(pf_win_size,
+                  (pI830->lvds_fixed_mode->HDisplay << 16) |
+                  (pI830->lvds_fixed_mode->VDisplay));
+    }
+
+
     /* configure CPU pipe timing, M/N/TU, etc. XXX ->mode_set*/
     /* Enable CPU pipe */
     temp = INREG(pipeconf_reg);
@@ -471,6 +524,7 @@
     if ((temp & PIPEACONF_ENABLE) == 0) {
         OUTREG(pipeconf_reg, temp | PIPEACONF_ENABLE);
         POSTING_READ(pipeconf_reg);
+        usleep(100);
     }
 
     /* configure and enable CPU plane */
@@ -484,15 +538,23 @@
 
 
     /* enable CPU FDI TX and PCH FDI RX */
-
+#if 0
     temp = INREG(fdi_tx_reg);
     temp |= FDI_TX_ENABLE;
+temp |= FDI_DP_PORT_WIDTH_X4; /* default */
+    temp &= ~FDI_LINK_TRAIN_NONE;
+    temp |= FDI_LINK_TRAIN_PATTERN_1;
+
     OUTREG(fdi_tx_reg, temp);
     POSTING_READ(fdi_tx_reg);
 
     temp = INREG(fdi_rx_reg);
+temp &= ~FDI_LINK_TRAIN_NONE;
+    temp |= FDI_LINK_TRAIN_PATTERN_1;
+
     OUTREG(fdi_rx_reg, temp | FDI_RX_ENABLE);
     POSTING_READ(fdi_rx_reg);
+#endif
 
     temp = INREG(fdi_tx_reg);
     temp |= FDI_TX_ENABLE;
@@ -510,19 +572,17 @@
     POSTING_READ(fdi_rx_reg);
     _debug("enable sec CPU FDI RX DPLL 0x%x", temp);
 
-     usleep(150);
-
-
-    if (ilk_a_stepping()) {
-	temp = INREG(fdi_rx_chicken_reg);
-	OUTREG(fdi_rx_chicken_reg, temp | FDI_RX_PHASE_SYNC_POINTER_ENABLE);
-    }
-
-    intel_wait_warmup(FDI_TRAIN_PATTERN_1_TIME);
     usleep(150);
-    /* Train FDI ... */
 
     _debug("train start");
+    /* umask FDI RX Interrupt symbol_lock and bit_lock bit
+       for train result */
+    temp = INREG(fdi_rx_imr_reg);
+    temp &= ~FDI_RX_SYMBOL_LOCK;
+    temp &= ~FDI_RX_BIT_LOCK;
+    OUTREG(fdi_rx_imr_reg, temp);
+    POSTING_READ(fdi_rx_imr_reg);
+    usleep(150);
 
     temp = INREG(fdi_rx_iir_reg);
     _debug("FDI_RX_IIR 0x%x", temp);
@@ -540,12 +600,12 @@
 	if (j != tries) {
 	    _debug("train 1 ok 1!");
 	    /* XXX clear it */
-	    /* OUTREG(fdi_rx_iir_reg, temp | FDI_RX_BIT_LOCK); */
+	     OUTREG(fdi_rx_iir_reg, temp | FDI_RX_BIT_LOCK); 
 	} else
 	    _debug("train 1 fail");
     } else {
 	/* XXX clear it */
-	/* OUTREG(fdi_rx_iir_reg, temp | FDI_RX_BIT_LOCK); */
+	 OUTREG(fdi_rx_iir_reg, temp | FDI_RX_BIT_LOCK); 
 	_debug("train 1 ok 2!");
     }
 
@@ -559,7 +619,6 @@
     temp |= FDI_LINK_TRAIN_PATTERN_2;
     OUTREG(fdi_rx_reg, temp);
 
-    intel_wait_warmup(FDI_TRAIN_PATTERN_2_TIME);
     usleep(150);
 
     _debug("train 2 start");
@@ -579,13 +638,13 @@
 	}
 	if (j != tries) {
 	    /* XXX clear it */
-	    /* OUTREG(fdi_rx_iir_reg, temp | FDI_RX_SYMBOL_LOCK); */
+	     OUTREG(fdi_rx_iir_reg, temp | FDI_RX_SYMBOL_LOCK); 
 	    _debug("train 2 ok 1!");
 	} else
 	    _debug("train 2 fail");
     } else {
 	/* XXX clear it */
-	/* OUTREG(fdi_rx_iir_reg, temp | FDI_RX_SYMBOL_LOCK); */
+	OUTREG(fdi_rx_iir_reg, temp | FDI_RX_SYMBOL_LOCK); 
 	_debug("train 2 ok 2!");
     }
     _debug("train done");
@@ -601,6 +660,12 @@
 
     /* enable PCH transcoder */
     temp = INREG(transconf_reg);
+    /*
+     * make the BPC in transcoder be consistent with
+     * that in pipeconf reg.
+     */
+    temp &= ~PIPE_BPC_MASK;
+    temp |= pipe_bpc;
     OUTREG(transconf_reg, temp | TRANS_ENABLE);
     POSTING_READ(transconf_reg);
 
@@ -619,17 +684,10 @@
     POSTING_READ(fdi_rx_reg);
 
     /* wait one idle pattern time */
-    intel_wait_warmup(FDI_ONE_IDLE_PATTERN_TIME);
 
-    /* configure PCH transcoder timing, M/N/TU, etc. XXX->mode_set */
+    usleep(100);
 
-    /* enable CPU panel fitter XXX */
-    temp = INREG(pf_ctl_reg);
-    if ((temp & PF_ENABLE) == 0) {
-	OUTREG(pf_ctl_reg, temp | PF_ENABLE);
-	POSTING_READ(pf_ctl_reg);
-    }
-
+    ilk_crtc_load_lut(crtc);
     i830WaitForVblank(pScrn);
 
     _debug("crtc enable done.");
@@ -652,48 +710,66 @@
     int fdi_rx_chicken_reg = (pipe == 0) ? FDI_RXA_CHICKEN : FDI_RXB_CHICKEN;
     int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
     int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1;
+int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
+    int pf_win_pos = (pipe == 0) ? PFA_WIN_POS : PFB_WIN_POS;
     uint32_t temp;
+    int tries = 5, j, n;
+    uint32_t vga_reg;
+    uint8_t sr1;
+    uint32_t pipe_bpc;
 
+
+
     _debug("cpu crtc %d disable", pipe);
+    temp = INREG(pipeconf_reg);
+    pipe_bpc = temp & PIPE_BPC_MASK;
 
-    /** disable sequence **/
 
+
+    /* Disable display plane */
+    temp = INREG(dspcntr_reg);
+    if ((temp & DISPLAY_PLANE_ENABLE) != 0) {
+        OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
+        /* Flush the plane changes */
+        OUTREG(dspbase_reg, INREG(dspbase_reg));
+        POSTING_READ(dspbase_reg);
+    }
+
+    /* i915_disable_vga */
+    ilk_disable_vga_plane(crtc);
+
+
     /* disable cpu pipe, disable after all planes disabled */
     temp = INREG(pipeconf_reg);
     if ((temp & PIPEACONF_ENABLE) != 0) {
 	OUTREG(pipeconf_reg, temp & ~PIPEACONF_ENABLE);
 	POSTING_READ(pipeconf_reg);
+       n = 0;
+       /* wait for cpu pipe off, pipe state */
+       while ((INREG(pipeconf_reg) & I965_PIPECONF_ACTIVE) != 0) {
+               n++;
+               if (n < 60) {
+                       usleep(500);
+                       continue;
+               } else {
+                       _debug("pipe %d off delay\n", pipe);
+                       break;
+               }
+       }
     } else {
-	_debug("pipe %d already disabled", pipe);
-	return;
-    }
+_debug("crtc %d already disabled", pipe);
 
-    /* disable panel power -> output power down */
-
-    /* disable cpu planes */
-    temp = INREG(dspcntr_reg);
-    if ((temp & DISPLAY_PLANE_ENABLE) != 0)
-    {
-	OUTREG(dspcntr_reg, temp & ~DISPLAY_PLANE_ENABLE);
-	/* Flush the plane changes */
-	OUTREG(dspbase_reg, INREG(dspbase_reg));
-	POSTING_READ(dspbase_reg);
     }
 
-    ilk_disable_vga_plane (crtc);
-
-    /* wait for cpu pipe off, pipe state */
-    while ((INREG(pipeconf_reg) & I965_PIPECONF_ACTIVE) != 0)
-	;
-
-    /* IGDNG-A : disable cpu panel fitter ? */
+    /* Disable PF */
     temp = INREG(pf_ctl_reg);
     if ((temp & PF_ENABLE) != 0) {
-	OUTREG(pf_ctl_reg, temp & ~PF_ENABLE);
-	POSTING_READ(pf_ctl_reg);
+OUTREG(pf_ctl_reg, temp & ~PF_ENABLE);
+          POSTING_READ(pf_ctl_reg);
+
     }
 
-    /* ignore eDP now */
+OUTREG(pf_win_size, 0);
 
     /* disable CPU FDI tx and PCH FDI rx */
     temp = INREG(fdi_tx_reg);
@@ -701,13 +777,13 @@
     POSTING_READ(fdi_tx_reg);
 
     temp = INREG(fdi_rx_reg);
+/* BPC in FDI rx is consistent with that in pipeconf */
+    temp &= ~(0x07 << 16);
+    temp |= (pipe_bpc << 11);
     OUTREG(fdi_rx_reg, temp & ~FDI_RX_ENABLE);
     POSTING_READ(fdi_rx_reg);
 
-    if (ilk_a_stepping()) {
-	temp = INREG(fdi_rx_chicken_reg);
-	OUTREG(fdi_rx_chicken_reg, temp & ~FDI_RX_PHASE_SYNC_POINTER_ENABLE);
-    }
+usleep(100);
 
     /* still set train pattern 1 */
     temp = INREG(fdi_tx_reg);
@@ -719,32 +795,75 @@
     temp &= ~FDI_LINK_TRAIN_NONE;
     temp |= FDI_LINK_TRAIN_PATTERN_1;
     OUTREG(fdi_rx_reg, temp);
-    /* XXX disable SDVO */
 
+
+    usleep(100);
+
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+        temp = INREG(PCH_LVDS);
+        OUTREG(PCH_LVDS, temp & ~LVDS_PORT_EN);
+        POSTING_READ(PCH_LVDS);
+        usleep(100);
+    }
+
+
     /* disable PCH transcoder */
     temp = INREG(transconf_reg);
-    OUTREG(transconf_reg, temp & ~TRANS_ENABLE);
+if ((temp & TRANS_ENABLE) != 0) {
+       OUTREG(transconf_reg, temp & ~TRANS_ENABLE);
+       POSTING_READ(transconf_reg);
+       n = 0;
+       /* wait for PCH transcoder off, transcoder state */
+       while ((INREG(transconf_reg) & TRANS_STATE_ENABLE) != 0) {
+               n++;
+               if (n < 60) {
+                   usleep(500);
+                   continue;
+               } else {
+                   _debug("transcoder %d off delay\n", pipe);
+                   break;
+               }
+       }
+    }
+
+    temp = INREG(transconf_reg);
+    /* BPC in transcoder is consistent with that in pipeconf */
+    temp &= ~PIPE_BPC_MASK;
+    temp |= pipe_bpc;
+    OUTREG(transconf_reg, temp);
     POSTING_READ(transconf_reg);
+    usleep(100);
 
-    temp = INREG(fdi_rx_reg);
-    OUTREG(fdi_rx_reg, temp & ~FDI_SEL_PCDCLK);
-    POSTING_READ(fdi_rx_reg);
 
     /* disable PCH DPLL */
     temp = INREG(pch_dpll_reg);
     if ((temp & DPLL_VCO_ENABLE) != 0) {
-	OUTREG(pch_dpll_reg, temp & ~DPLL_VCO_ENABLE);
-	POSTING_READ(pch_dpll_reg);
+OUTREG(pch_dpll_reg, temp & ~DPLL_VCO_ENABLE);
+       POSTING_READ(pch_dpll_reg);
+
     }
 
     temp = INREG(fdi_rx_reg);
-    if ((temp & FDI_RX_PLL_ENABLE) != 0) {
-	OUTREG(fdi_rx_reg, temp & ~FDI_RX_PLL_ENABLE);
-	POSTING_READ(fdi_rx_reg);
+    temp &= ~FDI_SEL_PCDCLK;
+    OUTREG(fdi_rx_reg, temp);
+    POSTING_READ(fdi_rx_reg);
+
+    temp = INREG(fdi_rx_reg);
+    temp &= ~FDI_RX_PLL_ENABLE;
+    OUTREG(fdi_rx_reg, temp);
+    POSTING_READ(fdi_rx_reg);
+
+    /*Disable CPU FDI TX PLL */
+    temp = INREG(fdi_tx_reg);
+    if ((temp & FDI_TX_PLL_ENABLE) != 0) {
+          OUTREG(fdi_tx_reg, temp & ~FDI_TX_PLL_ENABLE);
+          POSTING_READ(fdi_tx_reg);
+          usleep(100);
     }
 
-    /* if SSC no need, disable PCH SSC modulator ??? */
+    usleep(150);
 
+
     i830WaitForVblank(pScrn);
 }
 
@@ -761,7 +880,9 @@
     I830Ptr pI830 = I830PTR(pScrn);
     I830CrtcPrivatePtr intel_crtc = crtc->driver_private;
     int pipe = intel_crtc->pipe;
+Bool disable_pipe = TRUE;
 
+
     /* XXX: When our outputs are all unaware of DPMS modes other than off and
      * on, we should map those modes to DPMSModeOff in the CRTC.
      */
@@ -783,8 +904,11 @@
     case DPMSModeSuspend:
 	cpu_crtc_enable(crtc);
 	break;
-    case DPMSModeOff:
-	cpu_crtc_disable(crtc, TRUE);
+   case DPMSModeOff:
+        if ((pipe == 0) && (pI830->quirk_flag & QUIRK_PIPEA_FORCE))
+            disable_pipe = FALSE;
+       cpu_crtc_disable(crtc, disable_pipe);
+        intel_crtc->enabled = FALSE;
 	break;
     }
 
@@ -898,7 +1022,7 @@
 #define LINK_N 0x80000
 
 static void
-ilk_compute_m_n(int bytes_per_pixel,
+ilk_compute_m_n(int bits_per_pixel,
 	int nlanes,
 	int pixel_clock,
 	int link_clock,
@@ -910,7 +1034,8 @@
 
     temp = (uint64_t) DATA_N * pixel_clock;
     temp /= link_clock;
-    m_n->gmch_m = temp * bytes_per_pixel / nlanes;
+    m_n->gmch_m = temp * bits_per_pixel / nlanes;
+m_n->gmch_m >>= 3; /* convert to bytes_per_pixel */
     m_n->gmch_n = DATA_N;
     ilk_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);
 
@@ -944,6 +1069,9 @@
     I830OutputPrivatePtr intel_output;
     int pipe = intel_crtc->pipe;
     int plane = intel_crtc->plane;
+int fp_reg = (pipe == 0) ? FPA0 : FPB0;
+    int dpll_reg = (pipe == 0) ? DPLL_A : DPLL_B;
+
     /* CPU */
     int pipeconf_reg = (pipe == 0) ? PIPEACONF : PIPEBCONF;
     int cpu_htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;
@@ -971,6 +1099,8 @@
     uint32_t dpll = 0, fp = 0, dspcntr, pipeconf, lvds_bits = 0;
     Bool ok, is_sdvo = FALSE, is_dvo = FALSE;
     Bool is_crt = FALSE, is_lvds = FALSE, is_tv = FALSE;
+int lvds_reg = LVDS;
+
     const intel_limit_t *limit;
     int sdvo_pixel_multiply;
     struct ilk_m_n m_n;
@@ -991,10 +1121,12 @@
 	case I830_OUTPUT_LVDS:
 	    is_lvds = TRUE;
 	    lvds_bits = intel_output->lvds_bits;
+ _debug("output LVDS");
 	    break;
 	case I830_OUTPUT_SDVO:
 	case I830_OUTPUT_HDMI:
 	    is_sdvo = TRUE;
+_debug("output SDVO/HDMI");
 	    if (intel_output->needs_tv_clock)
 		is_tv = TRUE;
 	    break;
@@ -1047,14 +1179,73 @@
 		   (float)adjusted_mode->Clock / 1000);
     }
 
+_debug("Chosen PLL clock %.1f Mhz\n", (float)clock.dot / 1000);
+    _debug("desired %.1f Mhz\n", (float)adjusted_mode->Clock / 1000);
     fp = clock.n << 16 | clock.m1 << 8 | clock.m2;
 
     _debug("set m_n");
-    ilk_compute_m_n(3, 4, /* lane num 4 */
-	    adjusted_mode->Clock,
-	    270000, /* lane clock */
-	    &m_n);
 
+    int bpp;
+    /* determine panel color depth */
+    temp = INREG(pipeconf_reg);
+    temp &= ~PIPE_BPC_MASK;
+    if (is_lvds) {
+       int lvds_reg = INREG(PCH_LVDS);
+       /* the BPC will be 6 if it is 18-bit LVDS panel */
+       if ((lvds_reg & LVDS_A3_POWER_MASK) == LVDS_A3_POWER_UP)
+               temp |= PIPE_8BPC;
+       else
+               temp |= PIPE_6BPC;
+    } else
+       temp |= PIPE_8BPC;
+    OUTREG(pipeconf_reg, temp);
+    POSTING_READ(pipeconf_reg);
+
+    switch (temp & PIPE_BPC_MASK) {
+    case PIPE_8BPC:
+            bpp = 24;
+            break;
+    case PIPE_10BPC:
+            bpp = 30;
+            break;
+    case PIPE_6BPC:
+            bpp = 18;
+            break;
+   case PIPE_12BPC:
+            bpp = 36;
+            break;
+    default:
+            xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+            "unknown pipe bpc value\n");
+            bpp = 24;
+    }
+    ilk_compute_m_n(bpp, 4, /* lane num 4 */
+               adjusted_mode->Clock,
+               270000, /* lane clock */
+               &m_n);
+
+    /* IGDNG: try to setup display ref clock before DPLL
+     * enabling. This is only under driver's control after
+     * PCH B stepping, previous chipset stepping should be
+     * ignoring this setting.
+     */
+    if (IS_IGDNG(pI830)) {
+       temp = INREG(PCH_DREF_CONTROL);
+       /* Always enable nonspread source */
+       temp &= ~DREF_NONSPREAD_SOURCE_MASK;
+       temp |= DREF_NONSPREAD_SOURCE_ENABLE;
+       OUTREG(PCH_DREF_CONTROL, temp);
+       POSTING_READ(PCH_DREF_CONTROL);
+
+       temp &= ~DREF_SSC_SOURCE_MASK;
+       temp |= DREF_SSC_SOURCE_ENABLE;
+       OUTREG(PCH_DREF_CONTROL, temp);
+      POSTING_READ(PCH_DREF_CONTROL);
+
+       usleep(200);
+    }
+
+
     if (is_lvds)
 	dpll |= DPLLB_MODE_LVDS;
     else
@@ -1085,7 +1276,18 @@
 	    dpll |= DPLLB_LVDS_P2_CLOCK_DIV_14;
 	    break;
     }
+    if (is_lvds) {
+       dpll |= (1 << (clock.p1 - 1)) << DPLL_FPA0_P1_POST_DIV_SHIFT;
+    } else {
+       if (clock.p1 == 2)
+               dpll |= PLL_P1_DIVIDE_BY_TWO;
+       else
+               dpll |= (clock.p1 - 2) << DPLL_FPA0_P1_POST_DIV_SHIFT;
+       if (clock.p2 == 4)
+               dpll |= PLL_P2_DIVIDE_BY_4;
+    }
 
+
     if (is_sdvo && is_tv)
 	dpll |= PLL_REF_INPUT_TVCLKINBC;
     else if (is_tv)
@@ -1099,6 +1301,10 @@
     else
 	dpll |= PLL_REF_INPUT_DREFCLK;
 
+    /* setup pipeconf */
+    pipeconf = INREG(pipeconf_reg);
+
+
     /* Set up the display plane register */
     dspcntr = DISPPLANE_GAMMA_ENABLE;
     switch (pScrn->bitsPerPixel) {
@@ -1118,21 +1324,18 @@
 	FatalError("unknown display bpp\n");
     }
 
-    /* Plane A/B is connected to Pipe A/B only */
+ _debug("pScrn->bitsPerPixel 0x%x", pScrn->bitsPerPixel);
 
-    if (ilk_display_tiled(crtc))
+if (IS_I965G(pI830) && ilk_display_tiled(crtc)) {
+       _debug("tiled");
 	dspcntr |= DISPLAY_PLANE_TILED;
+}
 
-    /* full rgb color, 8bpc */
-    pipeconf = (PIPECONF_FULL_COLOR_RANGE |
-	    PIPECONF_COLOR_SPACE_RGB |
-	    PIPECONF_8BPP);
 
-    /*
-     * This "shouldn't" be needed as the dpms on code
-     * will be run after the mode is set. On 9xx, it helps.
-     * On 855, it can lock up the chip (and the entire machine)
-     */
+if (IS_IGDNG(pI830))
+                /* must disable */
+        dspcntr |= DISPPLANE_TRICKLE_FEED_DISABLE;
+
     dspcntr |= DISPLAY_PLANE_ENABLE;
     pipeconf |= PIPEACONF_ENABLE;
     dpll |= DPLL_VCO_ENABLE;
@@ -1149,29 +1352,92 @@
 	i830PrintPll(pScrn, "chosen", &clock);
     }
 
+    _debug("Mode for pipe %c:\n", pipe == 0 ? 'A' : 'B');
+    /* assign to IGDNG registers */
+    fp_reg = pch_fp_reg;
+    dpll_reg = pch_dpll_reg;
+
     _debug("disable DPLL first\n");
+    _debug("fp 0x%x", fp);
 
+
     if (dpll & DPLL_VCO_ENABLE)
     {
-	OUTREG(pch_fp_reg, fp);
-	OUTREG(pch_dpll_reg, dpll & ~DPLL_VCO_ENABLE);
-	POSTING_READ(pch_dpll_reg);
+OUTREG(fp_reg, fp);
+       OUTREG(dpll_reg, dpll & ~DPLL_VCO_ENABLE);
+       POSTING_READ(dpll_reg);
+
 	usleep(150);
     }
 
-    sdvo_pixel_multiply = adjusted_mode->Clock / mode->Clock;
-    dpll |= ((sdvo_pixel_multiply - 1) << PLL_REF_SDVO_HDMI_MULTIPLIER_SHIFT);
+    /* The LVDS pin pair needs to be on before the DPLLs are enabled.
+     * This is an exception to the general rule that mode_set doesn't turn
+     * things on.
+     */
+    if (is_lvds)
+    {
+        uint32_t lvds;
+       if (IS_IGDNG(pI830))
+               lvds_reg = PCH_LVDS;
 
-    _debug("enable PCH DPLL 0x%x", dpll);
-    OUTREG(pch_fp_reg, fp);
-    OUTREG(pch_dpll_reg, dpll);
-    POSTING_READ(pch_dpll_reg);
+       lvds = INREG(lvds_reg);
+
+        lvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP;
+       if (pipe == 1) {
+               _debug("lvds pipe b select");
+               lvds |= LVDS_PIPEB_SELECT;
+       } else {
+               _debug("lvds pipe a select");
+               lvds &= ~LVDS_PIPEB_SELECT;
+       }
+       /* set the corresponsding LVDS_BORDER bit */
+       lvds |= intel_output->lvds_bits;
+        /* Set the B0-B3 data pairs corresponding to whether we're going to
+         * set the DPLLs for dual-channel mode or not.
+         */
+        if (clock.p2 == P2_LVDS_FAST)
+            lvds |= LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP;
+        else
+            lvds &= ~(LVDS_B0B3_POWER_UP | LVDS_CLKB_POWER_UP);
+
+       /* It would be nice to set 24 vs 18-bit mode (LVDS_A3_POWER_UP)
+        * appropriately here, but we need to look more thoroughly into how
+        * panels behave in the two modes.
+        */
+       /* set the dithering flag */
+       if (IS_I965G(pI830)) {
+               if (pI830->lvds_dither) {
+                       if (IS_IGDNG(pI830))
+                               pipeconf |= PIPE_ENABLE_DITHER;
+                       else
+                               lvds |= LVDS_ENABLE_DITHER;
+               } else {
+                       if (IS_IGDNG(pI830))
+                               pipeconf &= ~PIPE_ENABLE_DITHER;
+                       else
+                               lvds &= ~LVDS_ENABLE_DITHER;
+               }
+       }
+
+
+        OUTREG(lvds_reg, lvds);
+        POSTING_READ(lvds_reg);
+    }
+
+    OUTREG(fp_reg, fp);
+    OUTREG(dpll_reg, dpll);
+    POSTING_READ(dpll_reg);
     /* Wait for the clocks to stabilize. */
     usleep(150);
-    OUTREG(pch_dpll_reg, dpll);
-    POSTING_READ(pch_dpll_reg);
-    i830WaitForVblank(pScrn);
 
+    OUTREG(fp_reg + 4, fp);
+    /* write it again -- the BIOS does, after all */
+    OUTREG(dpll_reg, dpll);
+    POSTING_READ(dpll_reg);
+
+    /* Wait for the clocks to stabilize. */
+    usleep(150);
+
     _debug("set timing");
     /* Timing */
     OUTREG(cpu_htot_reg, (adjusted_mode->CrtcHDisplay - 1) |
@@ -1198,9 +1464,7 @@
     temp = INREG(fdi_rx_reg);
     OUTREG(fdi_rx_reg, temp | FDI_RX_PLL_ENABLE);
     POSTING_READ(fdi_rx_reg);
-    intel_wait_warmup(WARMUP_PCH_FDI_RECEIVER_PLL);
-    intel_wait_warmup(WARMUP_DMI_LATENCY);
-
+usleep(200);
     /* enable pipe before any plane enable, and after timing set */
     _debug("enable pipe 0x%x", pipeconf);
     OUTREG(pipeconf_reg, pipeconf);
@@ -1207,6 +1471,10 @@
     POSTING_READ(pipeconf_reg);
     i830WaitForVblank(pScrn);
 
+    /* enable address swizzle for tiling buffer */
+    temp = INREG(DISP_ARB_CTL);
+    OUTREG(DISP_ARB_CTL, temp | DISP_TILE_SURFACE_SWIZZLING);
+     
     _debug("set plane");
     /* Flush the plane changes */
     OUTREG(dspcntr_reg, dspcntr);
@@ -1214,13 +1482,6 @@
     IlkPipeSetBase(crtc, x, y);
     i830WaitForVblank(pScrn);
 
-    temp = INREG(fdi_rx_reg);
-    OUTREG(fdi_rx_reg, temp | FDI_SEL_PCDCLK);
-    POSTING_READ(fdi_rx_reg);
-    /* pipesrc and dspsize control the size that is scaled from, which should
-     * always be the user's requested size.
-     */
-
 #ifdef XF86DRI
    I830DRISetVBlankInterrupt (pScrn, TRUE);
 #endif
--- src/i830_bios.c	Thu May 27 10:20:21 2010
+++ src/i830_bios.c	Thu May 27 10:24:50 2010
@@ -47,6 +47,9 @@
 				 (bios[_addr + 2] << 16)	\
 				 (bios[_addr + 3] << 24))
 
+#define SLAVE_ADDR1 0x70
+#define SLAVE_ADDR2 0x72
+
 static void *
 find_section(struct bdb_header *bdb, int section_id)
 {
@@ -73,6 +76,38 @@
     return NULL;
 }
 
+static void
+fill_detail_timing_data(DisplayModePtr fixed_mode, unsigned char *timing_ptr)
+{
+    fixed_mode->HDisplay   = _H_ACTIVE(timing_ptr);
+    fixed_mode->VDisplay   = _V_ACTIVE(timing_ptr);
+    fixed_mode->HSyncStart = fixed_mode->HDisplay +
+        _H_SYNC_OFF(timing_ptr);
+    fixed_mode->HSyncEnd   = fixed_mode->HSyncStart +
+        _H_SYNC_WIDTH(timing_ptr);
+    fixed_mode->HTotal     = fixed_mode->HDisplay +
+        _H_BLANK(timing_ptr);
+    fixed_mode->VSyncStart = fixed_mode->VDisplay +
+        _V_SYNC_OFF(timing_ptr);
+    fixed_mode->VSyncEnd   = fixed_mode->VSyncStart +
+        _V_SYNC_WIDTH(timing_ptr);
+    fixed_mode->VTotal     = fixed_mode->VDisplay +
+        _V_BLANK(timing_ptr);
+    fixed_mode->Clock      = _PIXEL_CLOCK(timing_ptr) / 1000;
+    fixed_mode->type       = M_T_PREFERRED;
+
+    /* Some VBTs have bogus h/vtotal values */
+    if (fixed_mode->HSyncEnd > fixed_mode->HTotal)
+        fixed_mode->HTotal = fixed_mode->HSyncEnd + 1;
+    if (fixed_mode->VSyncEnd > fixed_mode->VTotal)
+        fixed_mode->VTotal = fixed_mode->VSyncEnd + 1;
+
+    xf86SetModeDefaultName(fixed_mode);
+
+}
+
+
+
 /**
  * Returns the BIOS's fixed panel mode.
  *
@@ -82,14 +117,18 @@
  * detecting the panel mode is preferable.
  */
 static void
-parse_panel_data(I830Ptr pI830, struct bdb_header *bdb)
+parse_integrated_panel_data(I830Ptr pI830, struct bdb_header *bdb)
 {
     struct bdb_lvds_options *lvds_options;
     struct bdb_lvds_lfp_data_ptrs *lvds_lfp_data_ptrs;
-    int timing_offset;
+    struct bdb_lvds_lfp_data *lvds_data;
+    struct bdb_lvds_lfp_data_entry *entry;
     DisplayModePtr fixed_mode;
     unsigned char *timing_ptr;
+    int lfp_data_size;
+    int dvo_offset;
 
+
     /* Defaults if we can't find VBT info */
     pI830->lvds_dither = 0;
 
@@ -101,14 +140,26 @@
     if (lvds_options->panel_type == 0xff)
 	return;
 
+    lvds_data = find_section(bdb, BDB_LVDS_LFP_DATA);
+     if (!lvds_data) {
+       return;
+    }
+    
+
     lvds_lfp_data_ptrs = find_section(bdb, BDB_LVDS_LFP_DATA_PTRS);
     if (!lvds_lfp_data_ptrs)
 	return;
 
-    timing_offset =
-	lvds_lfp_data_ptrs->ptr[lvds_options->panel_type].dvo_timing_offset;
-    timing_ptr = (unsigned char *)bdb + timing_offset;
+    lfp_data_size = lvds_lfp_data_ptrs->ptr[1].dvo_timing_offset -
+       lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset;
+    dvo_offset = lvds_lfp_data_ptrs->ptr[0].dvo_timing_offset -
+       lvds_lfp_data_ptrs->ptr[0].fp_timing_offset;
+    entry = (struct bdb_lvds_lfp_data_entry *)((uint8_t *)lvds_data->data +
+       (lfp_data_size * lvds_options->panel_type));
 
+    timing_ptr = (unsigned char *)entry + dvo_offset;
+
+
     if (pI830->skip_panel_detect)
 	return;
 
@@ -118,35 +169,50 @@
     /* Since lvds_bdb_2_fp_edid_dtd is just an EDID detailed timing
      * block, pull the contents out using EDID macros.
      */
-    fixed_mode->HDisplay   = _H_ACTIVE(timing_ptr);
-    fixed_mode->VDisplay   = _V_ACTIVE(timing_ptr);
-    fixed_mode->HSyncStart = fixed_mode->HDisplay +
-	_H_SYNC_OFF(timing_ptr);
-    fixed_mode->HSyncEnd   = fixed_mode->HSyncStart +
-	_H_SYNC_WIDTH(timing_ptr);
-    fixed_mode->HTotal     = fixed_mode->HDisplay +
-	_H_BLANK(timing_ptr);
-    fixed_mode->VSyncStart = fixed_mode->VDisplay +
-	_V_SYNC_OFF(timing_ptr);
-    fixed_mode->VSyncEnd   = fixed_mode->VSyncStart +
-	_V_SYNC_WIDTH(timing_ptr);
-    fixed_mode->VTotal     = fixed_mode->VDisplay +
-	_V_BLANK(timing_ptr);
-    fixed_mode->Clock      = _PIXEL_CLOCK(timing_ptr) / 1000;
-    fixed_mode->type       = M_T_PREFERRED;
+    fill_detail_timing_data(fixed_mode, timing_ptr);
+    pI830->lvds_fixed_mode = fixed_mode;
 
-    /* Some VBTs have bogus h/vtotal values */
-    if (fixed_mode->HSyncEnd > fixed_mode->HTotal)
-	fixed_mode->HTotal = fixed_mode->HSyncEnd + 1;
-    if (fixed_mode->VSyncEnd > fixed_mode->VTotal)
-	fixed_mode->VTotal = fixed_mode->VSyncEnd + 1;
-
     xf86SetModeDefaultName(fixed_mode);
+}
 
-    pI830->lvds_fixed_mode = fixed_mode;
+static void
+parse_sdvo_panel_data(I830Ptr pI830, struct bdb_header *bdb)
+{
+    DisplayModePtr fixed_mode;
+    struct bdb_sdvo_lvds_options *sdvo_lvds_options;
+    unsigned char *timing_ptr;
+
+    pI830->sdvo_lvds_fixed_mode = NULL;
+    sdvo_lvds_options = find_section(bdb, BDB_SDVO_LVDS_OPTIONS);
+    if (sdvo_lvds_options == NULL)
+       return;
+
+    timing_ptr = find_section(bdb, BDB_SDVO_PANEL_DTDS);
+    if (timing_ptr == NULL)
+       return;
+
+    fixed_mode = xnfalloc(sizeof(DisplayModeRec));
+    if (fixed_mode == NULL)
+       return;
+
+    memset(fixed_mode, 0, sizeof(*fixed_mode));
+    fill_detail_timing_data(fixed_mode, timing_ptr +
+               (sdvo_lvds_options->panel_type * DET_TIMING_INFO_LEN));
+    pI830->sdvo_lvds_fixed_mode = fixed_mode;
+
 }
 
 static void
+parse_panel_data(I830Ptr pI830, struct bdb_header *bdb)
+{
+    parse_integrated_panel_data(pI830, bdb);
+    parse_sdvo_panel_data(pI830, bdb);
+}
+
+
+
+
+static void
 parse_general_features(I830Ptr pI830, struct bdb_header *bdb)
 {
     struct bdb_general_features *general;
@@ -170,6 +236,87 @@
     }
 }
 
+static
+void parse_sdvo_mapping(ScrnInfoPtr pScrn, struct bdb_header *bdb)
+{
+    unsigned int block_size;
+    uint16_t *block_ptr;
+    struct bdb_general_definitions *defs;
+    struct child_device_config *child;
+    int i, child_device_num, count;
+    struct sdvo_device_mapping *p_mapping;
+    I830Ptr pI830 = I830PTR(pScrn);
+
+    defs = find_section(bdb, BDB_GENERAL_DEFINITIONS);
+    if (!defs) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+               "can't find the general definition blocks\n");
+       return;
+    }
+    /* Get the block size of general defintion block */
+    block_ptr = (uint16_t *)((char *)defs - 2);
+    block_size = *block_ptr;
+    child_device_num = (block_size - sizeof(*defs)) / sizeof(*child);
+    count = 0;
+
+    for (i = 0; i < child_device_num; i++) {
+    child = &defs->devices[i];
+    if (!child->device_type) {
+       /* skip invalid child device type*/
+       continue;
+    }
+    if (child->slave_addr == SLAVE_ADDR1 ||
+    child->slave_addr == SLAVE_ADDR2) {
+    if (child->dvo_port != DEVICE_PORT_DVOB &&
+       child->dvo_port != DEVICE_PORT_DVOC) {
+       /* skip the incorrect sdvo port */
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+               "Incorrect SDVO port\n");
+       continue;
+    }
+    xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+       "the SDVO device with slave addr %x "
+       "is found on DVO %x port\n",
+       child->slave_addr, child->dvo_port);
+    /* fill the primary dvo port */
+    p_mapping = &(pI830->sdvo_mappings[child->dvo_port - 1]);
+    if (!p_mapping->initialized) {
+       p_mapping->dvo_port = child->dvo_port;
+       p_mapping->dvo_wiring = child->dvo_wiring;
+       p_mapping->initialized = 1;
+       p_mapping->slave_addr = child->slave_addr;
+    } else {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+               "One DVO port is shared by two slave "
+               "address. Maybe it can't be handled\n");
+    }
+    /* If there exists the slave2_addr, maybe it is a sdvo
+     * device that contain multiple inputs. And it can't
+     * handled by SDVO driver.
+     * Ignore the dvo mapping of slave2_addr
+     * of course its mapping info won't be added.
+     */
+    if (child->slave2_addr) {
+       xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+               "Two DVO ports uses the same slave address."
+               "Maybe it can't be handled by SDVO driver\n");
+        }
+       count++;
+    } else {
+       /* if the slave address is neither 0x70 nor 0x72, skip it. */
+       continue;
+       }
+    }
+    /* If the count is zero, it indicates that no sdvo device is found */
+    if (!count)
+       xf86DrvMsg(pScrn->scrnIndex, X_INFO,
+       "No SDVO device is found in VBT\n");
+
+     return;
+}
+
+
+
 #define INTEL_VBIOS_SIZE (64 * 1024)	/* XXX */
 
 /**
--- src/i830_driver.c	Thu May 27 10:20:22 2010
+++ src/i830_driver.c	Thu May 27 10:24:50 2010
@@ -989,6 +989,7 @@
 
    /* IGDNG alpha: single analog output now */
    pch_crt_init(pScrn);
+   i830_lvds_init(pScrn);
    if (INREG(HDMIB) & PORT_DETECTED) {
 	/* check SDVOB if possible */
 	found = i830_sdvo_init(pScrn, HDMIB);
@@ -2291,6 +2292,12 @@
 static Bool
 i830_pipe_enabled(I830Ptr pI830, enum pipe pipe)
 {
+   uint32_t   dpll_reg;
+   if (IS_IGDNG(pI830)) {
+       dpll_reg = (pipe == PIPE_A) ? PCH_DPLL_A: PCH_DPLL_B;
+       return (INREG(dpll_reg) & DPLL_VCO_ENABLE);
+    }
+
     if (pipe == PIPE_A)
 	return (INREG(PIPEACONF) & PIPEACONF_ENABLE);
     else
@@ -2303,8 +2310,10 @@
     int i;
     uint32_t pal_reg;
 
-    if (!i830_pipe_enabled(pI830, pipe))
+    if (!i830_pipe_enabled(pI830, pipe)) {
+	 _debug("save pipe %d not enabled", pipe);
 	return;
+    }
 
     if (IS_IGDNG(pI830))
        pal_reg = (pipe == PIPE_A) ? LGC_PALETTE_A : LGC_PALETTE_B;
@@ -2325,8 +2334,10 @@
     int i;
     uint32_t pal_reg;
 
-    if (!i830_pipe_enabled(pI830, pipe))
+    if (!i830_pipe_enabled(pI830, pipe)) {
+	_debug("restore pipe %d not enabled", pipe);
 	return;
+    }
 
     if (IS_IGDNG(pI830))
        pal_reg = (pipe == PIPE_A) ? LGC_PALETTE_A : LGC_PALETTE_B;
@@ -2462,6 +2473,148 @@
    return TRUE;
 }
 
+
+static uint8_t ilk_read_indexed(ScrnInfoPtr pScrn, uint16_t index_port, uint16_t data_port, uint8_t reg)
+{
+	I830Ptr pI830 = I830PTR(pScrn);
+OUTREG8(index_port, reg);
+	return INREG8(data_port);
+}
+
+static uint8_t ilk_read_ar(ScrnInfoPtr pScrn, uint16_t st01, uint8_t reg, uint16_t palette_enable)
+{
+	I830Ptr pI830 = I830PTR(pScrn);
+	INREG8(st01);
+OUTREG8(VGA_AR_INDEX, palette_enable | reg);
+	return INREG8(VGA_AR_DATA_READ);
+}
+
+static void ilk_write_ar(ScrnInfoPtr pScrn, uint16_t st01, uint8_t reg, uint8_t val, uint16_t palette_enable)
+{
+	I830Ptr pI830 = I830PTR(pScrn);
+	INREG8(st01);
+	OUTREG8(VGA_AR_INDEX, palette_enable | reg);
+	OUTREG8(VGA_AR_DATA_WRITE, val);
+}
+
+static void ilk_write_indexed(ScrnInfoPtr pScrn, uint16_t index_port, uint16_t data_port, uint8_t reg, uint8_t val)
+{
+	I830Ptr pI830 = I830PTR(pScrn);
+	OUTREG8(index_port, reg);
+	OUTREG8(data_port, val);
+}
+
+static void ilk_save_vga(ScrnInfoPtr pScrn)
+{
+	int i;
+	I830Ptr pI830 = I830PTR(pScrn);
+	uint16_t cr_index, cr_data, st01;
+
+	/* VGA color palette registers */
+	pI830->saveDACMASK = INREG8(VGA_DACMASK);
+
+/* MSR bits */
+	pI830->saveMSR = INREG8(VGA_MSR_READ);
+if (pI830->saveMSR & VGA_MSR_CGA_MODE) {
+	cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* CRT controller regs */
+	ilk_write_indexed(pScrn, cr_index, cr_data, 0x11,
+			   ilk_read_indexed(pScrn, cr_index, cr_data, 0x11) &
+			   (~0x80));
+	for (i = 0; i <= 0x24; i++)
+		pI830->saveCR[i] =
+			ilk_read_indexed(pScrn, cr_index, cr_data, i);
+	/* Make sure we don't turn off CR group 0 writes */
+	pI830->saveCR[0x11] &= ~0x80;
+
+	/* Attribute controller registers */
+	INREG8(st01);
+	pI830->saveAR_INDEX = INREG8(VGA_AR_INDEX);
+	for (i = 0; i <= 0x14; i++)
+		pI830->saveAR[i] = ilk_read_ar(pScrn, st01, i, 0);
+	INREG8(st01);
+	OUTREG8(VGA_AR_INDEX, pI830->saveAR_INDEX);
+	INREG8(st01);
+
+	/* Graphics controller registers */
+	for (i = 0; i < 9; i++)
+		pI830->saveGR[i] =
+			ilk_read_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, i);
+
+	pI830->saveGR[0x10] =
+		ilk_read_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x10);
+	pI830->saveGR[0x11] =
+		ilk_read_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x11);
+	pI830->saveGR[0x18] =
+		ilk_read_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x18);
+
+	/* Sequencer registers */
+	for (i = 0; i < 8; i++)
+		pI830->saveSR[i] =
+			ilk_read_indexed(pScrn, VGA_SR_INDEX, VGA_SR_DATA, i);
+}
+
+static void ilk_restore_vga(ScrnInfoPtr pScrn)
+{
+	I830Ptr pI830 = I830PTR(pScrn);
+	int i;
+	uint16_t cr_index, cr_data, st01;
+
+	/* MSR bits */
+	OUTREG8(VGA_MSR_WRITE, pI830->saveMSR);
+	if (pI830->saveMSR & VGA_MSR_CGA_MODE) {
+		cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* Sequencer registers, don't write SR07 */
+	for (i = 0; i < 7; i++)
+		ilk_write_indexed(pScrn, VGA_SR_INDEX, VGA_SR_DATA, i,
+				   pI830->saveSR[i]);
+
+	/* CRT controller regs */
+	/* Enable CR group 0 writes */
+	ilk_write_indexed(pScrn, cr_index, cr_data, 0x11, pI830->saveCR[0x11]);
+	for (i = 0; i <= 0x24; i++)
+		ilk_write_indexed(pScrn, cr_index, cr_data, i, pI830->saveCR[i]);
+
+	/* Graphics controller regs */
+	for (i = 0; i < 9; i++)
+		ilk_write_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, i,
+				   pI830->saveGR[i]);
+
+	ilk_write_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x10,
+			   pI830->saveGR[0x10]);
+	ilk_write_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x11,
+			   pI830->saveGR[0x11]);
+	ilk_write_indexed(pScrn, VGA_GR_INDEX, VGA_GR_DATA, 0x18,
+			   pI830->saveGR[0x18]);
+
+/* Attribute controller registers */
+INREG8(st01); /* switch back to index mode */
+for (i = 0; i <= 0x14; i++)
+	ilk_write_ar(pScrn, st01, i, pI830->saveAR[i], 0);
+INREG8(st01); /* switch back to index mode */
+OUTREG8(VGA_AR_INDEX, pI830->saveAR_INDEX | 0x20);
+	INREG8(st01);
+
+/* VGA color palette registers */
+	OUTREG8(VGA_DACMASK, pI830->saveDACMASK);
+}
+
 static Bool
 ilk_save_hw_state(ScrnInfoPtr pScrn)
 {
@@ -2472,6 +2625,20 @@
    int i;
 
    _debug("ilk save hw state");
+
+
+   pI830->saveDSPARB = INREG(DSPARB);
+
+   pI830->savePCH_DREF_CONTROL = INREG(PCH_DREF_CONTROL);
+   pI830->saveDISP_ARB_CTL = INREG(DISPLAY_ARB_CTRL);
+
+   pI830->savePFA_WIN_SZ = INREG(PFA_WIN_SZ);
+   pI830->savePFA_WIN_POS = INREG(PFA_WIN_POS);
+
+   pI830->savePFB_WIN_SZ = INREG(PFB_WIN_SZ);
+   pI830->savePFB_WIN_POS = INREG(PFB_WIN_POS);
+
+
    /* XXX */
    pI830->saveDSPACNTR = INREG(DSPACNTR);
    pI830->savePIPEACONF = INREG(PIPEACONF);
@@ -2527,7 +2694,6 @@
    pI830->saveFDI_RXA_TUSIZE1 = INREG(FDI_RXA_TUSIZE1);
    pI830->saveFDI_RXA_TUSIZE2 = INREG(FDI_RXA_TUSIZE2);
 
-   if(xf86_config->num_crtc == 2) {
       pI830->saveDSPBCNTR = INREG(DSPBCNTR);
       pI830->savePIPEBCONF = INREG(PIPEBCONF);
       pI830->savePIPEBSRC = INREG(PIPEBSRC);
@@ -2583,8 +2749,11 @@
       pI830->saveFDI_RXB_TUSIZE1 = INREG(FDI_RXB_TUSIZE1);
       pI830->saveFDI_RXB_TUSIZE2 = INREG(FDI_RXB_TUSIZE2);
 
-   }
+   pI830->saveVCLK_DIVISOR_VGA0 = INREG(VCLK_DIVISOR_VGA0);
+   pI830->saveVCLK_DIVISOR_VGA1 = INREG(VCLK_DIVISOR_VGA1);
+   pI830->saveVCLK_POST_DIV = INREG(VCLK_POST_DIV);
 
+
    pI830->saveVGACNTRL = INREG(CPU_VGACNTRL);
    pI830->savePCH_DREF_CONTROL = INREG(PCH_DREF_CONTROL);
 
@@ -2602,6 +2771,16 @@
    pI830->saveSWF[14] = INREG(SWF30);
    pI830->saveSWF[15] = INREG(SWF31);
    pI830->saveSWF[16] = INREG(SWF32);
+
+   pI830->saveDSPCLK_GATE_D = INREG(DSPCLK_GATE_D);
+   pI830->saveRENCLK_GATE_D1 = INREG(RENCLK_GATE_D1);
+
+   if (IS_I965G(pI830)) {
+      pI830->saveRENCLK_GATE_D2 = INREG(RENCLK_GATE_D2);
+      pI830->saveRAMCLK_GATE_D = INREG(RAMCLK_GATE_D);
+   }
+
+
    for (i = 0; i < xf86_config->num_output; i++) {
      xf86OutputPtr   output = xf86_config->output[i];
       if (output->funcs->save)
@@ -2608,6 +2787,7 @@
        (*output->funcs->save) (output);
    }
 
+ilk_save_vga(pScrn);
   vgaHWUnlock(hwp);
   vgaHWSave(pScrn, vgaReg, VGA_SR_FONTS);
 
@@ -2908,36 +3088,31 @@
    i830WaitForVblank(pScrn);
 #endif
 
+OUTREG(DSPARB, pI830->saveDSPARB);
+
    _debug("restore state");
-   OUTREG(PCH_DREF_CONTROL, pI830->savePCH_DREF_CONTROL);
+OUTREG(DISPLAY_ARB_CTRL, pI830->saveDISP_ARB_CTL);
    usleep(150);
 
-   /*
-   OUTREG(FDI_RXA_CTL, pI830->saveFDI_RXA_CTL);
-   usleep(150);
-   OUTREG(FDI_TXA_CTL, pI830->saveFDI_TXA_CTL);
-   usleep(150);
-   OUTREG(PFA_CTL_1, pI830->savePFA_CTL_1);
-   */
-
    /* If the pipe A PLL is active, we can restore the pipe & plane config */
    if (pI830->saveDPLL_A & DPLL_VCO_ENABLE)
    {
-      OUTREG(PCH_FPA0, pI830->saveFPA0);
+_debug("pipe A PLL is active");
+	
       OUTREG(PCH_DPLL_A, pI830->saveDPLL_A & ~DPLL_VCO_ENABLE);
       POSTING_READ(PCH_DPLL_A);
       usleep(150);
    }
+
    OUTREG(PCH_FPA0, pI830->saveFPA0);
    OUTREG(PCH_FPA1, pI830->saveFPA1);
+/* Actually enable it */
+
    OUTREG(PCH_DPLL_A, pI830->saveDPLL_A);
    POSTING_READ(PCH_DPLL_A);
-   i830_dpll_settle();
-   OUTREG(PCH_DPLL_A, pI830->saveDPLL_A);
-   POSTING_READ(PCH_DPLL_A);
-   i830_dpll_settle();
+      usleep(150);
 
-   /* Restore mode config */
+   /* Restore mode */
    OUTREG(HTOTAL_A, pI830->saveHTOTAL_A);
    OUTREG(HBLANK_A, pI830->saveHBLANK_A);
    OUTREG(HSYNC_A, pI830->saveHSYNC_A);
@@ -2944,49 +3119,25 @@
    OUTREG(VTOTAL_A, pI830->saveVTOTAL_A);
    OUTREG(VBLANK_A, pI830->saveVBLANK_A);
    OUTREG(VSYNC_A, pI830->saveVSYNC_A);
-   OUTREG(BCLRPAT_A, pI830->saveBCLRPAT_A);
 
-   OUTREG(DSPASTRIDE, pI830->saveDSPASTRIDE);
-   OUTREG(DSPASIZE, pI830->saveDSPASIZE);
-   OUTREG(DSPAPOS, pI830->saveDSPAPOS);
-   OUTREG(PIPEASRC, pI830->savePIPEASRC);
-   OUTREG(DSPABASE, pI830->saveDSPABASE);
-   OUTREG(DSPASURF, pI830->saveDSPASURF);
-   OUTREG(DSPATILEOFF, pI830->saveDSPATILEOFF);
 
-   OUTREG(PIPEACONF, pI830->savePIPEACONF);
-   POSTING_READ(PIPEACONF);
-   i830WaitForVblank(pScrn);
+   OUTREG(PIPEA_DATA_M1, pI830->savePIPEA_DATA_M1);
+   OUTREG(PIPEA_DATA_N1, pI830->savePIPEA_DATA_N1);
+   OUTREG(PIPEA_LINK_M1, pI830->savePIPEA_LINK_M1);
+   OUTREG(PIPEA_LINK_N1, pI830->savePIPEA_LINK_N1);
 
-   /*
-    * Program Pipe A's plane
-    * The corresponding display plane may be disabled, and should only be
-    * enabled if pipe A is actually on (otherwise we have a bug in the initial
-    * state).
-    */
-   if ((pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
-       DISPPLANE_SEL_PIPE_A) {
-       OUTREG(DSPACNTR, pI830->saveDSPACNTR);
-       OUTREG(DSPABASE, INREG(DSPABASE));
-       POSTING_READ(DSPABASE);
-       i830WaitForVblank(pScrn);
-   }
-   if ((pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
-       DISPPLANE_SEL_PIPE_A) {
-       OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
-       OUTREG(DSPBBASE, INREG(DSPBBASE));
-       POSTING_READ(DSPBBASE);
-       i830WaitForVblank(pScrn);
-   }
 
    OUTREG(FDI_RXA_CTL, pI830->saveFDI_RXA_CTL);
-   usleep(150);
    OUTREG(FDI_TXA_CTL, pI830->saveFDI_TXA_CTL);
-   usleep(150);
 
-   OUTREG(FDI_RXA_TUSIZE1, pI830->saveFDI_RXA_TUSIZE1);
-   OUTREG(FDI_RXA_TUSIZE2, pI830->saveFDI_RXA_TUSIZE2);
+OUTREG(PFA_CTL_1, pI830->savePFA_CTL_1);
+   OUTREG(PFA_WIN_SZ, pI830->savePFA_WIN_SZ);
+   OUTREG(PFA_WIN_POS, pI830->savePFA_WIN_POS);
 
+   OUTREG(TRANSACONF, pI830->saveTRANSACONF);
+   POSTING_READ(TRANSACONF);
+
+
    OUTREG(TRANS_HTOTAL_A, pI830->saveTRANS_HTOTAL_A);
    OUTREG(TRANS_HBLANK_A, pI830->saveTRANS_HBLANK_A);
    OUTREG(TRANS_HSYNC_A, pI830->saveTRANS_HSYNC_A);
@@ -2994,142 +3145,90 @@
    OUTREG(TRANS_VBLANK_A, pI830->saveTRANS_VBLANK_A);
    OUTREG(TRANS_VSYNC_A, pI830->saveTRANS_VSYNC_A);
 
-   OUTREG(PIPEA_DATA_M1, pI830->savePIPEA_DATA_M1);
-   OUTREG(PIPEA_DATA_N1, pI830->savePIPEA_DATA_N1);
-   OUTREG(PIPEA_DATA_M2, pI830->savePIPEA_DATA_M2);
-   OUTREG(PIPEA_DATA_N2, pI830->savePIPEA_DATA_N2);
-   OUTREG(PIPEA_LINK_M1, pI830->savePIPEA_LINK_M1);
-   OUTREG(PIPEA_LINK_N1, pI830->savePIPEA_LINK_N1);
-   OUTREG(PIPEA_LINK_M2, pI830->savePIPEA_LINK_M2);
-   OUTREG(PIPEA_LINK_N2, pI830->savePIPEA_LINK_N2);
-   usleep(150);
 
-   OUTREG(TRANSA_DATA_M1, pI830->saveTRANSA_DATA_M1);
-   OUTREG(TRANSA_DATA_N1, pI830->saveTRANSA_DATA_N1);
-   OUTREG(TRANSA_DATA_M2, pI830->saveTRANSA_DATA_M2);
-   OUTREG(TRANSA_DATA_N2, pI830->saveTRANSA_DATA_N2);
-   /*
-   OUTREG(TRANSA_DP_LINK_M1, pI830->saveTRANSA_DP_LINK_M1);
-   OUTREG(TRANSA_DP_LINK_N1, pI830->saveTRANSA_DP_LINK_N1);
-   OUTREG(TRANSA_DP_LINK_M2, pI830->saveTRANSA_DP_LINK_M2);
-   OUTREG(TRANSA_DP_LINK_N2, pI830->saveTRANSA_DP_LINK_N2);
-   */
+   /* Restore plane info */
+   OUTREG(DSPASIZE, pI830->saveDSPASIZE);
+   OUTREG(DSPAPOS, pI830->saveDSPAPOS);
+   OUTREG(PIPEASRC, pI830->savePIPEASRC);
+   OUTREG(DSPABASE, pI830->saveDSPABASE);
+   OUTREG(DSPASTRIDE, pI830->saveDSPASTRIDE);
+   OUTREG(DSPASURF, pI830->saveDSPASURF);
+   OUTREG(DSPATILEOFF, pI830->saveDSPATILEOFF);
 
-   OUTREG(TRANSACONF, pI830->saveTRANSACONF);
-   POSTING_READ(TRANSACONF);
+OUTREG(PIPEACONF, pI830->savePIPEACONF);
+i830_restore_palette(pI830, PIPE_A);
+OUTREG(DSPACNTR, pI830->saveDSPACNTR);
+   OUTREG(DSPABASE, INREG(DSPABASE));
 
-   OUTREG(PFA_CTL_1, pI830->savePFA_CTL_1);
+   /* Pipe & plane B info */
+   /* If the pipe B PLL is active, we can restore the pipe & plane config */
+   if (pI830->saveDPLL_B & DPLL_VCO_ENABLE)
+    {
 
-   /* See note about pipe programming above */
-   if(xf86_config->num_crtc == 2)
-   {
-       /*
-       OUTREG(FDI_RXB_CTL, pI830->saveFDI_RXB_CTL);
-       usleep(150);
-       OUTREG(FDI_TXB_CTL, pI830->saveFDI_TXB_CTL);
-       usleep(150);
-       OUTREG(PFB_CTL_1, pI830->savePFB_CTL_1);
-       usleep(150);
-       */
-      /* If the pipe B PLL is active, we can restore the pipe & plane config */
-      if (pI830->saveDPLL_B & DPLL_VCO_ENABLE)
-      {
-	 OUTREG(PCH_FPB0, pI830->saveFPB0);
-	 OUTREG(PCH_DPLL_B, pI830->saveDPLL_B & ~DPLL_VCO_ENABLE);
-	 POSTING_READ(PCH_DPLL_B);
-	 usleep(150);
-      }
-      OUTREG(PCH_FPB0, pI830->saveFPB0);
-      OUTREG(PCH_FPB1, pI830->saveFPB1);
-      OUTREG(PCH_DPLL_B, pI830->saveDPLL_B);
-      POSTING_READ(PCH_DPLL_B);
-      i830_dpll_settle();
-      OUTREG(PCH_DPLL_B, pI830->saveDPLL_B);
-      POSTING_READ(PCH_DPLL_B);
-      i830_dpll_settle();
+     _debug("pipe B PLL is active");
+     OUTREG(PCH_DPLL_B, pI830->saveDPLL_B & ~DPLL_VCO_ENABLE);
 
-      /* Restore mode config */
-      OUTREG(HTOTAL_B, pI830->saveHTOTAL_B);
-      OUTREG(HBLANK_B, pI830->saveHBLANK_B);
-      OUTREG(HSYNC_B, pI830->saveHSYNC_B);
-      OUTREG(VTOTAL_B, pI830->saveVTOTAL_B);
-      OUTREG(VBLANK_B, pI830->saveVBLANK_B);
-      OUTREG(VSYNC_B, pI830->saveVSYNC_B);
-      OUTREG(BCLRPAT_B, pI830->saveBCLRPAT_B);
-      OUTREG(DSPBSTRIDE, pI830->saveDSPBSTRIDE);
-      OUTREG(DSPBSIZE, pI830->saveDSPBSIZE);
-      OUTREG(DSPBPOS, pI830->saveDSPBPOS);
-      OUTREG(PIPEBSRC, pI830->savePIPEBSRC);
-      OUTREG(DSPBBASE, pI830->saveDSPBBASE);
-      OUTREG(DSPBSURF, pI830->saveDSPBSURF);
-      OUTREG(DSPBTILEOFF, pI830->saveDSPBTILEOFF);
+      usleep(150);
+}
 
-      OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
-      POSTING_READ(PIPEBCONF);
-      i830WaitForVblank(pScrn);
+OUTREG(PCH_FPB0, pI830->saveFPB0);
+   OUTREG(PCH_FPB1, pI830->saveFPB1);
+   /* Actually enable it */
+   OUTREG(PCH_DPLL_B, pI830->saveDPLL_B);
+   usleep(150);
 
-      /*
-       * Program Pipe B's plane
-       * Note that pipe B may be disabled, and in that case, the plane
-       * should also be disabled or we must have had a bad initial state.
-       */
-      if ((pI830->saveDSPACNTR & DISPPLANE_SEL_PIPE_MASK) ==
-	  DISPPLANE_SEL_PIPE_B) {
-	  OUTREG(DSPACNTR, pI830->saveDSPACNTR);
-	  OUTREG(DSPABASE, INREG(DSPABASE));
-	  i830WaitForVblank(pScrn);
-      }
-      if ((pI830->saveDSPBCNTR & DISPPLANE_SEL_PIPE_MASK) ==
-	  DISPPLANE_SEL_PIPE_B) {
-	  OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
-	  OUTREG(DSPBBASE, INREG(DSPBBASE));
-	  i830WaitForVblank(pScrn);
-      }
+   /* Restore mode */
+   OUTREG(HTOTAL_B, pI830->saveHTOTAL_B);
+   OUTREG(HBLANK_B, pI830->saveHBLANK_B);
+   OUTREG(HSYNC_B, pI830->saveHSYNC_B);
+   OUTREG(VTOTAL_B, pI830->saveVTOTAL_B);
+   OUTREG(VBLANK_B, pI830->saveVBLANK_B);
+   OUTREG(VSYNC_B, pI830->saveVSYNC_B);
 
-      OUTREG(FDI_RXB_CTL, pI830->saveFDI_RXB_CTL);
-      usleep(150);
-      OUTREG(FDI_TXB_CTL, pI830->saveFDI_TXB_CTL);
-      usleep(150);
+   OUTREG(PIPEB_DATA_M1, pI830->savePIPEB_DATA_M1);
+   OUTREG(PIPEB_DATA_N1, pI830->savePIPEB_DATA_N1);
+   OUTREG(PIPEB_LINK_M1, pI830->savePIPEB_LINK_M1);
+   OUTREG(PIPEB_LINK_N1, pI830->savePIPEB_LINK_N1);
 
-      OUTREG(FDI_RXB_TUSIZE1, pI830->saveFDI_RXB_TUSIZE1);
-      OUTREG(FDI_RXB_TUSIZE2, pI830->saveFDI_RXB_TUSIZE2);
+   OUTREG(FDI_RXB_CTL, pI830->saveFDI_RXB_CTL);
+   OUTREG(FDI_TXB_CTL, pI830->saveFDI_TXB_CTL);
 
-      OUTREG(TRANS_HTOTAL_B, pI830->saveTRANS_HTOTAL_B);
-      OUTREG(TRANS_HBLANK_B, pI830->saveTRANS_HBLANK_B);
-      OUTREG(TRANS_HSYNC_B, pI830->saveTRANS_HSYNC_B);
-      OUTREG(TRANS_VTOTAL_B, pI830->saveTRANS_VTOTAL_B);
-      OUTREG(TRANS_VBLANK_B, pI830->saveTRANS_VBLANK_B);
-      OUTREG(TRANS_VSYNC_B, pI830->saveTRANS_VSYNC_B);
 
-      OUTREG(PIPEB_DATA_M1, pI830->savePIPEB_DATA_M1);
-      OUTREG(PIPEB_DATA_N1, pI830->savePIPEB_DATA_N1);
-      OUTREG(PIPEB_DATA_M2, pI830->savePIPEB_DATA_M2);
-      OUTREG(PIPEB_DATA_N2, pI830->savePIPEB_DATA_N2);
-      OUTREG(PIPEB_LINK_M1, pI830->savePIPEB_LINK_M1);
-      OUTREG(PIPEB_LINK_N1, pI830->savePIPEB_LINK_N1);
-      OUTREG(PIPEB_LINK_M2, pI830->savePIPEB_LINK_M2);
-      OUTREG(PIPEB_LINK_N2, pI830->savePIPEB_LINK_N2);
-      usleep(150);
+   OUTREG(PFB_CTL_1, pI830->savePFB_CTL_1);
+   OUTREG(PFB_WIN_SZ, pI830->savePFB_WIN_SZ);
+   OUTREG(PFB_WIN_POS, pI830->savePFB_WIN_POS);
 
-      OUTREG(TRANSB_DATA_M1, pI830->saveTRANSB_DATA_M1);
-      OUTREG(TRANSB_DATA_N1, pI830->saveTRANSB_DATA_N1);
-      OUTREG(TRANSB_DATA_M2, pI830->saveTRANSB_DATA_M2);
-      OUTREG(TRANSB_DATA_N2, pI830->saveTRANSB_DATA_N2);
-      /*
-      OUTREG(TRANSB_DP_LINK_M1, pI830->saveTRANSB_DP_LINK_M1);
-      OUTREG(TRANSB_DP_LINK_N1, pI830->saveTRANSB_DP_LINK_N1);
-      OUTREG(TRANSB_DP_LINK_M2, pI830->saveTRANSB_DP_LINK_M2);
-      OUTREG(TRANSB_DP_LINK_N2, pI830->saveTRANSB_DP_LINK_N2);
-      */
-
       OUTREG(TRANSBCONF, pI830->saveTRANSBCONF);
       POSTING_READ(TRANSBCONF);
+usleep(150);
+   OUTREG(TRANS_HTOTAL_B, pI830->saveTRANS_HTOTAL_B);
+   OUTREG(TRANS_HBLANK_B, pI830->saveTRANS_HBLANK_B);
+   OUTREG(TRANS_HSYNC_B, pI830->saveTRANS_HSYNC_B);
+   OUTREG(TRANS_VTOTAL_B, pI830->saveTRANS_VTOTAL_B);
+   OUTREG(TRANS_VBLANK_B, pI830->saveTRANS_VBLANK_B);
+   OUTREG(TRANS_VSYNC_B, pI830->saveTRANS_VSYNC_B);
 
-      OUTREG(PFB_CTL_1, pI830->savePFB_CTL_1);
+   /* Restore plane info */
+   OUTREG(DSPBSIZE, pI830->saveDSPBSIZE);
+   OUTREG(DSPBPOS, pI830->saveDSPBPOS);
+   OUTREG(PIPEBSRC, pI830->savePIPEBSRC);
+   OUTREG(DSPBBASE, pI830->saveDSPBBASE);
+   OUTREG(DSPBSTRIDE, pI830->saveDSPBSTRIDE);
+   OUTREG(DSPBSURF, pI830->saveDSPBSURF);
+   OUTREG(DSPBTILEOFF, pI830->saveDSPBTILEOFF);
+
+
+OUTREG(PIPEBCONF, pI830->savePIPEBCONF);
+
       usleep(150);
-   }
 
-   OUTREG(CPU_VGACNTRL, pI830->saveVGACNTRL);
+   i830_restore_palette(pI830, PIPE_B);
+   /* Enable the plane */
+OUTREG(DSPBCNTR, pI830->saveDSPBCNTR);
+   OUTREG(DSPBBASE, INREG(DSPBBASE));
+
+
+
    /*
     * Restore cursors
     * Even though the X cursor is hidden before we restore the hw state,
@@ -3151,9 +3250,17 @@
 	 output->funcs->restore(output);
    }
 
-   i830_restore_palette(pI830, PIPE_A);
-   i830_restore_palette(pI830, PIPE_B);
+OUTREG(CPU_VGACNTRL, pI830->saveVGACNTRL);
 
+   OUTREG(VCLK_DIVISOR_VGA0, pI830->saveVCLK_DIVISOR_VGA0);
+   OUTREG(VCLK_DIVISOR_VGA1, pI830->saveVCLK_DIVISOR_VGA1);
+   OUTREG(VCLK_POST_DIV, pI830->saveVCLK_POST_DIV);
+
+   usleep(150);
+
+   ilk_restore_vga(pScrn);
+
+
    for(i = 0; i < 7; i++) {
       OUTREG(SWF0 + (i << 2), pI830->saveSWF[i]);
       OUTREG(SWF00 + (i << 2), pI830->saveSWF[i+7]);
--- src/i830_display.c	Thu May 27 10:20:21 2010
+++ src/i830_display.c	Thu May 27 10:24:50 2010
@@ -1211,7 +1211,9 @@
     int fdi_rx_iir_reg = (pipe == 0) ? FDI_RXA_IIR : FDI_RXB_IIR;
     int fdi_rx_imr_reg = (pipe == 0) ? FDI_RXA_IMR : FDI_RXB_IMR;
     int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
-    /* int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1; */
+    int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1; 
+    int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
+    int pf_win_pos = (pipe == 0) ? PFA_WIN_POS : PFB_WIN_POS;
     uint32_t temp;
     int cpu_htot_reg = (pipe == 0) ? HTOTAL_A : HTOTAL_B;
     int cpu_hblank_reg = (pipe == 0) ? HBLANK_A : HBLANK_B;
@@ -1228,6 +1230,15 @@
 
     ErrorF("cpu crtc %d enable\n", pipe);
 
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+        temp = INREG(PCH_LVDS);
+        if ((temp & LVDS_PORT_EN) == 0) {
+             OUTREG(PCH_LVDS, temp | LVDS_PORT_EN);
+                     POSTING_READ(PCH_LVDS);
+        }
+    }
+    
+
     /* enable PCH clock reference source */
     temp = INREG(PCH_DREF_CONTROL);
     temp &= ~DREF_CONTROL_MASK;
@@ -1261,14 +1272,18 @@
 	intel_wait_warmup(WARMUP_CPU_FDI_TRANSMITTER_PLL);
     }
 
-    /* FIXME when to enable CPU panel fitter? */
-#if 0
-    temp = INREG(pf_ctl_reg);
-    if ((temp & PF_ENABLE) == 0) {
-	OUTREG(pf_ctl_reg, temp | PF_ENABLE);
-	POSTING_READ(pf_ctl_reg);
+    /* Enable panel fitting for LVDS */
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+        temp = INREG(pf_ctl_reg);
+        OUTREG(pf_ctl_reg, temp | PF_ENABLE);
+    
+        /* currently full aspect */
+        OUTREG(pf_win_pos, 0);
+    
+        OUTREG(pf_win_size,
+                  (pI830->lvds_fixed_mode->HDisplay << 16) |
+                  (pI830->lvds_fixed_mode->VDisplay));
     }
-#endif
 
     /* Enable CPU pipe */
     temp = INREG(pipeconf_reg);
@@ -1456,6 +1471,8 @@
     int fdi_rx_chicken_reg = (pipe == 0) ? FDI_RXA_CHICKEN : FDI_RXB_CHICKEN;
     int transconf_reg = (pipe == 0) ? TRANSACONF : TRANSBCONF;
     int pf_ctl_reg = (pipe == 0) ? PFA_CTL_1 : PFB_CTL_1;
+    int pf_win_size = (pipe == 0) ? PFA_WIN_SZ : PFB_WIN_SZ;
+    int pf_win_pos = (pipe == 0) ? PFA_WIN_POS : PFB_WIN_POS;
     uint32_t temp;
 
     ErrorF("ilk crtc %d disable\n", pipe);
@@ -1467,9 +1484,6 @@
 
     /** disable sequence **/
 
-    /* Disable the VGA plane that we never use. */
-    i830_disable_vga_plane (crtc);
-
     /* disable cpu planes */
     temp = INREG(dspcntr_reg);
     if ((temp & DISPLAY_PLANE_ENABLE) != 0)
@@ -1480,6 +1494,9 @@
 	POSTING_READ(dspbase_reg);
     }
 
+    /* Disable the VGA plane that we never use. */
+    i830_disable_vga_plane (crtc);
+
     /* disable cpu pipe, disable after all planes disabled */
     temp = INREG(pipeconf_reg);
     if ((temp & PIPEACONF_ENABLE) != 0) {
@@ -1499,6 +1516,9 @@
 	POSTING_READ(pf_ctl_reg);
     }
 
+    OUTREG(pf_win_size, 0);
+    usleep(100);
+
     /* ignore eDP now */
 
     /* disable CPU FDI tx and PCH FDI rx */
@@ -1526,6 +1546,14 @@
     temp |= FDI_LINK_TRAIN_PATTERN_1;
     OUTREG(fdi_rx_reg, temp);
 
+    if (i830PipeHasType (crtc, I830_OUTPUT_LVDS)) {
+        temp = INREG(PCH_LVDS);
+        OUTREG(PCH_LVDS, temp & ~LVDS_PORT_EN);
+        POSTING_READ(PCH_LVDS);
+        usleep(100);
+    }
+    
+
     /* disable PCH transcoder */
     temp = INREG(transconf_reg);
     if ((temp & TRANS_ENABLE) != 0) {
@@ -1553,12 +1581,14 @@
 #endif
 
     temp = INREG(fdi_rx_reg);
-    if ((temp & FDI_RX_PLL_ENABLE) != 0) {
-	temp &= ~FDI_RX_PLL_ENABLE;
-	temp &= ~FDI_SEL_PCDCLK;
-	OUTREG(fdi_rx_reg, temp & ~FDI_RX_PLL_ENABLE);
-	POSTING_READ(fdi_rx_reg);
-    }
+    temp &= ~FDI_SEL_PCDCLK;
+    OUTREG(fdi_rx_reg, temp);
+    POSTING_READ(fdi_rx_reg);
+    
+    temp = INREG(fdi_rx_reg);
+    temp &= ~FDI_RX_PLL_ENABLE;
+    OUTREG(fdi_rx_reg, temp);
+    POSTING_READ(fdi_rx_reg);
 
     i830WaitForVblank(pScrn);
  }
@@ -1888,7 +1918,7 @@
 #define LINK_N 0x80000
 
 static void
-ilk_compute_m_n(int bytes_per_pixel,
+ilk_compute_m_n(int bits_per_pixel,
 	int nlanes,
 	int pixel_clock,
 	int link_clock,
@@ -1900,7 +1930,8 @@
 
     temp = (uint64_t) DATA_N * pixel_clock;
     temp /= link_clock;
-    m_n->gmch_m = temp * bytes_per_pixel / nlanes;
+    m_n->gmch_m = temp * bits_per_pixel / nlanes;
+    m_n->gmch_m >>= 3; /* convert to bytes_per_pixel */
     m_n->gmch_n = DATA_N;
     ilk_reduce_ratio(&m_n->gmch_m, &m_n->gmch_n);
 
@@ -1958,8 +1989,10 @@
     uint32_t dpll = 0, fp = 0, dspcntr, pipeconf, lvds_bits = 0;
     Bool ok, is_sdvo = FALSE, is_dvo = FALSE;
     Bool is_crt = FALSE, is_lvds = FALSE, is_tv = FALSE;
+    int lvds_reg = LVDS;
     struct ilk_m_n m_n = {0};
     int sdvo_pixel_multiply;
+    uint32_t temp;
 
     /* Set up some convenient bools for what outputs are connected to
      * our pipe, used in DPLL setup.
@@ -2027,12 +2060,64 @@
     }
 
     fp = clock.n << 16 | clock.m1 << 8 | clock.m2;
-    if (IS_IGDNG(pI830))
-       ilk_compute_m_n(3, 4, /* lane num 4 */
+    if (IS_IGDNG(pI830)) {
+       int bpp;
+    
+       /* determine panel color depth */
+       temp = INREG(pipeconf_reg);
+    
+       switch (temp & PIPE_BPC_MASK) {
+       case PIPE_8BPC:
+               bpp = 24;
+               break;
+       case PIPE_10BPC:
+               bpp = 30;
+               break;
+       case PIPE_6BPC:
+               bpp = 18;
+               break;
+       case PIPE_12BPC:
+               bpp = 36;
+               break;
+       default:
+               xf86DrvMsg(pScrn->scrnIndex, X_WARNING,
+               "unknown pipe bpc value\n");
+               bpp = 24;
+       }
+       ilk_compute_m_n(bpp, 4, /* lane num 4 */
                adjusted_mode->Clock,
                270000, /* lane clock */
                &m_n);
+     }
 
+
+   
+     /* IGDNG: try to setup display ref clock before DPLL
+      * enabling. This is only under driver's control after
+      * PCH B stepping, previous chipset stepping should be
+      * ignoring this setting.
+      */
+     if (IS_IGDNG(pI830)) {
+         temp = INREG(PCH_DREF_CONTROL);
+         /* Always enable nonspread source */
+         temp &= ~DREF_NONSPREAD_SOURCE_MASK;
+         temp |= DREF_NONSPREAD_SOURCE_ENABLE;
+         OUTREG(PCH_DREF_CONTROL, temp);
+         POSTING_READ(PCH_DREF_CONTROL);
+    
+         temp &= ~DREF_SSC_SOURCE_MASK;
+         temp |= DREF_SSC_SOURCE_ENABLE;
+         OUTREG(PCH_DREF_CONTROL, temp);
+         POSTING_READ(PCH_DREF_CONTROL);
+     
+         usleep(200);
+     
+         temp |= DREF_CPU_SOURCE_OUTPUT_NONSPREAD;
+         OUTREG(PCH_DREF_CONTROL, temp);
+         POSTING_READ(PCH_DREF_CONTROL);
+     }
+
+
     if (!IS_IGDNG(pI830))
        dpll = DPLL_VGA_MODE_DIS;
     if (IS_I9XX(pI830)) {
@@ -2192,8 +2277,13 @@
      */
     if (is_lvds)
     {
-	uint32_t lvds = INREG(LVDS);
+	uint32_t lvds;
 
+	if (IS_IGDNG(pI830))
+	           lvds_reg = PCH_LVDS;
+	
+	lvds = INREG(lvds_reg);
+
 	lvds |= LVDS_PORT_EN | LVDS_A0A2_CLKA_POWER_UP | LVDS_PIPEB_SELECT;
 	/* Set the B0-B3 data pairs corresponding to whether we're going to
 	 * set the DPLLs for dual-channel mode or not.
@@ -2230,8 +2320,8 @@
 
 	lvds |= lvds_bits;
 
-	OUTREG(LVDS, lvds);
-	POSTING_READ(LVDS);
+	OUTREG(lvds_reg, lvds);
+	POSTING_READ(lvds_reg);
     }
 
     OUTREG(fp_reg, fp);
--- src/i830_hdmi.c	Thu May 27 10:20:20 2010
+++ src/i830_hdmi.c	Thu May 27 10:24:50 2010
@@ -100,13 +100,32 @@
     I830Ptr pI830 = I830PTR(pScrn);
     uint32_t  temp;
 
-    if (mode == DPMSModeOff) {
-	temp = INREG(dev_priv->output_reg);
+    temp = INREG(dev_priv->output_reg);
+
+    /* HW workaround, need to toggle enable bit off and on for 12bpc, but
+     * we do this anyway which shows more stable in testing.
+     */
+    if (IS_IGDNG(pI830)) {
 	OUTREG(dev_priv->output_reg, temp & ~SDVO_ENABLE);
+       POSTING_READ(dev_priv->output_reg);
+    }
+
+    if (mode != DPMSModeOn) {
+       temp &= ~SDVO_ENABLE;
     } else {
-	temp = INREG(dev_priv->output_reg);
-	OUTREG(dev_priv->output_reg, temp | SDVO_ENABLE);
+	temp |= SDVO_ENABLE;
     }
+
+    OUTREG(dev_priv->output_reg, temp);
+    POSTING_READ(dev_priv->output_reg);
+
+    /* HW workaround, need to write this twice for issue that may result
+     * in first write getting masked.
+     */
+    if (IS_IGDNG(pI830)) {
+       OUTREG(dev_priv->output_reg, temp);
+        POSTING_READ(dev_priv->output_reg);
+    }
 }
 
 static void
--- src/i830_lvds.c	Sat Feb 28 12:28:53 2009
+++ src/i830_lvds.c	Thu May 27 10:24:50 2010
@@ -124,7 +124,7 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t blc_pwm_ctl, blc_pwm_ctl2;
+    uint32_t blc_pwm_ctl, blc_pwm_ctl2, reg;
     enum backlight_control method = BCM_NATIVE; /* Default to native */
 
     if (i830_kernel_backlight_available(output)) {
@@ -134,7 +134,11 @@
 	if (blc_pwm_ctl2 & BLM_LEGACY_MODE2)
 	    method = BCM_COMBO;
     } else {
-	blc_pwm_ctl = INREG(BLC_PWM_CTL);
+    	if (IS_IGDNG(pI830))
+            reg = BLC_PWM_CPU_CTL;
+        else
+            reg = BLC_PWM_CTL;
+        blc_pwm_ctl = INREG(reg);
 	if (blc_pwm_ctl & BLM_LEGACY_MODE)
 	    method = BCM_COMBO;
     }
@@ -150,11 +154,17 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t blc_pwm_ctl;
+    uint32_t blc_pwm_ctl, reg;
 
-    blc_pwm_ctl = INREG(BLC_PWM_CTL);
+    if (IS_IGDNG(pI830))
+        reg = BLC_PWM_CPU_CTL;
+    else
+        reg = BLC_PWM_CTL;
+    blc_pwm_ctl = INREG(reg);
     blc_pwm_ctl &= ~BACKLIGHT_DUTY_CYCLE_MASK;
-    OUTREG(BLC_PWM_CTL, blc_pwm_ctl | (level << BACKLIGHT_DUTY_CYCLE_SHIFT));
+    OUTREG(reg, blc_pwm_ctl | (level << BACKLIGHT_DUTY_CYCLE_SHIFT));
+    POSTING_READ(reg);
+    _debug("set level %d", level);
 }
 
 static int
@@ -162,10 +172,15 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t blc_pwm_ctl;
+    uint32_t blc_pwm_ctl, reg;
+    if (IS_IGDNG(pI830))
+        reg = BLC_PWM_CPU_CTL;
+    else
+        reg = BLC_PWM_CTL;
+    blc_pwm_ctl = INREG(reg);
 
-    blc_pwm_ctl = INREG(BLC_PWM_CTL);
     blc_pwm_ctl &= BACKLIGHT_DUTY_CYCLE_MASK;
+    _debug("get level 0x%x", blc_pwm_ctl);
     return blc_pwm_ctl;
 }
 
@@ -174,9 +189,15 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t pwm_ctl = INREG(BLC_PWM_CTL);
+    uint32_t pwm_ctl, reg;
     int val;
 
+    if (IS_IGDNG(pI830))
+        reg = BLC_PWM_CPU_CTL2;
+    else
+        reg = BLC_PWM_CTL;
+    pwm_ctl = INREG(reg);
+
     if (IS_I965GM(pI830) || IS_GM45(pI830)) {
 	val = ((pwm_ctl & BACKLIGHT_MODULATION_FREQ_MASK2) >>
 	       BACKLIGHT_MODULATION_FREQ_SHIFT2);
@@ -185,6 +206,8 @@
 	       BACKLIGHT_MODULATION_FREQ_SHIFT) * 2;
     }
 
+   _debug("max level 0x%x", val);
+
     return val;
 }
 
@@ -229,7 +252,7 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t blc_pwm_ctl;
+    uint32_t blc_pwm_ctl, reg;
     uint8_t lbb;
 
 #if XSERVER_LIBPCIACCESS
@@ -256,9 +279,14 @@
      */
     level <<= 1;
 
-    blc_pwm_ctl = INREG(BLC_PWM_CTL);
+    if (IS_IGDNG(pI830))
+        reg = BLC_PWM_CPU_CTL;
+    else
+        reg = BLC_PWM_CTL;
+    blc_pwm_ctl = INREG(reg);
+
     blc_pwm_ctl &= ~BACKLIGHT_DUTY_CYCLE_MASK;
-    OUTREG(BLC_PWM_CTL, blc_pwm_ctl | (level << BACKLIGHT_DUTY_CYCLE_SHIFT));
+    OUTREG(reg, blc_pwm_ctl | (level << BACKLIGHT_DUTY_CYCLE_SHIFT));
 }
 
 static int
@@ -266,9 +294,13 @@
 {
     ScrnInfoPtr pScrn = output->scrn;
     I830Ptr pI830 = I830PTR(pScrn);
-    uint32_t blc_pwm_ctl;
+    uint32_t blc_pwm_ctl, reg;
 
-    blc_pwm_ctl = INREG(BLC_PWM_CTL);
+    if (IS_IGDNG(pI830))
+        reg = BLC_PWM_CPU_CTL;
+    else
+        reg = BLC_PWM_CTL;
+    blc_pwm_ctl = INREG(reg);
     blc_pwm_ctl &= BACKLIGHT_DUTY_CYCLE_MASK;
 
     /* Since we don't use the low bit when using combo, the value is halved */
@@ -386,11 +418,20 @@
     struct i830_lvds_priv   *dev_priv = intel_output->dev_priv;
     ScrnInfoPtr		    pScrn = output->scrn;
     I830Ptr		    pI830 = I830PTR(pScrn);
-    uint32_t		    pp_status;
+    uint32_t   pp_status, ctl_reg, status_reg;
 
+    if (IS_IGDNG(pI830)) {
+            ctl_reg = PCH_PP_CONTROL;
+            status_reg = PCH_PP_STATUS;
+    } else {
+            ctl_reg = PP_CONTROL;
+            status_reg = PP_STATUS;
+    }
+    
+
     if (on) {
 	/* if we're going from on->on, be aware to current level. */
-	if ((INREG(PP_CONTROL) & POWER_TARGET_ON) && !dev_priv->dpmsoff) 
+	if ((INREG(ctl_reg) & POWER_TARGET_ON) && !dev_priv->dpmsoff)
 	    dev_priv->backlight_duty_cycle = dev_priv->get_backlight(output);
 
 	/*
@@ -400,33 +441,35 @@
 	 * controller for example), so on them, when turning LVDS back on,
 	 * they'll always re-maximize the brightness.
 	 */
-	if (!(INREG(PP_CONTROL) & POWER_TARGET_ON) &&
+	if (!(INREG(ctl_reg) & POWER_TARGET_ON) &&
 	    dev_priv->backlight_duty_cycle == 0 &&
 	    pI830->backlight_control_method < BCM_KERNEL)
 	    dev_priv->backlight_duty_cycle = dev_priv->backlight_max;
 
-	OUTREG(PP_CONTROL, INREG(PP_CONTROL) | POWER_TARGET_ON);
+      	OUTREG(ctl_reg, INREG(ctl_reg) | POWER_TARGET_ON);
 	do {
-	    pp_status = INREG(PP_STATUS);
+	    pp_status = INREG(status_reg);
 	} while ((pp_status & PP_ON) == 0);
 
 	dev_priv->set_backlight(output, dev_priv->backlight_duty_cycle);
 	dev_priv->dpmsoff = FALSE;
+  	_debug("on");
     } else {
 	/*
 	 * Only save the current backlight value if we're going from
 	 * on to off.
 	 */
-	if ((INREG(PP_CONTROL) & POWER_TARGET_ON) && !dev_priv->dpmsoff)
+	if ((INREG(ctl_reg) & POWER_TARGET_ON) && !dev_priv->dpmsoff)
 	    dev_priv->backlight_duty_cycle = dev_priv->get_backlight(output);
 	dev_priv->set_backlight(output, 0);
 
-	OUTREG(PP_CONTROL, INREG(PP_CONTROL) & ~POWER_TARGET_ON);
+	OUTREG(ctl_reg, INREG(ctl_reg) & ~POWER_TARGET_ON);
 	do {
-	    pp_status = INREG(PP_STATUS);
+	    pp_status = INREG(status_reg);
 	} while (pp_status & PP_ON);
 
 	dev_priv->dpmsoff = TRUE;
+	_debug("off");
     }
 }
 
@@ -448,15 +491,40 @@
     struct i830_lvds_priv   *dev_priv = intel_output->dev_priv;
     ScrnInfoPtr		    pScrn = output->scrn;
     I830Ptr		    pI830 = I830PTR(pScrn);
+    uint32_t   pp_on_reg, pp_off_reg, pp_ctl_reg, pp_div_reg;
+    uint32_t   pwm_ctl_reg;
 
+    if (IS_IGDNG(pI830)) {
+        pp_on_reg = PCH_PP_ON_DELAYS;
+        pp_off_reg = PCH_PP_OFF_DELAYS;
+        pp_ctl_reg = PCH_PP_CONTROL;
+        pp_div_reg = PCH_PP_DIVISOR;
+        pwm_ctl_reg = BLC_PWM_CPU_CTL;
+    } else {
+        pp_on_reg = PP_ON_DELAYS;
+        pp_off_reg = PP_OFF_DELAYS;
+        pp_ctl_reg = PP_CONTROL;
+        pp_div_reg = PP_DIVISOR;
+        pwm_ctl_reg = BLC_PWM_CTL;
+    }
+
     if (IS_I965GM(pI830) || IS_GM45(pI830))
 	pI830->saveBLC_PWM_CTL2 = INREG(BLC_PWM_CTL2);
-    pI830->savePP_ON = INREG(PP_ON_DELAYS);
-    pI830->savePP_OFF = INREG(PP_OFF_DELAYS);
-    pI830->savePP_CONTROL = INREG(PP_CONTROL);
-    pI830->savePP_DIVISOR = INREG(PP_DIVISOR);
-    pI830->saveBLC_PWM_CTL = INREG(BLC_PWM_CTL);
-    if ((INREG(PP_CONTROL) & POWER_TARGET_ON) && !dev_priv->dpmsoff) 
+
+    pI830->savePP_ON = INREG(pp_on_reg);
+    pI830->savePP_OFF = INREG(pp_off_reg);
+    pI830->savePP_CONTROL = INREG(pp_ctl_reg);
+    pI830->savePP_DIVISOR = INREG(pp_div_reg);
+    pI830->saveBLC_PWM_CTL = INREG(pwm_ctl_reg);
+
+    if (IS_IGDNG(pI830)) {
+        pI830->saveBLC_PWM_CTL = INREG(BLC_PWM_PCH_CTL1);
+        pI830->saveBLC_PWM_CTL2 = INREG(BLC_PWM_PCH_CTL2);
+        pI830->saveBLC_CPU_PWM_CTL = INREG(BLC_PWM_CPU_CTL);
+        pI830->saveBLC_CPU_PWM_CTL2 = INREG(BLC_PWM_CPU_CTL2);
+        pI830->saveLVDS = INREG(PCH_LVDS);
+    }
+    if ((INREG(pp_ctl_reg) & POWER_TARGET_ON) && !dev_priv->dpmsoff)
 	dev_priv->backlight_duty_cycle = dev_priv->get_backlight(output);
 }
 
@@ -465,14 +533,38 @@
 {
     ScrnInfoPtr	pScrn = output->scrn;
     I830Ptr	pI830 = I830PTR(pScrn);
+    uint32_t    pp_on_reg, pp_off_reg, pp_ctl_reg, pp_div_reg;
+    uint32_t    pwm_ctl_reg;
 
+    if (IS_IGDNG(pI830)) {
+        pp_on_reg = PCH_PP_ON_DELAYS;
+        pp_off_reg = PCH_PP_OFF_DELAYS;
+        pp_ctl_reg = PCH_PP_CONTROL;
+        pp_div_reg = PCH_PP_DIVISOR;
+        pwm_ctl_reg = BLC_PWM_CPU_CTL;
+
+    } else {
+        pp_on_reg = PP_ON_DELAYS;
+        pp_off_reg = PP_OFF_DELAYS;
+        pp_ctl_reg = PP_CONTROL;
+        pp_div_reg = PP_DIVISOR;
+        pwm_ctl_reg = BLC_PWM_CTL;
+    }
+
     if (IS_I965GM(pI830) || IS_GM45(pI830))
-	OUTREG(BLC_PWM_CTL2, pI830->saveBLC_PWM_CTL2);
-    OUTREG(BLC_PWM_CTL, pI830->saveBLC_PWM_CTL);
-    OUTREG(PP_ON_DELAYS, pI830->savePP_ON);
-    OUTREG(PP_OFF_DELAYS, pI830->savePP_OFF);
-    OUTREG(PP_DIVISOR, pI830->savePP_DIVISOR);
-    OUTREG(PP_CONTROL, pI830->savePP_CONTROL);
+    	OUTREG(BLC_PWM_CTL2, pI830->saveBLC_PWM_CTL2);
+    OUTREG(pwm_ctl_reg, pI830->saveBLC_PWM_CTL);
+    OUTREG(pp_on_reg, pI830->savePP_ON);
+    OUTREG(pp_off_reg, pI830->savePP_OFF);
+    OUTREG(pp_div_reg, pI830->savePP_DIVISOR);
+    OUTREG(pp_ctl_reg, pI830->savePP_CONTROL);
+   if (IS_IGDNG(pI830)) {
+        OUTREG(BLC_PWM_PCH_CTL1, pI830->saveBLC_PWM_CTL);
+        OUTREG(BLC_PWM_PCH_CTL2, pI830->saveBLC_PWM_CTL2);
+        OUTREG(BLC_PWM_CPU_CTL, pI830->saveBLC_CPU_PWM_CTL);
+        OUTREG(BLC_PWM_CPU_CTL2, pI830->saveBLC_CPU_PWM_CTL2);
+        OUTREG(PCH_LVDS, pI830->saveLVDS);
+    }
     if (pI830->savePP_CONTROL & POWER_TARGET_ON)
 	i830SetLVDSPanelPower(output, TRUE);
     else
@@ -525,7 +617,7 @@
 	}
     }
 
-    if (intel_crtc->pipe == 0) {
+    if (!IS_IGDNG(pI830) && (intel_crtc->pipe == 0)) {
 	xf86DrvMsg(pScrn->scrnIndex, X_ERROR,
 		   "Can't support LVDS on pipe A\n");
 	return FALSE;
@@ -563,6 +655,11 @@
 	goto out;
     }
 
+    /* full screen scale for now */
+        if (IS_IGDNG(pI830))
+             goto out;
+
+
     /* 965+ wants fuzzy fitting */
     if (IS_I965G(pI830))
 	pfit_control |= (intel_crtc->pipe << PFIT_PIPE_SHIFT) |
@@ -583,8 +680,10 @@
      * register description and PRM.
      */
     /* Change the value here to see the borders for debugging */
-    OUTREG(BCLRPAT_A, 0);
-    OUTREG(BCLRPAT_B, 0);
+    if (!IS_IGDNG(pI830)) {
+        OUTREG(BCLRPAT_A, 0);
+        OUTREG(BCLRPAT_B, 0);
+    }
     switch (dev_priv->fitting_mode) {
     case CENTER:
 	/*
@@ -757,6 +856,15 @@
     ScrnInfoPtr		    pScrn = output->scrn;
     I830Ptr		    pI830 = I830PTR(pScrn);
 
+     /*
+     * The LVDS pin pair will already have been turned on in the
+     * intel_crtc_mode_set since it has a large impact on the DPLL
+     * settings.
+     */
+
+    if (IS_IGDNG(pI830))
+          return;
+
     /*
      * PFIT must be enabled/disabled while LVDS is on but pipes are still off
      */
@@ -786,7 +894,7 @@
     timing->h_blanking = mode->HTotal - mode->HDisplay;
     timing->v_active = mode->VDisplay;
     timing->v_blanking = mode->VTotal - mode->VDisplay;
-    timing->h_sync_off = mode->HSyncStart - mode->HDisplay;
+    
     timing->h_sync_width = mode->HSyncEnd - mode->HSyncStart;
     timing->v_sync_off = mode->VSyncStart - mode->VDisplay;
     timing->v_sync_width = mode->VSyncEnd - mode->VSyncStart;
@@ -959,6 +1067,7 @@
     I830OutputPrivatePtr    intel_output = output->driver_private;
     struct i830_lvds_priv   *dev_priv = intel_output->dev_priv;
 
+     _debug("backlight_control_method %d \n", pI830->backlight_control_method);
     switch (pI830->backlight_control_method) {
     case BCM_NATIVE:
 	dev_priv->set_backlight = i830_lvds_set_backlight_native;
@@ -1295,10 +1404,17 @@
     DisplayModePtr	    modes, scan;
     DisplayModePtr	    lvds_ddc_mode = NULL;
     struct i830_lvds_priv   *dev_priv;
+    int gpio = GPIOC;
 
     if (pI830->quirk_flag & QUIRK_IGNORE_LVDS)
 	return;
 
+    if (IS_IGDNG(pI830)) {
+        if ((INREG(PCH_LVDS) & LVDS_DETECTED) == 0)
+                return;
+        gpio = PCH_GPIOC;
+    }
+
     output = xf86OutputCreate (pScrn, &i830_lvds_output_funcs, "LVDS");
     if (!output)
 	return;
@@ -1311,6 +1427,8 @@
     }
     intel_output->type = I830_OUTPUT_LVDS;
     intel_output->pipe_mask = (1 << 1);
+    if (IS_I965G(pI830))
+       intel_output->pipe_mask |= (1 << 0);
     intel_output->clone_mask = (1 << I830_OUTPUT_LVDS);
     
     output->driver_private = intel_output;
@@ -1333,7 +1451,7 @@
     /* Set up the LVDS DDC channel.  Most panels won't support it, but it can
      * be useful if available.
      */
-    I830I2CInit(pScrn, &intel_output->pDDCBus, GPIOC, "LVDSDDC_C");
+    I830I2CInit(pScrn, &intel_output->pDDCBus, gpio, "LVDSDDC_C");
 
     if (pI830->skip_panel_detect) {
 	xf86DrvMsg(pScrn->scrnIndex, X_INFO,
@@ -1427,6 +1545,8 @@
 
     i830_set_lvds_backlight_method(output);
 
+    _debug("backlight_control_method %d \n", pI830->backlight_control_method);
+
     switch (pI830->backlight_control_method) {
     case BCM_NATIVE:
 	dev_priv->set_backlight = i830_lvds_set_backlight_native;
--- src/i830_bios.h	Wed Jan 21 14:02:00 2009
+++ src/i830_bios.h	Thu May 27 10:24:50 2010
@@ -395,6 +395,23 @@
     struct vch_panel_data   panels[16];
 } __attribute__((packed));
 
+struct bdb_sdvo_lvds_options {
+    uint8_t     panel_backlight;
+    uint8_t     h40_set_panel_type;
+    uint8_t     panel_type;
+    uint8_t     ssc_clk_freq;
+    uint16_t    als_low_trip;
+    uint16_t    als_high_trip;
+    uint8_t     sclalarcoeff_tab_row_num;
+    uint8_t     sclalarcoeff_tab_row_size;
+    uint8_t     coefficient[8];
+    uint8_t     panel_misc_bits_1;
+    uint8_t     panel_misc_bits_2;
+    uint8_t     panel_misc_bits_3;
+    uint8_t     panel_misc_bits_4;
+} __attribute__((packed));
+
+
 #ifndef REG_DUMPER
 int i830_bios_init(ScrnInfoPtr pScrn);
 #endif
--- src/i830_lvds.c	Fri May 28 08:34:40 2010
+++ src/i830_lvds.c	Fri May 28 08:35:16 2010
@@ -1427,7 +1427,7 @@
     }
     intel_output->type = I830_OUTPUT_LVDS;
     intel_output->pipe_mask = (1 << 1);
-    if (IS_I965G(pI830))
+    if (IS_IGDNG(pI830))
        intel_output->pipe_mask |= (1 << 0);
     intel_output->clone_mask = (1 << I830_OUTPUT_LVDS);
     
