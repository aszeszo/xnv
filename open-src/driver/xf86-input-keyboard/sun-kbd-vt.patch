diff -urp -x '*~' -x '*.orig' src/sun_kbd.c src/sun_kbd.c
--- src/sun_kbd.c	2009-08-13 13:19:37.444951000 +0800
+++ src/sun_kbd.c	2009-08-13 13:19:37.668124000 +0800
@@ -63,6 +63,7 @@
 #include <sys/stropts.h>
 #include <sys/vuid_event.h>
 #include <sys/kbd.h>
+#include <sys/usb/clients/hid/hid.h>
 
 static int KbdOn(InputInfoPtr pInfo, int what);
 
@@ -178,6 +179,8 @@ KbdOn(InputInfoPtr pInfo, int what)
     sunKbdPrivPtr priv = (sunKbdPrivPtr) pKbd->private;
 
     int	ktrans, kdirect, i;
+    int io_get_direct = KIOCGDIRECT;
+    int io_set_direct = KIOCSDIRECT;
 
     if (priv->kbdActive) {
 	return Success;
@@ -190,9 +193,15 @@ KbdOn(InputInfoPtr pInfo, int what)
 		    "%s: cannot push module '%s' onto keyboard device: %s\n",
 		    pInfo->name, priv->strmod, strerror(errno));
 	}
+
+	if (strcmp(priv->strmod, "usbkbm") == 0) {
+	    io_get_direct = HIDIOCKMGDIRECT;
+	    io_set_direct = HIDIOCKMSDIRECT;
+	}
+
     }
 
-    SYSCALL(i = ioctl(pInfo->fd, KIOCGDIRECT, &kdirect));
+    SYSCALL(i = ioctl(pInfo->fd, io_get_direct, &kdirect));
     if (i < 0) {
 	xf86Msg(X_ERROR, 
 		"%s: Unable to determine keyboard direct setting: %s\n", 
@@ -203,7 +212,7 @@ KbdOn(InputInfoPtr pInfo, int what)
     priv->odirect = kdirect;
     kdirect = 1;
 
-    SYSCALL(i = ioctl(pInfo->fd, KIOCSDIRECT, &kdirect));
+    SYSCALL(i = ioctl(pInfo->fd, io_set_direct, &kdirect));
     if (i < 0) {
 	xf86Msg(X_ERROR, "%s: Failed turning keyboard direct mode on: %s\n",
 			pInfo->name, strerror(errno));
@@ -247,6 +256,7 @@ KbdOff(InputInfoPtr pInfo, int what)
     sunKbdPrivPtr priv = (sunKbdPrivPtr) pKbd->private;
 
     int i;
+    int io_set_direct, kdirect;
 
     if (!priv->kbdActive) {
 	return Success;
@@ -280,8 +290,16 @@ KbdOff(InputInfoPtr pInfo, int what)
 	priv->otranslation = -1;
     }
 
-    if (priv->odirect != -1) {
-        SYSCALL(i = ioctl(pInfo->fd, KIOCSDIRECT, &priv->odirect));
+    io_set_direct = KIOCSDIRECT;
+    kdirect = priv->odirect;
+
+    if ((priv->strmod != NULL) && (strcmp(priv->strmod, "usbkbm") == 0)) {
+	io_set_direct = HIDIOCKMSDIRECT;
+	kdirect = 0;
+    }
+
+    if (kdirect != -1) {
+        SYSCALL(i = ioctl(pInfo->fd, io_set_direct, &kdirect));
 	if (i < 0) {
 	    xf86Msg(X_ERROR,
 		    "%s: Unable to restore keyboard direct setting: %s\n",
