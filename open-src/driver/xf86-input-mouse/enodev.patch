# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
#

6844148 Xorg support for errno ENODEV from mouse devices

Based on xf86-input-keyboard fix for 6835394

diff -Nurp -x '*~' -x '*.orig' src/sun_mouse.c src/sun_mouse.c
--- src/sun_mouse.c	2009-09-20 19:02:57.000000000 -0700
+++ src/sun_mouse.c	2010-01-20 15:17:08.303078733 -0800
@@ -23,7 +23,7 @@
  * dealings in this Software without prior written authorization from the
  * XFree86 Project.
  */
-/* Copyright 2004-2005, 2008-2009 Sun Microsystems, Inc.  All rights reserved.
+/* Copyright 2004-2005, 2008-2010, Oracle and/or its affiliates. All rights reserved.
  *
  * Permission is hereby granted, free of charge, to any person obtaining a
  * copy of this software and associated documentation files (the
@@ -107,6 +107,7 @@ typedef struct _VuidMseRec {
 #ifdef HAVE_ABSOLUTE_MOUSE_SCALING
     Ms_screen_resolution	 absres;
 #endif
+    OsTimerPtr		remove_timer;   /* Callback for removal on ENODEV */
 } VuidMseRec, *VuidMsePtr;
 
 static VuidMsePtr	vuidMouseList = NULL;
@@ -138,6 +139,18 @@ VuidMsePtr getVuidMsePriv(InputInfoPtr p
     return m;
 }
 
+/* Called from OsTimer callback, since removing a device from the device
+   list or changing pInfo->fd while xf86Wakeup is looping through the list
+   causes server crashes */
+static CARD32
+vuidRemoveMouse(OsTimerPtr timer, CARD32 time, pointer arg)
+{
+    InputInfoPtr pInfo = (InputInfoPtr) arg;
+
+    xf86DisableDevice(pInfo->dev, TRUE);
+
+    return 0;  /* All done, don't set to run again */
+}
 
 /*
  * Initialize and enable the mouse wheel, if present.
@@ -334,19 +347,40 @@ vuidReadInput(InputInfoPtr pInfo)
     pMse = pInfo->private;
     pVuidMse = getVuidMsePriv(pInfo);
     buttons = pMse->lastButtons;
-    XisbBlockDuration(pMse->buffer, -1);
     pBuf = pVuidMse->buffer;
     n = 0;
 
     do {
-	while (n < sizeof(Firm_event) && (c = XisbRead(pMse->buffer)) >= 0) {
-	    pBuf[n++] = (unsigned char)c;
-	}
-
-	if (n == 0)
-	    return;
+	n = read(pInfo->fd, pBuf, sizeof(Firm_event));
 
-	if (n != sizeof(Firm_event)) {
+	if (n == 0) {
+	    break;
+	} else if (n == -1) {
+	    switch (errno) {
+		case EAGAIN: /* Nothing to read now */
+		    n = 0;   /* End loop, go on to flush events & return */
+		    continue;
+		case EINTR:  /* Interrupted, try again */
+		    continue;
+		case ENODEV: /* May happen when USB mouse is unplugged */
+		    /* We use X_NONE here because it doesn't alloc since we
+		       may be called from SIGIO handler */
+		    xf86MsgVerb(X_NONE, 0,
+				"%s: Device no longer present - removing.\n",
+				pInfo->name);
+		    xf86RemoveEnabledDevice(pInfo);
+		    pVuidMse->remove_timer =
+			TimerSet(pVuidMse->remove_timer, 0, 1,
+				 vuidRemoveMouse, pInfo);
+		    return;
+		default:     /* All other errors */
+		    /* We use X_NONE here because it doesn't alloc since we
+		       may be called from SIGIO handler */
+		    xf86MsgVerb(X_NONE, 0, "%s: Read error: %s\n", pInfo->name,
+				strerror(errno));
+		    return;
+	    }
+	} else if (n != sizeof(Firm_event)) {
 	    xf86Msg(X_WARNING, "%s: incomplete packet, size %d\n",
 			pInfo->name, n);
 	}
@@ -416,11 +450,6 @@ vuidReadInput(InputInfoPtr pInfo)
 	}
 #endif
 
-	n = 0;
-	if ((c = XisbRead(pMse->buffer)) >= 0) {
-	    /* Another packet.  Handle it right away. */
-	    pBuf[n++] = c;
-	}
     } while (n != 0);
 
     if (absXset || absYset) {
@@ -563,6 +592,13 @@ vuidMouseProc(DeviceIntPtr pPointer, int
 	    vuidMouseSendScreenSize(screenInfo.screens[0], pVuidMse);
 #endif	    
 	    xf86FlushInput(pInfo->fd);
+
+	    /* Allocate here so we don't alloc in ReadInput which may be called
+	       from SIGIO handler. */
+	    if (pVuidMse->remove_timer == NULL) {
+		pVuidMse->remove_timer = TimerSet(pVuidMse->remove_timer,
+						  0, 0, NULL, NULL);
+	    }
 	}
 	break;
 
@@ -578,6 +614,10 @@ vuidMouseProc(DeviceIntPtr pPointer, int
 		}
 	    }
 	}
+	if (pVuidMse->remove_timer) {
+	    TimerFree(pVuidMse->remove_timer);
+	    pVuidMse->remove_timer = NULL;
+	}
 	ret = pVuidMse->wrapped_device_control(pPointer, what);
 	break;
 
