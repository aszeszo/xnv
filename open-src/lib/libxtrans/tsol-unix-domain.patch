/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 *
 */

Unix domain rendezvous created under /var/tsol/doors/ for Trusted
Extensions. This directory is loopback mounted into all labeled
zones from the global zone. A link is created from /tmp/.X11-unix
to the above loopback mounted dir.
(See LSARC/2008/506)

diff -urp -x '*~' Xtranssock.c Xtranssock.c
--- Xtranssock.c	2008-09-18 14:32:55
+++ Xtransock.c		2008-09-18 14:35:26
@@ -83,6 +83,10 @@
 #include <sys/stat.h>
 #endif
 
+#if defined(X11_t)
+#include <tsol/label.h>
+#endif /* X11_t */
+
 #if defined(hpux) || (defined(MOTOROLA) && defined(SYSV))
 #define NO_TCP_H
 #endif 
@@ -252,6 +256,7 @@
 #if defined(X11_t)
 #define UNIX_PATH "/tmp/.X11-unix/X"
 #define UNIX_DIR "/tmp/.X11-unix"
+#define TSOL_UNIX_DIR  "/var/tsol/doors/.X11-unix"
 #endif /* X11_t */
 #if defined(XIM_t)
 #define UNIX_PATH "/tmp/.XIM-unix/XIM"
@@ -1094,6 +1099,29 @@
 #else
     mode = 0777;
 #endif
+
+#ifdef X11_t
+    if (is_system_labeled()) {
+	struct stat sbuf;
+
+        if (trans_mkdir(TSOL_UNIX_DIR, mode) == -1) {
+	    PRMSG (1, "SocketUNIXCreateListener: mkdir(%s) failed, errno = %d\n",
+	       TSOL_UNIX_DIR, errno, 0);
+	    (void) umask (oldUmask);
+	    return TRANS_CREATE_LISTENER_FAILED;
+        }
+
+        /* Create a symlink for UNIX_DIR to TSOL_UNIX_DIR */
+        if (stat(UNIX_DIR, &sbuf) != 0 && symlink(TSOL_UNIX_DIR, UNIX_DIR) != 0) {
+		PRMSG (1, 
+		    "SocketUNIXCreateListener: symlink to %s failed, errno = %d\n",
+	       	    TSOL_UNIX_DIR, errno, 0);
+	    (void) umask (oldUmask);
+	    return TRANS_CREATE_LISTENER_FAILED;
+        }
+
+    } else 
+#endif /* X11_t */
     if (trans_mkdir(UNIX_DIR, mode) == -1) {
 	PRMSG (1, "SocketUNIXCreateListener: mkdir(%s) failed, errno = %d\n",
 	       UNIX_DIR, errno, 0);
@@ -1992,10 +2020,28 @@
 	return TRANS_CONNECT_FAILED;
     }
 
+#if defined(X11_t) 
+    /* 
+     * Create a symlink for UNIX_DIR to TSOL_UNIX_DIR
+     * This link is created in the labeled (non-global) zones.
+     * The rendezvous created by the X server resides in the global zone
+     * and is mounted read-only to other zones.
+     */
+    if (is_system_labeled()) {
+	struct stat sbuf;
+
+        if (stat(UNIX_DIR, &sbuf) != 0 && symlink(TSOL_UNIX_DIR, UNIX_DIR) != 0) {
+	    PRMSG (1, "SocketUNIXConnect:: symlink to %s failed, errno = %d\n",
+		TSOL_UNIX_DIR, errno, 0);
+	    return TRANS_CONNECT_FAILED;
+         }
+     }
+#endif /* X11_t */
+
     /*
      * Build the socket name.
      */
-    
+
     sockname.sun_family = AF_UNIX;
 
     if (set_sun_path(port, UNIX_PATH, sockname.sun_path) != 0) {
