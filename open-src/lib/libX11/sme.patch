###############################################################################
# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use subject to license terms.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, provided that the above
# copyright notice(s) and this permission notice appear in all copies of
# the Software and that both the above copyright notice(s) and this
# permission notice appear in supporting documentation.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
# OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
# INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# 
# Except as contained in this notice, the name of a copyright holder
# shall not be used in advertising or otherwise to promote the sale, use
# or other dealings in this Software without prior written authorization
# of the copyright holder.
#
diff -urp -x '*~' -x '*.orig' include/X11/Xlibint.h include/X11/Xlibint.h
--- include/X11/Xlibint.h	2009-04-08 00:18:36.242153000 -0700
+++ include/X11/Xlibint.h	2009-04-08 00:18:46.488588000 -0700
@@ -185,6 +185,10 @@ struct _XDisplay
 	struct _XkbInfoRec *xkb_info; /* XKB info */
 	struct _XtransConnInfo *trans_conn; /* transport connection object */
 	struct _X11XCBPrivate *xcb; /* XCB glue private data */
+#ifdef SUNSOFT
+	char *smeBuffer;	/* Address of sme region */
+	int smeSize;		/* size of sme region */
+#endif /* SME */
 };
 
 #if defined(XTHREADS) && defined(SUNSOFT)
@@ -905,6 +909,15 @@ typedef struct _XExten {		/* private to 
 	struct _XExten *next_flush;	/* next in list of those with flushes */
 } _XExtension;
 
+/* XSUNBUFFERSIZE */
+/* Moved from XlibInt.c. This is now used in OpenDis.c also */
+#ifdef sun /* added by SUNSOFT */
+typedef union {
+	xReply rep;
+	char *buf;
+} _XAlignedBuffer;
+#endif /*  sun  */
+
 /* extension hooks */
 
 #ifdef DataRoutineIsProcedure
diff -urp -x '*~' -x '*.orig' src/ConnDis.c src/ConnDis.c
--- src/ConnDis.c	2008-11-18 22:42:01.000000000 -0800
+++ src/ConnDis.c	2009-04-08 00:18:46.494720000 -0700
@@ -137,7 +137,12 @@ _X11TransConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
     int family;
     int saddrlen;
@@ -164,6 +169,9 @@ _X11TransConnectDisplay (
     int local_transport_index = -1;
     const char *local_transport[] = { LOCAL_TRANSPORT_LIST, NULL };
 #endif
+#ifdef SUNSOFT
+    char *xsuntransport = NULL;
+#endif /* SME */
 
     p = display_name;
 
@@ -273,6 +281,13 @@ _X11TransConnectDisplay (
 	}
     }
 
+#ifdef SUNSOFT
+    if ((xsuntransport = getenv("XSUNTRANSPORT")) != NULL) {
+        if (!phostname && (strncmp("shmem", xsuntransport,  5) == 0))
+            *sme_conn = 1;
+    }
+#endif /* SME */
+
     /*
      * At this point, we know the following information:
      *
@@ -505,13 +520,23 @@ int _XConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
    XtransConnInfo trans_conn;
 
    trans_conn = _X11TransConnectDisplay (
 		      display_name, fullnamep, dpynump, screenp,
+#ifdef SUNSOFT /* SME */
+		      auth_namep, auth_namelenp, auth_datap, auth_datalenp,
+		      sme_conn);
+#else
 		      auth_namep, auth_namelenp, auth_datap, auth_datalenp);
+#endif /* SME */
 
    if (trans_conn)
    {
diff -urp -x '*~' -x '*.orig' src/OpenDis.c src/OpenDis.c
--- src/OpenDis.c	2009-04-08 00:18:36.386967000 -0700
+++ src/OpenDis.c	2009-04-08 00:18:46.495581000 -0700
@@ -52,6 +52,11 @@ in this Software without prior written a
 #include <X11/extensions/XInteractive.h>
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+#include <X11/extensions/sme.h>
+#include <sys/mman.h>
+#endif /* SME */
+
 #if !USE_XCB
 #ifdef X_NOT_POSIX
 #define Size_t unsigned int
@@ -67,6 +72,13 @@ typedef struct {
 } _XBigReqState;
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+void _XSmeAllocateHeapBuffer(
+    Display *dpy,
+    smeRegion *smeBp
+);
+#endif /* SME */
+
 #if defined(XTHREADS) && defined(SUNSOFT)
 DisplayPtrLink *HeadDisplay=NULL;
 DisplayPtrLink *LastDisplay=NULL;
@@ -84,6 +96,12 @@ void (*_XFreeDisplayLock_fn)(Display *dp
 #define FreeDisplayLock(dis)
 #endif /* XTHREADS */
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+int             _conn_buf_size = 0;
+int             _conn_ref_cnt = 0;
+_XAlignedBuffer _conn_aligned_buf;
+#endif /* SUNSOFT */
+
 static xReq _dummy_request = {
 	0, 0, 0
 };
@@ -94,6 +112,10 @@ static Bool _XBigReqHandler(Display *dpy
 				XPointer data);
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+static void InitializeSmeConn(Display *dpy, int dpynum);
+#endif /* SME */
+
 /*
  * Connects to a server, creates a Display object and returns a pointer to
  * the newly created Display back to the caller.
@@ -131,8 +153,13 @@ XOpenDisplay (
 	long setuplength;	/* number of bytes in setup message */
 	long usedbytes = 0;     /* number of bytes we have processed */
 	unsigned long mask;
+#ifdef SUNSOFT
+        int sme_conn = 0;
+#endif /* SME */
+#ifndef SUNSOFT
        long int conn_buf_size;
        char *xlib_buffer_size;
+#endif
 
 #if !USE_XCB
 	bzero((char *) &client, sizeof(client));
@@ -185,7 +212,11 @@ XOpenDisplay (
 					 display_name, &fullname, &idisplay,
 					 &iscreen, &conn_auth_name,
 					 &conn_auth_namelen, &conn_auth_data,
-					 &conn_auth_datalen)) == NULL) {
+					 &conn_auth_datalen
+#ifdef SUNSOFT
+                                        , &sme_conn
+#endif /* SME */
+		)) == NULL) {
 		Xfree ((char *) dpy);
 		return(NULL);
 	}
@@ -284,6 +315,28 @@ XOpenDisplay (
 	}
 
 	/* Set up the output buffers. */
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+#define DEFAULTBUFSIZE 16384
+	if (!_conn_buf_size) {
+	    char *xsunbuffersize;
+
+	    if ((xsunbuffersize = getenv("XSUNBUFFERSIZE")) == NULL)
+		_conn_buf_size = DEFAULTBUFSIZE;
+	    else
+		_conn_buf_size = 1024 * atoi(xsunbuffersize);
+	    if (_conn_buf_size < DEFAULTBUFSIZE)
+		_conn_buf_size = DEFAULTBUFSIZE;
+
+	    _conn_aligned_buf.buf = Xmalloc(_conn_buf_size);
+	}
+	_conn_ref_cnt++;
+
+	if ((dpy->bufptr = dpy->buffer = Xmalloc(_conn_buf_size)) == NULL) {
+		OutOfMemory (dpy, setup);
+		return(NULL);
+	}
+	dpy->bufmax = dpy->buffer + _conn_buf_size;
+#else
 #ifndef XLIBDEFAULTBUFSIZE
 #define XLIBDEFAULTBUFSIZE 16384 /* 16k */
 #endif
@@ -302,6 +355,7 @@ XOpenDisplay (
          return(NULL);
     }
     dpy->bufmax = dpy->buffer + conn_buf_size;
+#endif /* SUNSOFT BUFFERSIZE */
 #if USE_XCB
     dpy->xcb->real_bufmax = dpy->bufmax;
     dpy->bufmax = dpy->buffer;
@@ -776,6 +830,24 @@ XOpenDisplay (
 	}
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+    /*
+       B U G : 4188179
+
+       If client is using shared memory transportation,
+       communication buffer need not be freed upon
+       closing of connection.
+
+       A non-null smeBuffer field in the display structure
+       indicates sme buffer being used.
+     */
+        if (sme_conn)
+           InitializeSmeConn(dpy, idisplay);
+        else
+           dpy->smeBuffer = NULL ;
+
+#endif /* SME */
+
 /*
  * and return successfully
  */
@@ -899,8 +971,28 @@ void _XFreeDisplayStructure(Display *dpy
 	if (dpy->vendor)
 	   Xfree (dpy->vendor);
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	_conn_ref_cnt--;
+	if (!_conn_ref_cnt && _conn_aligned_buf.buf) {
+	   Xfree (_conn_aligned_buf.buf);
+	   _conn_buf_size = 0;
+	}
+#endif /* SUNSOFT */
+
+    /*
+       B U G : 4188179
+
+       Do not free communication buffer if using shared
+       memory extension.
+
+     */
+#ifdef SUNSOFT /* XSUNTRANSPORT */
+    if ( (dpy->smeBuffer == NULL) && (dpy->buffer) )
+	   Xfree (dpy->buffer);
+#else
         if (dpy->buffer)
 	   Xfree (dpy->buffer);
+#endif
 	if (dpy->keysyms)
 	   Xfree ((char *) dpy->keysyms);
 	if (dpy->xdefaults)
@@ -1063,3 +1155,160 @@ static void OutOfMemory(Display *dpy, ch
     if (setup) Xfree (setup);
 #endif /* !USE_XCB */
 }
+
+#ifdef SUNSOFT
+/*
+ * Initialize the shm conn.  Do it through the normal X11 extension
+ * protocol, except that it is done invisibly as far as user of libX11 is
+ * concerned.
+ */
+static void
+InitializeSmeConn(Display *dpy, int dpynum)
+{
+	smeRegion *region;
+	XExtCodes *extCodes;
+	xSMEReq *req;
+	xSmeConnInitReply smeReply;
+	xSmeConnInitReply *reply = &smeReply;
+	char *xsunsmesize;
+	char buf[80];
+	int fd;
+
+#define X_SME extCodes->major_opcode
+
+/*
+ * Check if server is configured with this extension.
+ */
+	if (!(extCodes = XInitExtension(dpy, SMENAME)))
+	    return;
+
+/*
+ * Initialize extension in server for this client.
+ */
+	LockDisplay(dpy);
+	GetReq(SME, req);
+	/*
+	 * Xsun manpage (man/man1/Xsun.1) says that default XSUNSMESIZE
+	 * should be 64K.
+	 */
+	if ((xsunsmesize = getenv("XSUNSMESIZE")) != NULL)
+	    req->xsunsmesize = 1024 * atoi(xsunsmesize);
+       else
+	    req->xsunsmesize = 1024 * 64;
+
+	if (req->xsunsmesize < _conn_buf_size)
+	{
+	    req->xsunsmesize = _conn_buf_size;
+	}
+	/*
+	 * Make sure heap size is multiple of _conn_buf_size.
+	 */
+	if (req->xsunsmesize % _conn_buf_size != 0)
+	{
+            int chunks;
+
+            chunks = req->xsunsmesize/_conn_buf_size;
+            if (chunks <= 0)
+            {
+                chunks = 1;
+            }
+            req->xsunsmesize = chunks * _conn_buf_size;
+	}
+
+        /*
+         * If the client requested a buffer chunk size that would cause us to
+         * run out of FIFO queue slots, cap it at the maximum.
+         */
+        if ((req->xsunsmesize/_conn_buf_size) > SMECONNQSIZE) {
+                req->xsunsmesize = _conn_buf_size * SMECONNQSIZE;
+        }
+
+	/*
+	 * Add in smeRegion overhead to get total buffer size.
+	 */
+	req->xsunsmesize += sizeof(smeRegion);
+
+	req->subReqType = INIT_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+		 reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	snprintf(buf, sizeof(buf), "%s:%i.%i", SMEFILE, dpynum,
+	  reply->client_index);
+	fd = open(buf, O_RDWR, 0666) ;
+
+	region = (smeRegion *)mmap((caddr_t)0, req->xsunsmesize,
+		PROT_READ|PROT_WRITE, MAP_SHARED, fd, (off_t)0) ;
+	if (region == MAP_FAILED)
+    	{
+    		close(fd) ;
+    		unlink(buf) ;
+#ifdef DEBUG
+    perror("Trying to mmap sme conn region");
+#endif /* DEBUG */
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeSize = req->xsunsmesize ;
+	close(fd) ;
+	unlink(buf) ;
+
+/*
+ * Validate that the server is using the new version of smeconn.
+ * It fills in the first half and checks that we fill in the rest.
+ */
+	if (region->smeMagic != (SME_MAGIC4 & 0xffff0000))
+    	{
+    		UnlockDisplay (dpy);
+    		dpy->smeBuffer = NULL ;
+    		return;
+    	}
+
+    	region->smeMagic = SME_MAGIC4;  /* Fill in whole field */
+
+
+        /*
+         * It would be better to pass the buffer allocation unit to the
+         * the server through the initial request, but that would alter
+         * the size of the request structure.
+         */
+        region->smeBufferSize = _conn_buf_size;
+
+/*
+ * Start up sme conn.  Reply synchronizes both server and application
+ * as they switch over to sme request conn.  Content means nothing.
+ */
+	GetReq(SME, req);
+	req->subReqType = START_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+    		reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeBuffer = (char *)region;
+	Xfree(dpy->buffer);
+	dpy->buffer = dpy->bufptr = dpy->bufmax = NULL;
+	_XSmeAllocateHeapBuffer (dpy, region);
+	dpy->bufptr = dpy->buffer;
+
+	UnlockDisplay(dpy);
+
+#undef X_SmeConn
+}
+#endif /* SME */
+
diff -urp -x '*~' -x '*.orig' src/Xintconn.h src/Xintconn.h
--- src/Xintconn.h	2008-10-07 10:18:19.000000000 -0700
+++ src/Xintconn.h	2009-04-08 00:18:46.530793000 -0700
@@ -18,7 +18,12 @@ int _XConnectDisplay (
     char **auth_namep,          /* RETURN */
     int *auth_namelenp,         /* RETURN */
     char **auth_datap,          /* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,         /* RETURN */
+    int *sme_conn);             /* RETURN */
+#else
     int *auth_datalenp);        /* RETURN */
+#endif /* SME */
 extern int _XDisconnectDisplay(XtransConnInfo trans_conn);
 extern Bool _XSendClientPrefix(Display *dpy, xConnClientPrefix *client,
 				char *auth_proto, char *auth_string,
@@ -27,7 +32,11 @@ extern XtransConnInfo _X11TransConnectDi
 				char **fullnamep, int *dpynump,
 				int *screenp, char **auth_namep,
 				int *auth_namelenp, char **auth_datap,
+#ifdef SUNSOFT /* SME */
+				int *auth_datalenp, int *sme_conn);
+#else
 				int *auth_datalenp);
+#endif /* SME */
 #endif /* !USE_XCB */
 
 /* OpenDis.c */
diff -urp -x '*~' -x '*.orig' src/XlibInt.c src/XlibInt.c
--- src/XlibInt.c	2009-04-06 16:49:19.000000000 -0700
+++ src/XlibInt.c	2009-04-08 00:18:46.532476000 -0700
@@ -54,6 +54,13 @@ from The Open Group.
 #include <direct.h>
 #endif
 
+#ifdef SUNSOFT
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <X11/extensions/sme.h>
+#endif /* SME */
+
 #ifdef XTHREADS
 #include "locking.h"
 
@@ -186,10 +193,27 @@ xthread_t (*_Xthread_self_fn)(void) = NU
 
 #endif /* MUSTCOPY */
 
+#ifdef SUNSOFT
+extern int _conn_buf_size;
+
+void _XSmeAllocateHeapBuffer(
+#if NeedFunctionPrototypes
+    Display *dpy,
+    smeRegion *smeBp
+#endif
+);
+
+void _XSmeCheckForFull();
+#endif /* SME */
+
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+extern _XAlignedBuffer _conn_aligned_buf;
+#else
 typedef union {
     xReply rep;
     char buf[BUFSIZE];
 } _XAlignedBuffer;
+#endif /* SUNSOFT */
 
 static char *_XAsyncReply(
     Display *dpy,
@@ -222,6 +246,140 @@ static xReq _dummy_request = {
 	0, 0, 0
 };
 
+#ifdef SUNSOFT
+
+static
+void
+smeIncHead(smeRegion *smeBp)
+{
+	smeBp->smeHeadptr =
+            (smeBp->smeHeadptr+smeBp->smeBufferSize)%smeBp->smeHeapSize;
+}
+
+#define smePokeServer(dpy, c) { \
+        char byte = (char)c ; \
+        for (;;) { \
+            int result = 0 ; \
+            result = _X11TransWrite (dpy->trans_conn, &byte, 1); \
+            if (result == 1) { \
+                break; \
+            } else if (result == 0) { \
+                continue; \
+            } else if (result < 0 && ETEST()) { \
+                continue; \
+            } else if ((result < 0) && !ECHECK(EINTR)) { \
+                    /* Write failed! */ \
+                    /* errno set by write system call. */ \
+                    _XIOError(dpy); \
+                    break; \
+            } \
+        } \
+}
+
+/*
+ * Wait for the server to open up enough buffer space for us to
+ * continue writing. Since the inbound connection is shared with client
+ * traffic a condition variable is used to block until the Xserver
+ * has freed some buffer space.
+ */
+static void
+SmeWaitForServer(Display *dpy, smeRegion *smeBp)
+{
+        char *save_bufptr = dpy->bufptr;
+
+        dpy->bufptr = dpy->buffer;
+
+
+        /*
+         * Let the Xserver know we are waiting for buffer space.
+         */
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+        smeBp->smeClientBufferBlocked = 1;
+
+        /*
+         * Don't hold the mutex over the poke since it might
+         * cause the Xserver to run and not acquire the mutex the
+         * first time round.
+         */
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+        /*
+         * The 'W' is for debugging when looking at truss output from
+         * an X client. The Xserver doesn't care what the byte contains.
+         */
+        smePokeServer (dpy, 'W');
+
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+
+	while (smeBp->smeClientBufferBlocked != 0) {
+		timestruc_t ts;
+		int err;
+
+                /*
+                 * Can't block indefinitly on the condition variable
+                 * since the Xserver might have terminated.
+                 */
+		ts.tv_sec = 1;
+		ts.tv_nsec = 0;
+
+		err = cond_reltimedwait(&smeBp->smeBufferCV,
+                                        &smeBp->smeBufferMutex,
+                                        &ts);
+		if (err == 0) {
+			/*
+			 * We have been signaled by the server,
+			 * see if smeClientBufferBlocked has been cleared.
+			 */
+			continue;
+		} else if (err == ETIME) {
+			/*
+			 * We timed out, see if we still have a valid
+			 * connect to the server.
+			 */
+			struct pollfd pfd;
+
+    			pfd.fd = dpy->fd;
+                	pfd.events = POLLIN;
+                	pfd.revents = 0;
+
+			err = poll(&pfd, 1, 0);
+
+			if (err == 0) {
+				continue;
+			} else if (err == 1 && pfd.revents & POLLHUP) {
+				break;
+			} else if (err < 0) {
+				break;
+			}
+		}
+        }
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+	dpy->bufptr = save_bufptr;
+}
+
+/*
+ * smeConnQueueIn() adds the current buffer to the FIFO queue of
+ * sme buffers.
+ */
+void smeConnQueueIn(dpy, smeBp, bufptr, msgsize, bufsize)
+    Display     *dpy;
+    smeRegion   *smeBp;
+    char        *bufptr;
+    int         msgsize;
+    int         bufsize;
+{
+    int index;
+
+    index = (uint)(smeBp->smeIn+1) % SMECONNQSIZE;
+    smeBp->smeQueue[index].bufp = bufptr - (char *)(smeBp+1);
+    smeBp->smeQueue[index].msgSize = msgsize;
+
+    smeBp->smeIn++; /* increment after bufp & msgSize updated */
+}
+
+#endif /* SME */
+
 /*
  * This is an OS dependent routine which:
  * 1) returns as soon as the connection can be written on....
@@ -307,9 +465,11 @@ _XWaitForWritable(
 #endif
 	    )
 	{
+#ifndef SUNSOFT /* XSUNBUFFERSIZE */
 	    _XAlignedBuffer buf;
+#endif
 	    BytesReadable_t pend;
-	    register int len;
+	    BytesReadable_t len;
 	    register xReply *rep;
 
 	    /* find out how much data can be read */
@@ -332,9 +492,15 @@ _XWaitForWritable(
 	    /* round down to an integral number of XReps */
 	    len = (len / SIZEOF(xReply)) * SIZEOF(xReply);
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	    (void) _XRead (dpy, _conn_aligned_buf.buf, (long) len);
+
+	    STARTITERATE(rep,xReply,_conn_aligned_buf.buf,len > 0) {
+#else
 	    (void) _XRead (dpy, buf.buf, (long) len);
 
 	    STARTITERATE(rep,xReply,buf.buf,len > 0) {
+#endif
 		if (rep->generic.type == X_Reply) {
                     int tmp = len;
 		    RESETITERPTR(rep,xReply,
@@ -653,6 +819,25 @@ static void _XFlushInt(
 	register char *bufindex;
 	_XExtension *ext;
 
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
+
+                size = (long)(dpy->bufptr - dpy->buffer);
+                if (!size) return;
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,size,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+               /*
+                * The 'D' is for debugging when looking at truss output from
+                * an X client. The Xserver doesn't care what the byte contains.
+                */
+                smePokeServer (dpy, 'D');
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+                dpy->bufptr = dpy->buffer;
+        }
+        else {
+#endif /* SME */
+
 	/* This fix resets the bufptr to the front of the buffer so
 	 * additional appends to the bufptr will not corrupt memory. Since
 	 * the server is down, these appends are no-op's anyway but
@@ -674,7 +859,7 @@ static void _XFlushInt(
 	    }
 	}
 #endif
-	size = todo = dpy->bufptr - dpy->buffer;
+	size = todo = (long)(dpy->bufptr - dpy->buffer);
 	if (!size) return;
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
@@ -735,6 +920,11 @@ static void _XFlushInt(
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+
+#ifdef SUNSOFT
+    }
+#endif /* SME */
+	return;
 }
 
 int
@@ -742,9 +932,11 @@ _XEventsQueued(
     register Display *dpy,
     int mode)
 {
-	register int len;
+	BytesReadable_t len;
 	BytesReadable_t pend;
+#ifndef SUNSOFT /* XSUNBUFFERSIZE */
 	_XAlignedBuffer buf;
+#endif
 	register xReply *rep;
 	char *read_buf;
 #ifdef XTHREADS
@@ -865,8 +1057,11 @@ _XEventsQueued(
 	} else
 #endif /* XTHREADS*/
 	{
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	    read_buf = _conn_aligned_buf.buf;
+#else
 	    read_buf = buf.buf;
-
+#endif	/* SUNSOFT */
 	    if (len < SIZEOF(xReply)
 #ifdef XTHREADS
 		|| dpy->async_handlers
@@ -898,12 +1093,21 @@ _XEventsQueued(
 		    UnlockNextEventReader(dpy);
 		}
 		return(dpy->qlen); /* we read, so we can return */
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	    } else if (read_buf != _conn_aligned_buf.buf)
+		memcpy(_conn_aligned_buf.buf, read_buf, len);
+#else
 	    } else if (read_buf != buf.buf)
 		memcpy(buf.buf, read_buf, len);
+#endif /* SUNSOFT */
 	}
 #endif /* XTHREADS*/
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	STARTITERATE(rep,xReply,_conn_aligned_buf.buf,len > 0) {
+#else
 	STARTITERATE(rep,xReply,buf.buf,len > 0) {
+#endif
 	    if (rep->generic.type == X_Reply) {
                 int tmp = len;
 		RESETITERPTR(rep,xReply,
@@ -936,9 +1140,11 @@ _XEventsQueued(
 void _XReadEvents(
 	register Display *dpy)
 {
+#ifndef SUNSOFT /* XSUNBUFFERSIZE */
 	_XAlignedBuffer buf;
+#endif
 	BytesReadable_t pend;
-	int len;
+	BytesReadable_t len;
 	register xReply *rep;
 	Bool not_yet_flushed = True;
 	char *read_buf;
@@ -1013,7 +1219,11 @@ void _XReadEvents(
 	    } else
 #endif /* XTHREADS*/
 	    {
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+		read_buf = _conn_aligned_buf.buf;
+#else
 		read_buf = buf.buf;
+#endif
 
 		/* but we won't read more than the max buffer size */
 		if (len > BUFSIZE)
@@ -1063,12 +1273,21 @@ void _XReadEvents(
 			       read_buf, len);
 		    ConditionSignal(dpy, dpy->lock->reply_awaiters->cv);
 		    continue;
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+		} else if (read_buf != _conn_aligned_buf.buf)
+		    memcpy(_conn_aligned_buf.buf, read_buf, len);
+#else
 		} else if (read_buf != buf.buf)
 		    memcpy(buf.buf, read_buf, len);
+#endif
 	    }
 #endif /* XTHREADS */
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+	    STARTITERATE(rep,xReply,_conn_aligned_buf.buf,len > 0) {
+#else
 	    STARTITERATE(rep,xReply,buf.buf,len > 0) {
+#endif
 		if (rep->generic.type == X_Reply) {
 		    RESETITERPTR(rep,xReply,
 				 _XAsyncReply (dpy, rep,
@@ -1400,8 +1619,84 @@ _XSend (
 	long skip, dbufsize, padsize, total, todo;
 	_XExtension *ext;
 
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
+
+                dbufsize = dpy->bufptr-dpy->buffer;
+
+                padsize = -size & 3;
+
+                total =  dbufsize + size + padsize;
+
+                /*
+                 * If request won't fit in a single sme buffer, break it up
+                 * into smaller requests.
+                 */
+                if (total > (long)(_conn_buf_size))
+                {
+                        long bytesCopied = 0 ;
+                        long numToCopy = 0 ;
+                        long chunk = _conn_buf_size & 0xffffffc ;
+
+                        while (bytesCopied < size)
+                        {
+                                /*
+                                 * Compensate for buffer contents.
+                                 */
+                                if (dbufsize) {
+                                        numToCopy = chunk - dbufsize;
+                                        numToCopy = min(numToCopy, size);
+                                        numToCopy &= 0xffffffc;
+                                        dbufsize = 0;
+                                } else if (size - bytesCopied >= chunk) {
+                                        numToCopy = chunk;
+                                } else {
+                                        numToCopy = size - bytesCopied ;
+                                }
+                                _XSend(dpy, data + bytesCopied, numToCopy) ;
+                                bytesCopied += numToCopy ;
+                        }
+                        return;
+                }
+                else {
+
+                /*
+                 * Copy data into sme buffer.
+                 */
+
+                if (size) {
+                    memcpy (dpy->bufptr, data, size);
+                }
+
+                /* Pad the buffer with zeros. */
+                if (padsize)
+                {
+                   char *p = (char *)dpy->bufptr + size;
+                   int i;
+                   for (i = 0; i < padsize; i++)
+                      *p++ = '\0';
+                }
+
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,total,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+                smePokeServer (dpy, 'D');
+
+                /* Allocate a new buffer */
+                dpy->buffer = dpy->bufmax;
+
+                /* Get a new buffer */
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+
+                /* Reset pointer to beginning of new sme buffer. */
+                dpy->bufptr = dpy->buffer;
+        	}
+        }
+        else {
+#endif /* SME */
+
 	if (!size || (dpy->flags & XlibDisplayIOError)) return;
-	dbufsize = dpy->bufptr - dpy->buffer;
+	dbufsize = (long)(dpy->bufptr - dpy->buffer);
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
 	/* make sure no one else can put in data */
@@ -1505,9 +1800,66 @@ _XSend (
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+#ifdef SUNSOFT
+	}
+#endif /* SME */
 	return;
 }
 
+#ifdef SUNSOFT
+
+
+/*
+ * Allocate a buffer in the shared memory region using a stack heap.
+ * Note: this routine starts the allocation at the value of dpy->buffer
+ */
+
+void
+_XSmeAllocateHeapBuffer(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+        for (;;) {
+
+           /*
+            * Determine if the circular list is full or has space.
+            */
+            if ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+                (smeBp->smeIn != smeBp->smeOut)) {
+                /*
+                 * Full, wait for space.
+                 */
+                SmeWaitForServer(dpy, smeBp);
+                continue;
+            } else {
+                /*
+                 * Take the next buffer chunk.
+                 */
+                dpy->buffer = smeBp->smeHeadptr + (char *)(smeBp + 1);
+                dpy->bufmax = dpy->buffer + smeBp->smeBufferSize;
+                smeIncHead(smeBp);
+                break;
+           }
+        }
+}
+
+void
+_XSmeCheckForFull(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+
+    while ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+           (smeBp->smeIn != smeBp->smeOut)) {
+        /*
+         * Full, wait for space.
+         */
+         SmeWaitForServer(dpy, smeBp);
+    }
+}
+
+#endif /* SME */
+
 static void
 _XGetMiscCode(
     register Display *dpy)
