###############################################################################
# Copyright (c) 2008, 2009, Oracle and/or its affiliates. All rights reserved.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice (including the next
# paragraph) shall be included in all copies or substantial portions of the
# Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
#
diff -urp -x '*~' -x '*.orig' include/X11/Xlibint.h include/X11/Xlibint.h
--- include/X11/Xlibint.h	2010-06-07 15:49:19.999603302 -0700
+++ include/X11/Xlibint.h	2010-06-07 15:49:20.803676676 -0700
@@ -197,6 +197,10 @@ struct _XDisplay
 		XGenericEventCookie *	/* in */,
 		XGenericEventCookie *   /* out*/);
 	void *cookiejar;  /* cookie events returned but not claimed */
+#ifdef SUNSOFT
+	char *smeBuffer;	/* Address of sme region */
+	int smeSize;		/* size of sme region */
+#endif /* SME */
 };
 
 #if defined(XTHREADS) && defined(SUNSOFT)
diff -urp -x '*~' -x '*.orig' src/ConnDis.c src/ConnDis.c
--- src/ConnDis.c	2010-06-03 12:45:32.000000000 -0700
+++ src/ConnDis.c	2010-06-07 15:49:20.804309938 -0700
@@ -136,7 +136,12 @@ _X11TransConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
     int family;
     int saddrlen;
@@ -163,6 +168,9 @@ _X11TransConnectDisplay (
     int local_transport_index = -1;
     const char *local_transport[] = { LOCAL_TRANSPORT_LIST, NULL };
 #endif
+#ifdef SUNSOFT
+    char *xsuntransport = NULL;
+#endif /* SME */
 
     p = display_name;
 
@@ -272,6 +280,13 @@ _X11TransConnectDisplay (
 	}
     }
 
+#ifdef SUNSOFT
+    if ((xsuntransport = getenv("XSUNTRANSPORT")) != NULL) {
+        if (!phostname && (strncmp("shmem", xsuntransport,  5) == 0))
+            *sme_conn = 1;
+    }
+#endif /* SME */
+
     /*
      * At this point, we know the following information:
      *
@@ -504,13 +519,23 @@ int _XConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
    XtransConnInfo trans_conn;
 
    trans_conn = _X11TransConnectDisplay (
 		      display_name, fullnamep, dpynump, screenp,
+#ifdef SUNSOFT /* SME */
+		      auth_namep, auth_namelenp, auth_datap, auth_datalenp,
+		      sme_conn);
+#else
 		      auth_namep, auth_namelenp, auth_datap, auth_datalenp);
+#endif /* SME */
 
    if (trans_conn)
    {
diff -urp -x '*~' -x '*.orig' src/OpenDis.c src/OpenDis.c
--- src/OpenDis.c	2010-06-07 15:49:20.020725240 -0700
+++ src/OpenDis.c	2010-06-07 15:49:20.805475576 -0700
@@ -50,6 +50,11 @@ in this Software without prior written a
 #include <X11/extensions/XInteractive.h>
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+#include <X11/extensions/sme.h>
+#include <sys/mman.h>
+#endif /* SME */
+
 #if !USE_XCB
 #ifdef X_NOT_POSIX
 #define Size_t unsigned int
@@ -65,6 +70,13 @@ typedef struct {
 } _XBigReqState;
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+void _XSmeAllocateHeapBuffer(
+    Display *dpy,
+    smeRegion *smeBp
+);
+#endif /* SME */
+
 #if defined(XTHREADS) && defined(SUNSOFT)
 DisplayPtrLink *HeadDisplay=NULL;
 DisplayPtrLink *LastDisplay=NULL;
@@ -82,6 +94,10 @@ void (*_XFreeDisplayLock_fn)(Display *dp
 #define FreeDisplayLock(dis)
 #endif /* XTHREADS */
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+int _conn_buf_size = 0;
+#endif /* SUNSOFT */
+
 static xReq _dummy_request = {
 	0, 0, 0
 };
@@ -92,6 +108,10 @@ static Bool _XBigReqHandler(Display *dpy
 				XPointer data);
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+static void InitializeSmeConn(Display *dpy, int dpynum);
+#endif /* SME */
+
 /*
  * Connects to a server, creates a Display object and returns a pointer to
  * the newly created Display back to the caller.
@@ -129,6 +149,10 @@ XOpenDisplay (
 	long setuplength;	/* number of bytes in setup message */
 	long usedbytes = 0;     /* number of bytes we have processed */
 	unsigned long mask;
+#ifdef SUNSOFT
+        int sme_conn = 0;
+#endif /* SME */
+
 	long int conn_buf_size;
 	char *xlib_buffer_size;
 
@@ -202,7 +226,11 @@ fallback_success:
 					 display_name, &fullname, &idisplay,
 					 &iscreen, &conn_auth_name,
 					 &conn_auth_namelen, &conn_auth_data,
-					 &conn_auth_datalen)) == NULL) {
+					 &conn_auth_datalen
+#ifdef SUNSOFT
+                                        , &sme_conn
+#endif /* SME */
+		)) == NULL) {
 		Xfree ((char *) dpy);
 		return(NULL);
 	}
@@ -800,6 +828,26 @@ fallback_success:
 	}
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+    /*
+       B U G : 4188179
+
+       If client is using shared memory transportation,
+       communication buffer need not be freed upon
+       closing of connection.
+
+       A non-null smeBuffer field in the display structure
+       indicates sme buffer being used.
+     */
+        _conn_buf_size = conn_buf_size;
+
+        if (sme_conn)
+           InitializeSmeConn(dpy, idisplay);
+        else
+           dpy->smeBuffer = NULL ;
+
+#endif /* SME */
+
 /*
  * and return successfully
  */
@@ -934,8 +982,20 @@ void _XFreeDisplayStructure(Display *dpy
 	if (dpy->vendor)
 	   Xfree (dpy->vendor);
 
+    /*
+       B U G : 4188179
+
+       Do not free communication buffer if using shared
+       memory extension.
+
+     */
+#ifdef SUNSOFT /* XSUNTRANSPORT */
+    if ( (dpy->smeBuffer == NULL) && (dpy->buffer) )
+	   Xfree (dpy->buffer);
+#else
         if (dpy->buffer)
 	   Xfree (dpy->buffer);
+#endif
 	if (dpy->keysyms)
 	   Xfree ((char *) dpy->keysyms);
 	if (dpy->xdefaults)
@@ -1098,3 +1158,160 @@ static void OutOfMemory(Display *dpy, ch
     if (setup) Xfree (setup);
 #endif /* !USE_XCB */
 }
+
+#ifdef SUNSOFT
+/*
+ * Initialize the shm conn.  Do it through the normal X11 extension
+ * protocol, except that it is done invisibly as far as user of libX11 is
+ * concerned.
+ */
+static void
+InitializeSmeConn(Display *dpy, int dpynum)
+{
+	smeRegion *region;
+	XExtCodes *extCodes;
+	xSMEReq *req;
+	xSmeConnInitReply smeReply;
+	xSmeConnInitReply *reply = &smeReply;
+	char *xsunsmesize;
+	char buf[80];
+	int fd;
+
+#define X_SME extCodes->major_opcode
+
+/*
+ * Check if server is configured with this extension.
+ */
+	if (!(extCodes = XInitExtension(dpy, SMENAME)))
+	    return;
+
+/*
+ * Initialize extension in server for this client.
+ */
+	LockDisplay(dpy);
+	GetReq(SME, req);
+	/*
+	 * Xsun manpage (man/man1/Xsun.1) says that default XSUNSMESIZE
+	 * should be 64K.
+	 */
+	if ((xsunsmesize = getenv("XSUNSMESIZE")) != NULL)
+	    req->xsunsmesize = 1024 * atoi(xsunsmesize);
+       else
+	    req->xsunsmesize = 1024 * 64;
+
+	if (req->xsunsmesize < _conn_buf_size)
+	{
+	    req->xsunsmesize = _conn_buf_size;
+	}
+	/*
+	 * Make sure heap size is multiple of conn_buf_size.
+	 */
+	if (req->xsunsmesize % _conn_buf_size != 0)
+	{
+            int chunks;
+
+            chunks = req->xsunsmesize/_conn_buf_size;
+            if (chunks <= 0)
+            {
+                chunks = 1;
+            }
+            req->xsunsmesize = chunks * _conn_buf_size;
+	}
+
+        /*
+         * If the client requested a buffer chunk size that would cause us to
+         * run out of FIFO queue slots, cap it at the maximum.
+         */
+        if ((req->xsunsmesize/_conn_buf_size) > SMECONNQSIZE) {
+                req->xsunsmesize = _conn_buf_size * SMECONNQSIZE;
+        }
+
+	/*
+	 * Add in smeRegion overhead to get total buffer size.
+	 */
+	req->xsunsmesize += sizeof(smeRegion);
+
+	req->subReqType = INIT_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+		 reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	snprintf(buf, sizeof(buf), "%s:%i.%i", SMEFILE, dpynum,
+	  reply->client_index);
+	fd = open(buf, O_RDWR, 0666) ;
+
+	region = (smeRegion *)mmap((caddr_t)0, req->xsunsmesize,
+		PROT_READ|PROT_WRITE, MAP_SHARED, fd, (off_t)0) ;
+	if (region == MAP_FAILED)
+    	{
+    		close(fd) ;
+    		unlink(buf) ;
+#ifdef DEBUG
+    perror("Trying to mmap sme conn region");
+#endif /* DEBUG */
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeSize = req->xsunsmesize ;
+	close(fd) ;
+	unlink(buf) ;
+
+/*
+ * Validate that the server is using the new version of smeconn.
+ * It fills in the first half and checks that we fill in the rest.
+ */
+	if (region->smeMagic != (SME_MAGIC4 & 0xffff0000))
+    	{
+    		UnlockDisplay (dpy);
+    		dpy->smeBuffer = NULL ;
+    		return;
+    	}
+
+    	region->smeMagic = SME_MAGIC4;  /* Fill in whole field */
+
+
+        /*
+         * It would be better to pass the buffer allocation unit to the
+         * the server through the initial request, but that would alter
+         * the size of the request structure.
+         */
+        region->smeBufferSize = _conn_buf_size;
+
+/*
+ * Start up sme conn.  Reply synchronizes both server and application
+ * as they switch over to sme request conn.  Content means nothing.
+ */
+	GetReq(SME, req);
+	req->subReqType = START_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+    		reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeBuffer = (char *)region;
+	Xfree(dpy->buffer);
+	dpy->buffer = dpy->bufptr = dpy->bufmax = NULL;
+	_XSmeAllocateHeapBuffer (dpy, region);
+	dpy->bufptr = dpy->buffer;
+
+	UnlockDisplay(dpy);
+
+#undef X_SmeConn
+}
+#endif /* SME */
+
diff -urp -x '*~' -x '*.orig' src/Xintconn.h src/Xintconn.h
--- src/Xintconn.h	2010-01-14 17:11:36.000000000 -0800
+++ src/Xintconn.h	2010-06-07 15:49:20.804631804 -0700
@@ -17,7 +17,12 @@ int _XConnectDisplay (
     char **auth_namep,          /* RETURN */
     int *auth_namelenp,         /* RETURN */
     char **auth_datap,          /* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,         /* RETURN */
+    int *sme_conn);             /* RETURN */
+#else
     int *auth_datalenp);        /* RETURN */
+#endif /* SME */
 extern int _XDisconnectDisplay(XtransConnInfo trans_conn);
 extern Bool _XSendClientPrefix(Display *dpy, xConnClientPrefix *client,
 				char *auth_proto, char *auth_string,
@@ -26,7 +31,11 @@ extern XtransConnInfo _X11TransConnectDi
 				char **fullnamep, int *dpynump,
 				int *screenp, char **auth_namep,
 				int *auth_namelenp, char **auth_datap,
+#ifdef SUNSOFT /* SME */
+				int *auth_datalenp, int *sme_conn);
+#else
 				int *auth_datalenp);
+#endif /* SME */
 #endif /* !USE_XCB */
 
 /* OpenDis.c */
diff -urp -x '*~' -x '*.orig' src/XlibInt.c src/XlibInt.c
--- src/XlibInt.c	2010-06-07 15:49:20.026209260 -0700
+++ src/XlibInt.c	2010-06-07 15:49:20.806893011 -0700
@@ -52,8 +52,15 @@ from The Open Group.
 #include <direct.h>
 #endif
 
+#ifdef SUNSOFT
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <X11/extensions/sme.h>
+#endif /* SME */
+
 /* Xtransint.h is needed for access to an xtrans internal structure.
- * See the comments in _XFlush for information. This is required for
+ * See the comments in _XFlush for information.  This is required for
  * compatibility between X11R6-xtrans and gnuemacs v18.58.
  */
 #include <X11/Xtrans/Xtransint.h>
@@ -181,6 +188,19 @@ xthread_t (*_Xthread_self_fn)(void) = NU
 
 #endif /* MUSTCOPY */
 
+#ifdef SUNSOFT
+extern int _conn_buf_size;
+
+void _XSmeAllocateHeapBuffer(
+#if NeedFunctionPrototypes
+    Display *dpy,
+    smeRegion *smeBp
+#endif
+);
+
+void _XSmeCheckForFull();
+#endif /* SME */
+
 typedef union {
     xReply rep;
     char buf[BUFSIZE];
@@ -217,6 +237,140 @@ static xReq _dummy_request = {
 	0, 0, 0
 };
 
+#ifdef SUNSOFT
+
+static
+void
+smeIncHead(smeRegion *smeBp)
+{
+	smeBp->smeHeadptr =
+            (smeBp->smeHeadptr+smeBp->smeBufferSize)%smeBp->smeHeapSize;
+}
+
+#define smePokeServer(dpy, c) { \
+        char byte = (char)c ; \
+        for (;;) { \
+            int result = 0 ; \
+            result = _X11TransWrite (dpy->trans_conn, &byte, 1); \
+            if (result == 1) { \
+                break; \
+            } else if (result == 0) { \
+                continue; \
+            } else if (result < 0 && ETEST()) { \
+                continue; \
+            } else if ((result < 0) && !ECHECK(EINTR)) { \
+                    /* Write failed! */ \
+                    /* errno set by write system call. */ \
+                    _XIOError(dpy); \
+                    break; \
+            } \
+        } \
+}
+
+/*
+ * Wait for the server to open up enough buffer space for us to
+ * continue writing. Since the inbound connection is shared with client
+ * traffic a condition variable is used to block until the Xserver
+ * has freed some buffer space.
+ */
+static void
+SmeWaitForServer(Display *dpy, smeRegion *smeBp)
+{
+        char *save_bufptr = dpy->bufptr;
+
+        dpy->bufptr = dpy->buffer;
+
+
+        /*
+         * Let the Xserver know we are waiting for buffer space.
+         */
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+        smeBp->smeClientBufferBlocked = 1;
+
+        /*
+         * Don't hold the mutex over the poke since it might
+         * cause the Xserver to run and not acquire the mutex the
+         * first time round.
+         */
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+        /*
+         * The 'W' is for debugging when looking at truss output from
+         * an X client. The Xserver doesn't care what the byte contains.
+         */
+        smePokeServer (dpy, 'W');
+
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+
+	while (smeBp->smeClientBufferBlocked != 0) {
+		timestruc_t ts;
+		int err;
+
+                /*
+                 * Can't block indefinitly on the condition variable
+                 * since the Xserver might have terminated.
+                 */
+		ts.tv_sec = 1;
+		ts.tv_nsec = 0;
+
+		err = cond_reltimedwait(&smeBp->smeBufferCV,
+                                        &smeBp->smeBufferMutex,
+                                        &ts);
+		if (err == 0) {
+			/*
+			 * We have been signaled by the server,
+			 * see if smeClientBufferBlocked has been cleared.
+			 */
+			continue;
+		} else if (err == ETIME) {
+			/*
+			 * We timed out, see if we still have a valid
+			 * connect to the server.
+			 */
+			struct pollfd pfd;
+
+    			pfd.fd = dpy->fd;
+                	pfd.events = POLLIN;
+                	pfd.revents = 0;
+
+			err = poll(&pfd, 1, 0);
+
+			if (err == 0) {
+				continue;
+			} else if (err == 1 && pfd.revents & POLLHUP) {
+				break;
+			} else if (err < 0) {
+				break;
+			}
+		}
+        }
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+	dpy->bufptr = save_bufptr;
+}
+
+/*
+ * smeConnQueueIn() adds the current buffer to the FIFO queue of
+ * sme buffers.
+ */
+void smeConnQueueIn(dpy, smeBp, bufptr, msgsize, bufsize)
+    Display     *dpy;
+    smeRegion   *smeBp;
+    char        *bufptr;
+    int         msgsize;
+    int         bufsize;
+{
+    int index;
+
+    index = (uint)(smeBp->smeIn+1) % SMECONNQSIZE;
+    smeBp->smeQueue[index].bufp = bufptr - (char *)(smeBp+1);
+    smeBp->smeQueue[index].msgSize = msgsize;
+
+    smeBp->smeIn++; /* increment after bufp & msgSize updated */
+}
+
+#endif /* SME */
+
 /*
  * This is an OS dependent routine which:
  * 1) returns as soon as the connection can be written on....
@@ -304,7 +458,7 @@ _XWaitForWritable(
 	{
 	    _XAlignedBuffer buf;
 	    BytesReadable_t pend;
-	    register int len;
+	    BytesReadable_t len;
 	    register xReply *rep;
 
 	    /* find out how much data can be read */
@@ -678,6 +832,24 @@ static void _XFlushInt(
 		dpy->trans_conn->fd = dpy->fd;
 	}
 	/* End gnuemacs v18.58 compatability fix. */
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
+
+                size = (long)(dpy->bufptr - dpy->buffer);
+                if (!size) return;
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,size,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+               /*
+                * The 'D' is for debugging when looking at truss output from
+                * an X client. The Xserver doesn't care what the byte contains.
+                */
+                smePokeServer (dpy, 'D');
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+                dpy->bufptr = dpy->buffer;
+        }
+        else {
+#endif /* SME */
 
 	/* This fix resets the bufptr to the front of the buffer so
 	 * additional appends to the bufptr will not corrupt memory. Since
@@ -700,7 +872,7 @@ static void _XFlushInt(
 	    }
 	}
 #endif
-	size = todo = dpy->bufptr - dpy->buffer;
+	size = todo = (long)(dpy->bufptr - dpy->buffer);
 	if (!size) return;
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
@@ -761,6 +933,11 @@ static void _XFlushInt(
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+
+#ifdef SUNSOFT
+    }
+#endif /* SME */
+	return;
 }
 
 int
@@ -768,7 +945,7 @@ _XEventsQueued(
     register Display *dpy,
     int mode)
 {
-	register int len;
+	BytesReadable_t len;
 	BytesReadable_t pend;
 	_XAlignedBuffer buf;
 	register xReply *rep;
@@ -892,7 +1069,6 @@ _XEventsQueued(
 #endif /* XTHREADS*/
 	{
 	    read_buf = buf.buf;
-
 	    if (len < SIZEOF(xReply)
 #ifdef XTHREADS
 		|| dpy->async_handlers
@@ -964,7 +1140,7 @@ void _XReadEvents(
 {
 	_XAlignedBuffer buf;
 	BytesReadable_t pend;
-	int len;
+	BytesReadable_t len;
 	register xReply *rep;
 	Bool not_yet_flushed = True;
 	char *read_buf;
@@ -1428,8 +1604,84 @@ _XSend (
 	long skip, dbufsize, padsize, total, todo;
 	_XExtension *ext;
 
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
+
+                dbufsize = dpy->bufptr-dpy->buffer;
+
+                padsize = -size & 3;
+
+                total =  dbufsize + size + padsize;
+
+                /*
+                 * If request won't fit in a single sme buffer, break it up
+                 * into smaller requests.
+                 */
+                if (total > (long)(_conn_buf_size))
+                {
+                        long bytesCopied = 0 ;
+                        long numToCopy = 0 ;
+                        long chunk = _conn_buf_size & 0xffffffc ;
+
+                        while (bytesCopied < size)
+                        {
+                                /*
+                                 * Compensate for buffer contents.
+                                 */
+                                if (dbufsize) {
+                                        numToCopy = chunk - dbufsize;
+                                        numToCopy = min(numToCopy, size);
+                                        numToCopy &= 0xffffffc;
+                                        dbufsize = 0;
+                                } else if (size - bytesCopied >= chunk) {
+                                        numToCopy = chunk;
+                                } else {
+                                        numToCopy = size - bytesCopied ;
+                                }
+                                _XSend(dpy, data + bytesCopied, numToCopy) ;
+                                bytesCopied += numToCopy ;
+                        }
+                        return;
+                }
+                else {
+
+                /*
+                 * Copy data into sme buffer.
+                 */
+
+                if (size) {
+                    memcpy (dpy->bufptr, data, size);
+                }
+
+                /* Pad the buffer with zeros. */
+                if (padsize)
+                {
+                   char *p = (char *)dpy->bufptr + size;
+                   int i;
+                   for (i = 0; i < padsize; i++)
+                      *p++ = '\0';
+                }
+
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,total,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+                smePokeServer (dpy, 'D');
+
+                /* Allocate a new buffer */
+                dpy->buffer = dpy->bufmax;
+
+                /* Get a new buffer */
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+
+                /* Reset pointer to beginning of new sme buffer. */
+                dpy->bufptr = dpy->buffer;
+        	}
+        }
+        else {
+#endif /* SME */
+
 	if (!size || (dpy->flags & XlibDisplayIOError)) return;
-	dbufsize = dpy->bufptr - dpy->buffer;
+	dbufsize = (long)(dpy->bufptr - dpy->buffer);
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
 	/* make sure no one else can put in data */
@@ -1533,9 +1785,66 @@ _XSend (
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+#ifdef SUNSOFT
+	}
+#endif /* SME */
 	return;
 }
 
+#ifdef SUNSOFT
+
+
+/*
+ * Allocate a buffer in the shared memory region using a stack heap.
+ * Note: this routine starts the allocation at the value of dpy->buffer
+ */
+
+void
+_XSmeAllocateHeapBuffer(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+        for (;;) {
+
+           /*
+            * Determine if the circular list is full or has space.
+            */
+            if ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+                (smeBp->smeIn != smeBp->smeOut)) {
+                /*
+                 * Full, wait for space.
+                 */
+                SmeWaitForServer(dpy, smeBp);
+                continue;
+            } else {
+                /*
+                 * Take the next buffer chunk.
+                 */
+                dpy->buffer = smeBp->smeHeadptr + (char *)(smeBp + 1);
+                dpy->bufmax = dpy->buffer + smeBp->smeBufferSize;
+                smeIncHead(smeBp);
+                break;
+           }
+        }
+}
+
+void
+_XSmeCheckForFull(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+
+    while ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+           (smeBp->smeIn != smeBp->smeOut)) {
+        /*
+         * Full, wait for space.
+         */
+         SmeWaitForServer(dpy, smeBp);
+    }
+}
+
+#endif /* SME */
+
 static void
 _XGetMiscCode(
     register Display *dpy)
