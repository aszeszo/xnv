###############################################################################
# Copyright 2009 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, provided that the above
# copyright notice(s) and this permission notice appear in all copies of
# the Software and that both the above copyright notice(s) and this
# permission notice appear in supporting documentation.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
# OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
# INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# 
# Except as contained in this notice, the name of a copyright holder
# shall not be used in advertising or otherwise to promote the sale, use
# or other dealings in this Software without prior written authorization
# of the copyright holder.
#
diff -urp -x '*~' -x '*.orig' include/X11/Xlibint.h include/X11/Xlibint.h
--- include/X11/Xlibint.h	2009-04-08 00:18:36.242153000 -0700
+++ include/X11/Xlibint.h	2009-04-08 00:18:46.488588000 -0700
@@ -185,6 +185,10 @@ struct _XDisplay
 		XGenericEventCookie *   /* in */,
 		XGenericEventCookie *   /* out*/);
 	void *cookiejar;  /* cookie events returned but not claimed */
+#ifdef SUNSOFT
+	char *smeBuffer;	/* Address of sme region */
+	int smeSize;		/* size of sme region */
+#endif /* SME */
 };
 
 #if defined(XTHREADS) && defined(SUNSOFT)
diff -urp -x '*~' -x '*.orig' src/ConnDis.c src/ConnDis.c
--- src/ConnDis.c	2008-11-18 22:42:01.000000000 -0800
+++ src/ConnDis.c	2009-04-08 00:18:46.494720000 -0700
@@ -137,7 +137,12 @@ _X11TransConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
     int family;
     int saddrlen;
@@ -164,6 +169,9 @@ _X11TransConnectDisplay (
     int local_transport_index = -1;
     const char *local_transport[] = { LOCAL_TRANSPORT_LIST, NULL };
 #endif
+#ifdef SUNSOFT
+    char *xsuntransport = NULL;
+#endif /* SME */
 
     p = display_name;
 
@@ -273,6 +281,13 @@ _X11TransConnectDisplay (
 	}
     }
 
+#ifdef SUNSOFT
+    if ((xsuntransport = getenv("XSUNTRANSPORT")) != NULL) {
+        if (!phostname && (strncmp("shmem", xsuntransport,  5) == 0))
+            *sme_conn = 1;
+    }
+#endif /* SME */
+
     /*
      * At this point, we know the following information:
      *
@@ -505,13 +520,23 @@ int _XConnectDisplay (
     char **auth_namep,			/* RETURN */
     int *auth_namelenp,			/* RETURN */
     char **auth_datap,			/* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,			/* RETURN */
+    int *sme_conn)                      /* RETURN */
+#else
     int *auth_datalenp)			/* RETURN */
+#endif /* SME */
 {
    XtransConnInfo trans_conn;
 
    trans_conn = _X11TransConnectDisplay (
 		      display_name, fullnamep, dpynump, screenp,
+#ifdef SUNSOFT /* SME */
+		      auth_namep, auth_namelenp, auth_datap, auth_datalenp,
+		      sme_conn);
+#else
 		      auth_namep, auth_namelenp, auth_datap, auth_datalenp);
+#endif /* SME */
 
    if (trans_conn)
    {
diff -urp -x '*~' -x '*.orig' src/Xintconn.h src/Xintconn.h
--- src/Xintconn.h	2008-10-07 10:18:19.000000000 -0700
+++ src/Xintconn.h	2009-04-08 00:18:46.530793000 -0700
@@ -18,7 +18,12 @@ int _XConnectDisplay (
     char **auth_namep,          /* RETURN */
     int *auth_namelenp,         /* RETURN */
     char **auth_datap,          /* RETURN */
+#ifdef SUNSOFT /* SME */
+    int *auth_datalenp,         /* RETURN */
+    int *sme_conn);             /* RETURN */
+#else
     int *auth_datalenp);        /* RETURN */
+#endif /* SME */
 extern int _XDisconnectDisplay(XtransConnInfo trans_conn);
 extern Bool _XSendClientPrefix(Display *dpy, xConnClientPrefix *client,
 				char *auth_proto, char *auth_string,
@@ -27,7 +32,11 @@ extern XtransConnInfo _X11TransConnectDi
 				char **fullnamep, int *dpynump,
 				int *screenp, char **auth_namep,
 				int *auth_namelenp, char **auth_datap,
+#ifdef SUNSOFT /* SME */
+				int *auth_datalenp, int *sme_conn);
+#else
 				int *auth_datalenp);
+#endif /* SME */
 #endif /* !USE_XCB */
 
 /* OpenDis.c */
--- src/OpenDis.c	Fri Oct 16 15:10:13 2009
+++ src/OpenDis.c	Fri Oct 16 15:17:29 2009
@@ -52,6 +52,11 @@
 #include <X11/extensions/XInteractive.h>
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+#include <X11/extensions/sme.h>
+#include <sys/mman.h>
+#endif /* SME */
+
 #if !USE_XCB
 #ifdef X_NOT_POSIX
 #define Size_t unsigned int
@@ -67,6 +72,13 @@
 } _XBigReqState;
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+void _XSmeAllocateHeapBuffer(
+    Display *dpy,
+    smeRegion *smeBp
+);
+#endif /* SME */
+
 #if defined(XTHREADS) && defined(SUNSOFT)
 DisplayPtrLink *HeadDisplay=NULL;
 DisplayPtrLink *LastDisplay=NULL;
@@ -84,6 +96,10 @@
 #define FreeDisplayLock(dis)
 #endif /* XTHREADS */
 
+#ifdef SUNSOFT /* XSUNBUFFERSIZE */
+int _conn_buf_size = 0;
+#endif /* SUNSOFT */
+
 static xReq _dummy_request = {
 	0, 0, 0
 };
@@ -94,6 +110,10 @@
 				XPointer data);
 #endif /* !USE_XCB */
 
+#ifdef SUNSOFT
+static void InitializeSmeConn(Display *dpy, int dpynum);
+#endif /* SME */
+
 /*
  * Connects to a server, creates a Display object and returns a pointer to
  * the newly created Display back to the caller.
@@ -131,6 +151,10 @@
 	long setuplength;	/* number of bytes in setup message */
 	long usedbytes = 0;     /* number of bytes we have processed */
 	unsigned long mask;
+#ifdef SUNSOFT
+        int sme_conn = 0;
+#endif /* SME */
+
        long int conn_buf_size;
        char *xlib_buffer_size;
 
@@ -185,7 +209,11 @@
 					 display_name, &fullname, &idisplay,
 					 &iscreen, &conn_auth_name,
 					 &conn_auth_namelen, &conn_auth_data,
-					 &conn_auth_datalen)) == NULL) {
+					 &conn_auth_datalen
+#ifdef SUNSOFT
+                                        , &sme_conn
+#endif /* SME */
+		)) == NULL) {
 		Xfree ((char *) dpy);
 		return(NULL);
 	}
@@ -776,6 +810,26 @@
 	}
 /* end SUNSOFT_INTERACTIVE */
 
+#ifdef SUNSOFT
+    /*
+       B U G : 4188179
+
+       If client is using shared memory transportation,
+       communication buffer need not be freed upon
+       closing of connection.
+
+       A non-null smeBuffer field in the display structure
+       indicates sme buffer being used.
+     */
+        _conn_buf_size = conn_buf_size;
+
+        if (sme_conn)
+           InitializeSmeConn(dpy, idisplay);
+        else
+           dpy->smeBuffer = NULL ;
+
+#endif /* SME */
+
 /*
  * and return successfully
  */
@@ -899,8 +953,20 @@
 	if (dpy->vendor)
 	   Xfree (dpy->vendor);
 
+    /*
+       B U G : 4188179
+
+       Do not free communication buffer if using shared
+       memory extension.
+
+     */
+#ifdef SUNSOFT /* XSUNTRANSPORT */
+    if ( (dpy->smeBuffer == NULL) && (dpy->buffer) )
+	   Xfree (dpy->buffer);
+#else
         if (dpy->buffer)
 	   Xfree (dpy->buffer);
+#endif
 	if (dpy->keysyms)
 	   Xfree ((char *) dpy->keysyms);
 	if (dpy->xdefaults)
@@ -1063,3 +1129,160 @@
     if (setup) Xfree (setup);
 #endif /* !USE_XCB */
 }
+
+#ifdef SUNSOFT
+/*
+ * Initialize the shm conn.  Do it through the normal X11 extension
+ * protocol, except that it is done invisibly as far as user of libX11 is
+ * concerned.
+ */
+static void
+InitializeSmeConn(Display *dpy, int dpynum)
+{
+	smeRegion *region;
+	XExtCodes *extCodes;
+	xSMEReq *req;
+	xSmeConnInitReply smeReply;
+	xSmeConnInitReply *reply = &smeReply;
+	char *xsunsmesize;
+	char buf[80];
+	int fd;
+
+#define X_SME extCodes->major_opcode
+
+/*
+ * Check if server is configured with this extension.
+ */
+	if (!(extCodes = XInitExtension(dpy, SMENAME)))
+	    return;
+
+/*
+ * Initialize extension in server for this client.
+ */
+	LockDisplay(dpy);
+	GetReq(SME, req);
+	/*
+	 * Xsun manpage (man/man1/Xsun.1) says that default XSUNSMESIZE
+	 * should be 64K.
+	 */
+	if ((xsunsmesize = getenv("XSUNSMESIZE")) != NULL)
+	    req->xsunsmesize = 1024 * atoi(xsunsmesize);
+       else
+	    req->xsunsmesize = 1024 * 64;
+
+	if (req->xsunsmesize < _conn_buf_size)
+	{
+	    req->xsunsmesize = _conn_buf_size;
+	}
+	/*
+	 * Make sure heap size is multiple of conn_buf_size.
+	 */
+	if (req->xsunsmesize % _conn_buf_size != 0)
+	{
+            int chunks;
+
+            chunks = req->xsunsmesize/_conn_buf_size;
+            if (chunks <= 0)
+            {
+                chunks = 1;
+            }
+            req->xsunsmesize = chunks * _conn_buf_size;
+	}
+
+        /*
+         * If the client requested a buffer chunk size that would cause us to
+         * run out of FIFO queue slots, cap it at the maximum.
+         */
+        if ((req->xsunsmesize/_conn_buf_size) > SMECONNQSIZE) {
+                req->xsunsmesize = _conn_buf_size * SMECONNQSIZE;
+        }
+
+	/*
+	 * Add in smeRegion overhead to get total buffer size.
+	 */
+	req->xsunsmesize += sizeof(smeRegion);
+
+	req->subReqType = INIT_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+		 reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	snprintf(buf, sizeof(buf), "%s:%i.%i", SMEFILE, dpynum,
+	  reply->client_index);
+	fd = open(buf, O_RDWR, 0666) ;
+
+	region = (smeRegion *)mmap((caddr_t)0, req->xsunsmesize,
+		PROT_READ|PROT_WRITE, MAP_SHARED, fd, (off_t)0) ;
+	if (region == MAP_FAILED)
+    	{
+    		close(fd) ;
+    		unlink(buf) ;
+#ifdef DEBUG
+    perror("Trying to mmap sme conn region");
+#endif /* DEBUG */
+    		dpy->smeBuffer = NULL ;
+    		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeSize = req->xsunsmesize ;
+	close(fd) ;
+	unlink(buf) ;
+
+/*
+ * Validate that the server is using the new version of smeconn.
+ * It fills in the first half and checks that we fill in the rest.
+ */
+	if (region->smeMagic != (SME_MAGIC4 & 0xffff0000))
+    	{
+    		UnlockDisplay (dpy);
+    		dpy->smeBuffer = NULL ;
+    		return;
+    	}
+
+    	region->smeMagic = SME_MAGIC4;  /* Fill in whole field */
+
+
+        /*
+         * It would be better to pass the buffer allocation unit to the
+         * the server through the initial request, but that would alter
+         * the size of the request structure.
+         */
+        region->smeBufferSize = _conn_buf_size;
+
+/*
+ * Start up sme conn.  Reply synchronizes both server and application
+ * as they switch over to sme request conn.  Content means nothing.
+ */
+	GetReq(SME, req);
+	req->subReqType = START_SME_CONN;
+/*
+	if (!_XReply (dpy, (xReply *)reply, -1, xFalse) ||
+*/
+	if (!_XReply (dpy, (xReply *)reply, 0, xFalse) ||
+    		reply->status != Success)
+    	{
+    		dpy->smeBuffer = NULL ;
+		UnlockDisplay(dpy);
+    		return;
+    	}
+
+	dpy->smeBuffer = (char *)region;
+	Xfree(dpy->buffer);
+	dpy->buffer = dpy->bufptr = dpy->bufmax = NULL;
+	_XSmeAllocateHeapBuffer (dpy, region);
+	dpy->bufptr = dpy->buffer;
+
+	UnlockDisplay(dpy);
+
+#undef X_SmeConn
+}
+#endif /* SME */
+
--- src/XlibInt.c	Fri Oct 16 15:10:13 2009
+++ src/XlibInt.c	Fri Oct 16 10:43:49 2009
@@ -54,8 +54,15 @@
 #include <direct.h>
 #endif
 
+#ifdef SUNSOFT
+#include <string.h>
+#include <thread.h>
+#include <synch.h>
+#include <X11/extensions/sme.h>
+#endif /* SME */
+
 /* Xtransint.h is needed for access to an xtrans internal structure.
- * See the comments in _XFlush for information. This is required for
+ * See the comments in _XFlush for information.  This is required for
  * compatibility between X11R6-xtrans and gnuemacs v18.58.
  */
 #include <X11/Xtrans/Xtransint.h>
@@ -192,6 +199,19 @@
 
 #endif /* MUSTCOPY */
 
+#ifdef SUNSOFT
+extern int _conn_buf_size;
+
+void _XSmeAllocateHeapBuffer(
+#if NeedFunctionPrototypes
+    Display *dpy,
+    smeRegion *smeBp
+#endif
+);
+
+void _XSmeCheckForFull();
+#endif /* SME */
+
 typedef union {
     xReply rep;
     char buf[BUFSIZE];
@@ -228,7 +248,141 @@
 	0, 0, 0
 };
 
+#ifdef SUNSOFT
+
+static
+void
+smeIncHead(smeRegion *smeBp)
+{
+	smeBp->smeHeadptr =
+            (smeBp->smeHeadptr+smeBp->smeBufferSize)%smeBp->smeHeapSize;
+}
+
+#define smePokeServer(dpy, c) { \
+        char byte = (char)c ; \
+        for (;;) { \
+            int result = 0 ; \
+            result = _X11TransWrite (dpy->trans_conn, &byte, 1); \
+            if (result == 1) { \
+                break; \
+            } else if (result == 0) { \
+                continue; \
+            } else if (result < 0 && ETEST()) { \
+                continue; \
+            } else if ((result < 0) && !ECHECK(EINTR)) { \
+                    /* Write failed! */ \
+                    /* errno set by write system call. */ \
+                    _XIOError(dpy); \
+                    break; \
+            } \
+        } \
+}
+
 /*
+ * Wait for the server to open up enough buffer space for us to
+ * continue writing. Since the inbound connection is shared with client
+ * traffic a condition variable is used to block until the Xserver
+ * has freed some buffer space.
+ */
+static void
+SmeWaitForServer(Display *dpy, smeRegion *smeBp)
+{
+        char *save_bufptr = dpy->bufptr;
+
+        dpy->bufptr = dpy->buffer;
+
+
+        /*
+         * Let the Xserver know we are waiting for buffer space.
+         */
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+        smeBp->smeClientBufferBlocked = 1;
+
+        /*
+         * Don't hold the mutex over the poke since it might
+         * cause the Xserver to run and not acquire the mutex the
+         * first time round.
+         */
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+        /*
+         * The 'W' is for debugging when looking at truss output from
+         * an X client. The Xserver doesn't care what the byte contains.
+         */
+        smePokeServer (dpy, 'W');
+
+	(void)mutex_lock(&smeBp->smeBufferMutex);
+
+	while (smeBp->smeClientBufferBlocked != 0) {
+		timestruc_t ts;
+		int err;
+
+                /*
+                 * Can't block indefinitly on the condition variable
+                 * since the Xserver might have terminated.
+                 */
+		ts.tv_sec = 1;
+		ts.tv_nsec = 0;
+
+		err = cond_reltimedwait(&smeBp->smeBufferCV,
+                                        &smeBp->smeBufferMutex,
+                                        &ts);
+		if (err == 0) {
+			/*
+			 * We have been signaled by the server,
+			 * see if smeClientBufferBlocked has been cleared.
+			 */
+			continue;
+		} else if (err == ETIME) {
+			/*
+			 * We timed out, see if we still have a valid
+			 * connect to the server.
+			 */
+			struct pollfd pfd;
+
+    			pfd.fd = dpy->fd;
+                	pfd.events = POLLIN;
+                	pfd.revents = 0;
+
+			err = poll(&pfd, 1, 0);
+
+			if (err == 0) {
+				continue;
+			} else if (err == 1 && pfd.revents & POLLHUP) {
+				break;
+			} else if (err < 0) {
+				break;
+			}
+		}
+        }
+	(void)mutex_unlock(&smeBp->smeBufferMutex);
+
+	dpy->bufptr = save_bufptr;
+}
+
+/*
+ * smeConnQueueIn() adds the current buffer to the FIFO queue of
+ * sme buffers.
+ */
+void smeConnQueueIn(dpy, smeBp, bufptr, msgsize, bufsize)
+    Display     *dpy;
+    smeRegion   *smeBp;
+    char        *bufptr;
+    int         msgsize;
+    int         bufsize;
+{
+    int index;
+
+    index = (uint)(smeBp->smeIn+1) % SMECONNQSIZE;
+    smeBp->smeQueue[index].bufp = bufptr - (char *)(smeBp+1);
+    smeBp->smeQueue[index].msgSize = msgsize;
+
+    smeBp->smeIn++; /* increment after bufp & msgSize updated */
+}
+
+#endif /* SME */
+
+/*
  * This is an OS dependent routine which:
  * 1) returns as soon as the connection can be written on....
  * 2) if the connection can be read, must enqueue events and handle errors,
@@ -315,7 +469,7 @@
 	{
 	    _XAlignedBuffer buf;
 	    BytesReadable_t pend;
-	    register int len;
+	    BytesReadable_t len;
 	    register xReply *rep;
 
 	    /* find out how much data can be read */
@@ -670,7 +824,25 @@
 		dpy->trans_conn->fd = dpy->fd;
 	}
 	/* End gnuemacs v18.58 compatability fix. */
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
 
+                size = (long)(dpy->bufptr - dpy->buffer);
+                if (!size) return;
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,size,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+               /*
+                * The 'D' is for debugging when looking at truss output from
+                * an X client. The Xserver doesn't care what the byte contains.
+                */
+                smePokeServer (dpy, 'D');
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+                dpy->bufptr = dpy->buffer;
+        }
+        else {
+#endif /* SME */
+
 	/* This fix resets the bufptr to the front of the buffer so
 	 * additional appends to the bufptr will not corrupt memory. Since
 	 * the server is down, these appends are no-op's anyway but
@@ -692,7 +864,7 @@
 	    }
 	}
 #endif
-	size = todo = dpy->bufptr - dpy->buffer;
+	size = todo = (long)(dpy->bufptr - dpy->buffer);
 	if (!size) return;
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
@@ -753,6 +925,11 @@
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+
+#ifdef SUNSOFT
+    }
+#endif /* SME */
+	return;
 }
 
 int
@@ -760,7 +937,7 @@
     register Display *dpy,
     int mode)
 {
-	register int len;
+	BytesReadable_t len;
 	BytesReadable_t pend;
 	_XAlignedBuffer buf;
 	register xReply *rep;
@@ -884,7 +1061,6 @@
 #endif /* XTHREADS*/
 	{
 	    read_buf = buf.buf;
-
 	    if (len < SIZEOF(xReply)
 #ifdef XTHREADS
 		|| dpy->async_handlers
@@ -956,7 +1132,7 @@
 {
 	_XAlignedBuffer buf;
 	BytesReadable_t pend;
-	int len;
+	BytesReadable_t len;
 	register xReply *rep;
 	Bool not_yet_flushed = True;
 	char *read_buf;
@@ -1420,8 +1596,84 @@
 	long skip, dbufsize, padsize, total, todo;
 	_XExtension *ext;
 
+#ifdef SUNSOFT
+        if (dpy->smeBuffer) {
+                smeRegion *smeBp = (smeRegion *) dpy->smeBuffer;
+
+                dbufsize = dpy->bufptr-dpy->buffer;
+
+                padsize = -size & 3;
+
+                total =  dbufsize + size + padsize;
+
+                /*
+                 * If request won't fit in a single sme buffer, break it up
+                 * into smaller requests.
+                 */
+                if (total > (long)(_conn_buf_size))
+                {
+                        long bytesCopied = 0 ;
+                        long numToCopy = 0 ;
+                        long chunk = _conn_buf_size & 0xffffffc ;
+
+                        while (bytesCopied < size)
+                        {
+                                /*
+                                 * Compensate for buffer contents.
+                                 */
+                                if (dbufsize) {
+                                        numToCopy = chunk - dbufsize;
+                                        numToCopy = min(numToCopy, size);
+                                        numToCopy &= 0xffffffc;
+                                        dbufsize = 0;
+                                } else if (size - bytesCopied >= chunk) {
+                                        numToCopy = chunk;
+                                } else {
+                                        numToCopy = size - bytesCopied ;
+                                }
+                                _XSend(dpy, data + bytesCopied, numToCopy) ;
+                                bytesCopied += numToCopy ;
+                        }
+                        return;
+                }
+                else {
+
+                /*
+                 * Copy data into sme buffer.
+                 */
+
+                if (size) {
+                    memcpy (dpy->bufptr, data, size);
+                }
+
+                /* Pad the buffer with zeros. */
+                if (padsize)
+                {
+                   char *p = (char *)dpy->bufptr + size;
+                   int i;
+                   for (i = 0; i < padsize; i++)
+                      *p++ = '\0';
+                }
+
+                smeConnQueueIn (dpy,smeBp,dpy->buffer,total,_conn_buf_size);
+                dpy->last_req = (char *)&_dummy_request;
+                smePokeServer (dpy, 'D');
+
+                /* Allocate a new buffer */
+                dpy->buffer = dpy->bufmax;
+
+                /* Get a new buffer */
+                _XSmeAllocateHeapBuffer (dpy, smeBp);
+
+                /* Reset pointer to beginning of new sme buffer. */
+                dpy->bufptr = dpy->buffer;
+        	}
+        }
+        else {
+#endif /* SME */
+
 	if (!size || (dpy->flags & XlibDisplayIOError)) return;
-	dbufsize = dpy->bufptr - dpy->buffer;
+	dbufsize = (long)(dpy->bufptr - dpy->buffer);
 #ifdef XTHREADS
 	dpy->flags |= XlibDisplayWriting;
 	/* make sure no one else can put in data */
@@ -1525,9 +1777,66 @@
 #ifdef XTHREADS
 	dpy->flags &= ~XlibDisplayWriting;
 #endif
+#ifdef SUNSOFT
+	}
+#endif /* SME */
 	return;
 }
 
+#ifdef SUNSOFT
+
+
+/*
+ * Allocate a buffer in the shared memory region using a stack heap.
+ * Note: this routine starts the allocation at the value of dpy->buffer
+ */
+
+void
+_XSmeAllocateHeapBuffer(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+        for (;;) {
+
+           /*
+            * Determine if the circular list is full or has space.
+            */
+            if ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+                (smeBp->smeIn != smeBp->smeOut)) {
+                /*
+                 * Full, wait for space.
+                 */
+                SmeWaitForServer(dpy, smeBp);
+                continue;
+            } else {
+                /*
+                 * Take the next buffer chunk.
+                 */
+                dpy->buffer = smeBp->smeHeadptr + (char *)(smeBp + 1);
+                dpy->bufmax = dpy->buffer + smeBp->smeBufferSize;
+                smeIncHead(smeBp);
+                break;
+           }
+        }
+}
+
+void
+_XSmeCheckForFull(dpy, smeBp)
+    Display *dpy;
+    smeRegion *smeBp;
+{
+
+    while ((smeBp->smeHeadptr == smeBp->smeTailptr) &&
+           (smeBp->smeIn != smeBp->smeOut)) {
+        /*
+         * Full, wait for space.
+         */
+         SmeWaitForServer(dpy, smeBp);
+    }
+}
+
+#endif /* SME */
+
 static void
 _XGetMiscCode(
     register Display *dpy)
