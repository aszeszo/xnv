--- include/GL/internal/glcore.h	Thu Jun 19 16:28:49 2008
+++ include/GL/internal/glcore.h	Thu Jun 19 16:33:23 2008
@@ -38,11 +38,17 @@
 
 #include <sys/types.h>
 
+#ifdef CAPI
+#undef CAPI
+#endif
+#define CAPI
+
 #define GL_CORE_SGI  1
 #define GL_CORE_MESA 2
 #define GL_CORE_APPLE 4
 
 typedef struct __GLcontextRec __GLcontext;
+typedef struct __GLinterfaceRec __GLinterface;
 
 /*
 ** This file defines the interface between the GL core and the surrounding
@@ -180,4 +186,333 @@
 #define GLX_TEXTURE_2D_BIT_EXT             0x00000002
 #define GLX_TEXTURE_RECTANGLE_BIT_EXT      0x00000004
 
+/************************************************************************/
+
+/*
+** Structure used for allocating and freeing drawable private memory.
+** (like software buffers, for example).
+**
+** The memory allocation routines are provided by the surrounding
+** "operating system" code, and they are to be used for allocating
+** software buffers and things which are associated with the drawable,
+** and used by any context which draws to that drawable.  There are
+** separate memory allocation functions for drawables and contexts
+** since drawables and contexts can be created and destroyed independently
+** of one another, and the "operating system" may want to use separate
+** allocation arenas for each.
+**
+** The freePrivate function is filled in by the core routines when they
+** allocates software buffers, and stick them in "private".  The freePrivate
+** function will destroy anything allocated to this drawable (to be called
+** when the drawable is destroyed).
+*/
+typedef struct __GLdrawableRegionRec __GLdrawableRegion;
+typedef struct __GLdrawableBufferRec __GLdrawableBuffer;
+typedef struct __GLdrawablePrivateRec __GLdrawablePrivate;
+
+typedef struct __GLregionRectRec {
+    /* lower left (inside the rectangle) */
+    GLint x0, y0;
+    /* upper right (outside the rectangle) */
+    GLint x1, y1;
+} __GLregionRect;
+
+struct __GLdrawableRegionRec {
+    GLint numRects;
+    __GLregionRect *rects;
+    __GLregionRect boundingRect;
+};
+
+/************************************************************************/
+
+/* masks for the buffers */
+#define __GL_FRONT_BUFFER_MASK		0x00000001
+#define	__GL_FRONT_LEFT_BUFFER_MASK	0x00000001
+#define	__GL_FRONT_RIGHT_BUFFER_MASK	0x00000002
+#define	__GL_BACK_BUFFER_MASK		0x00000004
+#define __GL_BACK_LEFT_BUFFER_MASK	0x00000004
+#define __GL_BACK_RIGHT_BUFFER_MASK	0x00000008
+#define	__GL_ACCUM_BUFFER_MASK		0x00000010
+#define	__GL_DEPTH_BUFFER_MASK		0x00000020
+#define	__GL_STENCIL_BUFFER_MASK	0x00000040
+#define	__GL_AUX_BUFFER_MASK(i)		(0x0000080 << (i))
+
+#define __GL_ALL_BUFFER_MASK		0xffffffff
+
+/* what Resize routines return if resize resorted to fallback case */
+#define __GL_BUFFER_FALLBACK	0x10
+
+typedef void (*__GLbufFallbackInitFn)(__GLdrawableBuffer *buf, 
+				      __GLdrawablePrivate *glPriv, GLint bits);
+typedef void (*__GLbufMainInitFn)(__GLdrawableBuffer *buf, 
+				  __GLdrawablePrivate *glPriv, GLint bits,
+				  __GLbufFallbackInitFn back);
+
+/*
+** A drawable buffer
+**
+** This data structure describes the context side of a drawable.  
+**
+** According to the spec there could be multiple contexts bound to the same
+** drawable at the same time (from different threads).  In order to avoid
+** multiple-access conflicts, locks are used to serialize access.  When a
+** thread needs to access (read or write) a member of the drawable, it takes
+** a lock first.  Some of the entries in the drawable are treated "mostly
+** constant", so we take the freedom of allowing access to them without
+** taking a lock (for optimization reasons).
+**
+** For more details regarding locking, see buffers.h in the GL core
+*/
+struct __GLdrawableBufferRec {
+    /*
+    ** Buffer dimensions
+    */
+    GLint width, height, depth;
+
+    /*
+    ** Framebuffer base address
+    */
+    void *base;
+
+    /*
+    ** Framebuffer size (in bytes)
+    */
+    GLuint size;
+
+    /*
+    ** Size (in bytes) of each element in the framebuffer
+    */
+    GLuint elementSize;
+    GLuint elementSizeLog2;
+
+    /*
+    ** Element skip from one scanline to the next.
+    ** If the buffer is part of another buffer (for example, fullscreen
+    ** front buffer), outerWidth is the width of that buffer.
+    */
+    GLint outerWidth;
+
+    /*
+    ** outerWidth * elementSize
+    */
+    GLint byteWidth;
+
+    /*
+    ** Allocation/deallocation is done based on this handle.  A handle
+    ** is conceptually different from the framebuffer 'base'.
+    */
+    void *handle;
+
+    /* imported */
+    GLboolean (*resize)(__GLdrawableBuffer *buf,
+			GLint x, GLint y, GLuint width, GLuint height, 
+			__GLdrawablePrivate *glPriv, GLuint bufferMask);
+    void (*lock)(__GLdrawableBuffer *buf, __GLdrawablePrivate *glPriv);
+    void (*unlock)(__GLdrawableBuffer *buf, __GLdrawablePrivate *glPriv);
+    void (*fill)(__GLdrawableBuffer *buf, __GLdrawablePrivate *glPriv,
+    		GLuint val, GLint x, GLint y, GLint w, GLint h);
+    void (*free)(__GLdrawableBuffer *buf, __GLdrawablePrivate *glPriv);
+
+    /* exported */
+    void (*freePrivate)(__GLdrawableBuffer *buf, __GLdrawablePrivate *glPriv);
+#ifdef __cplusplus
+    void *privatePtr;
+#else
+    void *private;
+#endif
+
+    /* private */
+    void *other;	/* implementation private data */
+    __GLbufMainInitFn mainInit;
+    __GLbufFallbackInitFn fallbackInit;
+};
+
+/*
+** The context side of the drawable private
+*/
+struct __GLdrawablePrivateRec {
+    /*
+    ** Drawable Modes
+    */
+    __GLcontextModes *modes;
+
+    /*
+    ** Drawable size
+    */
+    GLuint width, height;
+
+    /*
+    ** Origin in screen coordinates of the drawable
+    */
+    GLint xOrigin, yOrigin;
+#ifdef __GL_ALIGNED_BUFFERS
+    /*
+    ** Drawable offset from screen origin
+    */
+    GLint xOffset, yOffset;
+
+    /*
+    ** Alignment restriction
+    */
+    GLint xAlignment, yAlignment;
+#endif
+    /*
+    ** Should we invert the y axis?
+    */
+    GLint yInverted;
+
+    /*
+    ** Mask specifying which buffers are renderable by the hw
+    */
+    GLuint accelBufferMask;
+
+    /*
+    ** the buffers themselves
+    */
+    __GLdrawableBuffer frontBuffer;
+    __GLdrawableBuffer backBuffer;
+    __GLdrawableBuffer accumBuffer;
+    __GLdrawableBuffer depthBuffer;
+    __GLdrawableBuffer stencilBuffer;
+#if defined(__GL_NUMBER_OF_AUX_BUFFERS) && (__GL_NUMBER_OF_AUX_BUFFERS > 0)
+    __GLdrawableBuffer *auxBuffer;
+#endif
+
+    __GLdrawableRegion ownershipRegion;
+
+    /*
+    ** Lock for the drawable private structure
+    */
+    void *lock;
+#ifdef DEBUG
+    /* lock debugging info */
+    int lockRefCount;
+    int lockLine[10];
+    char *lockFile[10];
+#endif
+
+    /* imported */
+    void *(*malloc)(size_t size);
+    void *(*calloc)(size_t numElem, size_t elemSize);
+    void *(*realloc)(void *oldAddr, size_t newSize);
+    void (*free)(void *addr);
+
+    GLboolean (*addSwapRect)(__GLdrawablePrivate *glPriv, 
+			     GLint x, GLint y, GLsizei width, GLsizei height);
+    void (*setClipRect)(__GLdrawablePrivate *glPriv, 
+			GLint x, GLint y, GLsizei width, GLsizei height);
+    void (*updateClipRegion)(__GLdrawablePrivate *glPriv);
+    GLboolean (*resize)(__GLdrawablePrivate *glPriv);
+    void (*getDrawableSize)(__GLdrawablePrivate *glPriv, 
+			    GLint *x, GLint *y, GLuint *width, GLuint *height);
+
+    void (*lockDP)(__GLdrawablePrivate *glPriv, __GLcontext *gc);
+    void (*unlockDP)(__GLdrawablePrivate *glPriv);
+
+    /* exported */
+#ifdef __cplusplus
+    void *privatePtr;
+#else
+    void *private;
+#endif
+    void (*freePrivate)(__GLdrawablePrivate *);
+
+    /* client data */
+    void *other;
+};
+
+/*
+** Macros to lock/unlock the drawable private
+*/
+#if defined(DEBUG)
+#define __GL_LOCK_DP(glPriv,gc) \
+    (*(glPriv)->lockDP)(glPriv,gc); \
+    (glPriv)->lockLine[(glPriv)->lockRefCount] = __LINE__; \
+    (glPriv)->lockFile[(glPriv)->lockRefCount] = __FILE__; \
+    (glPriv)->lockRefCount++
+#define __GL_UNLOCK_DP(glPriv) \
+    (glPriv)->lockRefCount--; \
+    (glPriv)->lockLine[(glPriv)->lockRefCount] = 0; \
+    (glPriv)->lockFile[(glPriv)->lockRefCount] = NULL; \
+    (*(glPriv)->unlockDP)(glPriv)
+#else /* DEBUG */
+#define __GL_LOCK_DP(glPriv,gc)		(*(glPriv)->lockDP)(glPriv,gc)
+#define	__GL_UNLOCK_DP(glPriv)		(*(glPriv)->unlockDP)(glPriv)
+#endif /* DEBUG */
+
+
+/*
+** Procedures which are imported by the GL from the surrounding
+** "operating system".  Math functions are not considered part of the
+** "operating system".
+*/
+typedef struct __GLimportsRec {
+    /* Memory management */
+    void * (*malloc)(__GLcontext *gc, size_t size);
+    void *(*calloc)(__GLcontext *gc, size_t numElem, size_t elemSize);
+    void *(*realloc)(__GLcontext *gc, void *oldAddr, size_t newSize);
+    void (*free)(__GLcontext *gc, void *addr);
+
+    /* Error handling */
+    void (*warning)(__GLcontext *gc, char *fmt);
+    void (*fatal)(__GLcontext *gc, char *fmt);
+
+    /* other system calls */
+    char *(CAPI *getenv)(__GLcontext *gc, const char *var);
+    int (CAPI *atoi)(__GLcontext *gc, const char *str);
+    int (CAPI *sprintf)(__GLcontext *gc, char *str, const char *fmt, ...);
+    void *(CAPI *fopen)(__GLcontext *gc, const char *path, const char *mode);
+    int (CAPI *fclose)(__GLcontext *gc, void *stream);
+    int (CAPI *fprintf)(__GLcontext *gc, void *stream, const char *fmt, ...);
+
+    /* Drawing surface management */
+    __GLdrawablePrivate *(*getDrawablePrivate)(__GLcontext *gc);
+    __GLdrawablePrivate *(*getReadablePrivate)(__GLcontext *gc);
+
+    /* Operating system dependent data goes here */
+    void *other;
+} __GLimports;
+
+/************************************************************************/
+
+/*
+** Procedures which are exported by the GL to the surrounding "operating
+** system" so that it can manage multiple GL context's.
+*/
+typedef struct __GLexportsRec {
+    /* Context management (return GL_FALSE on failure) */
+    GLboolean (*destroyContext)(__GLcontext *gc);
+    GLboolean (*loseCurrent)(__GLcontext *gc);
+    /* oldglPriv isn't used anymore, kept for backwards compatibility */
+    GLboolean (*makeCurrent)(__GLcontext *gc);
+    GLboolean (*shareContext)(__GLcontext *gc, __GLcontext *gcShare);
+    GLboolean (*copyContext)(__GLcontext *dst, const __GLcontext *src, GLuint mask);
+    GLboolean (*forceCurrent)(__GLcontext *gc);
+
+    /* Drawing surface notification callbacks */
+    GLboolean (*notifyResize)(__GLcontext *gc);
+    void (*notifyDestroy)(__GLcontext *gc);
+    void (*notifySwapBuffers)(__GLcontext *gc);
+
+    /* Dispatch table override control for external agents like libGLS */
+    struct __GLdispatchStateRec* (*dispatchExec)(__GLcontext *gc);
+    void (*beginDispatchOverride)(__GLcontext *gc);
+    void (*endDispatchOverride)(__GLcontext *gc);
+} __GLexports;
+
+/************************************************************************/
+
+/*
+** This must be the first member of a __GLcontext structure.  This is the
+** only part of a context that is exposed to the outside world; everything
+** else is opaque.
+*/
+struct __GLinterfaceRec {
+    __GLimports imports;
+    __GLexports exports;
+};
+
+extern __GLcontext *__glCoreCreateContext(__GLimports *, __GLcontextModes *);
+extern void __glCoreNopDispatch(void);
+
 #endif /* __gl_core_h_ */

--- src/mesa/drivers/dri/i965/intel_buffers.c     Thu Nov  1 08:30:52 2007
+++ src/mesa/drivers/dri/i965/intel_buffers.c        Thu Sep  4 21:35:02 2008
@@ -192,6 +192,7 @@
       }
    }
 
+#if 0
    {
       if (intel->intelScreen->driScrnPriv->ddxMinor >= 7) {
         volatile drmI830Sarea *sarea = intel->sarea;
@@ -224,6 +225,8 @@
          intel->vblank_flags &= ~VBLANK_FLAG_SECONDARY;
       }
    }
+#endif
+
    _mesa_resize_framebuffer(&intel->ctx,
                            (GLframebuffer*)dPriv->driverPrivate,
                            dPriv->w, dPriv->h);

--- include/GL/glxext.h	Mon Oct  6 10:51:23 2008
+++ include/GL/glxext.h	Mon Oct  6 10:54:36 2008
@@ -406,10 +406,10 @@
 /* (as used in the GLX_OML_sync_control extension). */
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
 #include <inttypes.h>
-#elif defined(__sun__) || defined(__digital__)
+#elif defined(sun) || defined(__digital__)
 #include <inttypes.h>
-#if defined(__STDC__)
-#if defined(__arch64__) || defined(_LP64)
+#elif defined(__STDC__)
+#if defined(__arch64__)
 typedef long int int64_t;
 typedef unsigned long int uint64_t;
 #else
@@ -434,7 +434,6 @@
 #else
 #include <inttypes.h>     /* Fallback option */
 #endif
-#endif
 
 #ifndef GLX_VERSION_1_3
 #define GLX_VERSION_1_3 1
--- include/GL/glext.h	Mon Oct  6 10:55:51 2008
+++ include/GL/glext.h	Mon Oct  6 10:56:47 2008
@@ -3739,10 +3739,10 @@
 /* (as used in the GL_EXT_timer_query extension). */
 #if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
 #include <inttypes.h>
-#elif defined(__sun__) || defined(__digital__)
+#elif defined(sun)
 #include <inttypes.h>
-#if defined(__STDC__)
-#if defined(__arch64__) || defined(_LP64)
+#elif defined(__STDC__)
+#if defined(__arch64__)
 typedef long int int64_t;
 typedef unsigned long int uint64_t;
 #else
@@ -3767,7 +3767,6 @@
 #else
 #include <inttypes.h>     /* Fallback option */
 #endif
-#endif
 
 #ifndef GL_EXT_timer_query
 typedef int64_t GLint64EXT;
