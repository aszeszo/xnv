# Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
# Use subject to license terms.
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, and/or sell copies of the Software, and to permit persons
# to whom the Software is furnished to do so, provided that the above
# copyright notice(s) and this permission notice appear in all copies of
# the Software and that both the above copyright notice(s) and this
# permission notice appear in supporting documentation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
# OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
# HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
# INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
# FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# # WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
# Except as contained in this notice, the name of a copyright holder
# shall not be used in advertising or otherwise to promote the sale, use
# or other dealings in this Software without prior written authorization
# of the copyright holder.

--- src/truetype/ttinterp.c	2008-06-06 03:14:58.000000000 -0400
+++ src/truetype/ttinterp.c	2008-06-10 12:55:29.000000000 -0400
@@ -237,8 +237,8 @@
 #define GUESS_VECTOR( V )                                         \
   if ( CUR.face->unpatented_hinting )                             \
   {                                                               \
-    CUR.GS.V.x = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0x4000 : 0 ); \
-    CUR.GS.V.y = (FT_F2Dot14)( CUR.GS.both_x_axis ? 0 : 0x4000 ); \
+    CUR.FT_GS.V.x = (FT_F2Dot14)( CUR.FT_GS.both_x_axis ? 0x4000 : 0 ); \
+    CUR.FT_GS.V.y = (FT_F2Dot14)( CUR.FT_GS.both_x_axis ? 0 : 0x4000 ); \
   }
 #else
 #define GUESS_VECTOR( V )
@@ -585,7 +585,7 @@
         exec->codeRangeTable[i] = size->codeRangeTable[i];
 
       /* set graphics state */
-      exec->GS = size->GS;
+      exec->FT_GS = size->FT_GS;
 
       exec->cvtSize = size->cvt_size;
       exec->cvt     = size->cvt;
@@ -713,22 +713,22 @@
     exec->zp1 = exec->pts;
     exec->zp2 = exec->pts;
 
-    exec->GS.gep0 = 1;
-    exec->GS.gep1 = 1;
-    exec->GS.gep2 = 1;
+    exec->FT_GS.gep0 = 1;
+    exec->FT_GS.gep1 = 1;
+    exec->FT_GS.gep2 = 1;
 
-    exec->GS.projVector.x = 0x4000;
-    exec->GS.projVector.y = 0x0000;
+    exec->FT_GS.projVector.x = 0x4000;
+    exec->FT_GS.projVector.y = 0x0000;
 
-    exec->GS.freeVector = exec->GS.projVector;
-    exec->GS.dualVector = exec->GS.projVector;
+    exec->FT_GS.freeVector = exec->FT_GS.projVector;
+    exec->FT_GS.dualVector = exec->FT_GS.projVector;
 
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
-    exec->GS.both_x_axis = TRUE;
+    exec->FT_GS.both_x_axis = TRUE;
 #endif
 
-    exec->GS.round_state = 1;
-    exec->GS.loop        = 1;
+    exec->FT_GS.round_state = 1;
+    exec->FT_GS.loop        = 1;
 
     /* some glyphs leave something on the stack. so we clean it */
     /* before a new execution.                                  */
@@ -1350,7 +1350,7 @@
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
       if ( CUR.face->unpatented_hinting )
       {
-        if ( CUR.GS.both_x_axis )
+        if ( CUR.FT_GS.both_x_axis )
           CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
         else
           CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
@@ -1358,10 +1358,10 @@
       else
 #endif
       {
-        if ( CUR.GS.projVector.y == 0 )
+        if ( CUR.FT_GS.projVector.y == 0 )
           CUR.tt_metrics.ratio = CUR.tt_metrics.x_ratio;
 
-        else if ( CUR.GS.projVector.x == 0 )
+        else if ( CUR.FT_GS.projVector.x == 0 )
           CUR.tt_metrics.ratio = CUR.tt_metrics.y_ratio;
 
         else
@@ -1369,9 +1369,9 @@
           FT_Long  x, y;
 
 
-          x = TT_MULDIV( CUR.GS.projVector.x,
+          x = TT_MULDIV( CUR.FT_GS.projVector.x,
                          CUR.tt_metrics.x_ratio, 0x4000 );
-          y = TT_MULDIV( CUR.GS.projVector.y,
+          y = TT_MULDIV( CUR.FT_GS.projVector.y,
                          CUR.tt_metrics.y_ratio, 0x4000 );
           CUR.tt_metrics.ratio = TT_VecLen( x, y );
         }
@@ -1551,7 +1551,7 @@
     FT_ASSERT( !CUR.face->unpatented_hinting );
 #endif
 
-    v = CUR.GS.freeVector.x;
+    v = CUR.FT_GS.freeVector.x;
 
     if ( v != 0 )
     {
@@ -1562,7 +1562,7 @@
       zone->tags[point] |= FT_CURVE_TAG_TOUCH_X;
     }
 
-    v = CUR.GS.freeVector.y;
+    v = CUR.FT_GS.freeVector.y;
 
     if ( v != 0 )
     {
@@ -1604,14 +1604,14 @@
     FT_ASSERT( !CUR.face->unpatented_hinting );
 #endif
 
-    v = CUR.GS.freeVector.x;
+    v = CUR.FT_GS.freeVector.x;
 
     if ( v != 0 )
       zone->org[point].x += TT_MULDIV( distance,
                                        v * 0x10000L,
                                        CUR.F_dot_P );
 
-    v = CUR.GS.freeVector.y;
+    v = CUR.FT_GS.freeVector.y;
 
     if ( v != 0 )
       zone->org[point].y += TT_MULDIV( distance,
@@ -2191,8 +2191,8 @@
 #endif
 
     return TT_DotFix14( dx, dy,
-                        CUR.GS.projVector.x,
-                        CUR.GS.projVector.y );
+                        CUR.FT_GS.projVector.x,
+                        CUR.FT_GS.projVector.y );
   }
 
 
@@ -2217,8 +2217,8 @@
                          FT_Pos  dy )
   {
     return TT_DotFix14( dx, dy,
-                        CUR.GS.dualVector.x,
-                        CUR.GS.dualVector.y );
+                        CUR.FT_GS.dualVector.x,
+                        CUR.FT_GS.dualVector.y );
   }
 
 
@@ -2295,18 +2295,18 @@
       /* `both-x-axis' true, otherwise set it false.  The x values only     */
       /* need be tested because the vector has been normalised to a unit    */
       /* vector of length 0x4000 = unity.                                   */
-      CUR.GS.both_x_axis = (FT_Bool)( CUR.GS.projVector.x == 0x4000 &&
-                                      CUR.GS.freeVector.x == 0x4000 );
+      CUR.FT_GS.both_x_axis = (FT_Bool)( CUR.FT_GS.projVector.x == 0x4000 &&
+                                      CUR.FT_GS.freeVector.x == 0x4000 );
 
       /* Throw away projection and freedom vector information */
       /* because the patents don't allow them to be stored.   */
       /* The relevant US Patents are 5155805 and 5325479.     */
-      CUR.GS.projVector.x = 0;
-      CUR.GS.projVector.y = 0;
-      CUR.GS.freeVector.x = 0;
-      CUR.GS.freeVector.y = 0;
+      CUR.FT_GS.projVector.x = 0;
+      CUR.FT_GS.projVector.y = 0;
+      CUR.FT_GS.freeVector.x = 0;
+      CUR.FT_GS.freeVector.y = 0;
 
-      if ( CUR.GS.both_x_axis )
+      if ( CUR.FT_GS.both_x_axis )
       {
         CUR.func_project   = Project_x;
         CUR.func_move      = Direct_Move_X;
@@ -2319,11 +2319,11 @@
         CUR.func_move_orig = Direct_Move_Orig_Y;
       }
 
-      if ( CUR.GS.dualVector.x == 0x4000 )
+      if ( CUR.FT_GS.dualVector.x == 0x4000 )
         CUR.func_dualproj = Project_x;
       else
       {
-        if ( CUR.GS.dualVector.y == 0x4000 )
+        if ( CUR.FT_GS.dualVector.y == 0x4000 )
           CUR.func_dualproj = Project_y;
         else
           CUR.func_dualproj = Dual_Project;
@@ -2336,32 +2336,32 @@
     }
 #endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING */
 
-    if ( CUR.GS.freeVector.x == 0x4000 )
-      CUR.F_dot_P       = CUR.GS.projVector.x * 0x10000L;
+    if ( CUR.FT_GS.freeVector.x == 0x4000 )
+      CUR.F_dot_P       = CUR.FT_GS.projVector.x * 0x10000L;
     else
     {
-      if ( CUR.GS.freeVector.y == 0x4000 )
-        CUR.F_dot_P       = CUR.GS.projVector.y * 0x10000L;
+      if ( CUR.FT_GS.freeVector.y == 0x4000 )
+        CUR.F_dot_P       = CUR.FT_GS.projVector.y * 0x10000L;
       else
-        CUR.F_dot_P = (FT_Long)CUR.GS.projVector.x * CUR.GS.freeVector.x * 4 +
-                      (FT_Long)CUR.GS.projVector.y * CUR.GS.freeVector.y * 4;
+        CUR.F_dot_P = (FT_Long)CUR.FT_GS.projVector.x * CUR.FT_GS.freeVector.x * 4 +
+                      (FT_Long)CUR.FT_GS.projVector.y * CUR.FT_GS.freeVector.y * 4;
     }
 
-    if ( CUR.GS.projVector.x == 0x4000 )
+    if ( CUR.FT_GS.projVector.x == 0x4000 )
       CUR.func_project = (TT_Project_Func)Project_x;
     else
     {
-      if ( CUR.GS.projVector.y == 0x4000 )
+      if ( CUR.FT_GS.projVector.y == 0x4000 )
         CUR.func_project = (TT_Project_Func)Project_y;
       else
         CUR.func_project = (TT_Project_Func)Project;
     }
 
-    if ( CUR.GS.dualVector.x == 0x4000 )
+    if ( CUR.FT_GS.dualVector.x == 0x4000 )
       CUR.func_dualproj = (TT_Project_Func)Project_x;
     else
     {
-      if ( CUR.GS.dualVector.y == 0x4000 )
+      if ( CUR.FT_GS.dualVector.y == 0x4000 )
         CUR.func_dualproj = (TT_Project_Func)Project_y;
       else
         CUR.func_dualproj = (TT_Project_Func)Dual_Project;
@@ -2372,14 +2372,14 @@
 
     if ( CUR.F_dot_P == 0x40000000L )
     {
-      if ( CUR.GS.freeVector.x == 0x4000 )
+      if ( CUR.FT_GS.freeVector.x == 0x4000 )
       {
         CUR.func_move      = (TT_Move_Func)Direct_Move_X;
         CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
       }
       else
       {
-        if ( CUR.GS.freeVector.y == 0x4000 )
+        if ( CUR.FT_GS.freeVector.y == 0x4000 )
         {
           CUR.func_move      = (TT_Move_Func)Direct_Move_Y;
           CUR.func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
@@ -2576,13 +2576,13 @@
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
-    CUR.GS.freeVector.x = A;                \
-    CUR.GS.projVector.x = A;                \
-    CUR.GS.dualVector.x = A;                \
+    CUR.FT_GS.freeVector.x = A;                \
+    CUR.FT_GS.projVector.x = A;                \
+    CUR.FT_GS.dualVector.x = A;                \
                                             \
-    CUR.GS.freeVector.y = B;                \
-    CUR.GS.projVector.y = B;                \
-    CUR.GS.dualVector.y = B;                \
+    CUR.FT_GS.freeVector.y = B;                \
+    CUR.FT_GS.projVector.y = B;                \
+    CUR.FT_GS.dualVector.y = B;                \
                                             \
     COMPUTE_Funcs();                        \
   }
@@ -2596,11 +2596,11 @@
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
-    CUR.GS.projVector.x = A;                \
-    CUR.GS.dualVector.x = A;                \
+    CUR.FT_GS.projVector.x = A;                \
+    CUR.FT_GS.dualVector.x = A;                \
                                             \
-    CUR.GS.projVector.y = B;                \
-    CUR.GS.dualVector.y = B;                \
+    CUR.FT_GS.projVector.y = B;                \
+    CUR.FT_GS.dualVector.y = B;                \
                                             \
     GUESS_VECTOR( freeVector );             \
                                             \
@@ -2616,8 +2616,8 @@
     A = (FT_Short)( CUR.opcode & 1 ) << 14; \
     B = A ^ (FT_Short)0x4000;               \
                                             \
-    CUR.GS.freeVector.x = A;                \
-    CUR.GS.freeVector.y = B;                \
+    CUR.FT_GS.freeVector.x = A;                \
+    CUR.FT_GS.freeVector.y = B;                \
                                             \
     GUESS_VECTOR( projVector );             \
                                             \
@@ -2629,9 +2629,9 @@
     if ( INS_SxVTL( (FT_UShort)args[1],               \
                     (FT_UShort)args[0],               \
                     CUR.opcode,                       \
-                    &CUR.GS.projVector ) == SUCCESS ) \
+                    &CUR.FT_GS.projVector ) == SUCCESS ) \
     {                                                 \
-      CUR.GS.dualVector = CUR.GS.projVector;          \
+      CUR.FT_GS.dualVector = CUR.FT_GS.projVector;          \
       GUESS_VECTOR( freeVector );                     \
       COMPUTE_Funcs();                                \
     }
@@ -2641,7 +2641,7 @@
     if ( INS_SxVTL( (FT_UShort)args[1],               \
                     (FT_UShort)args[0],               \
                     CUR.opcode,                       \
-                    &CUR.GS.freeVector ) == SUCCESS ) \
+                    &CUR.FT_GS.freeVector ) == SUCCESS ) \
     {                                                 \
       GUESS_VECTOR( projVector );                     \
       COMPUTE_Funcs();                                \
@@ -2650,7 +2650,7 @@
 
 #define DO_SFVTPV                          \
     GUESS_VECTOR( projVector );            \
-    CUR.GS.freeVector = CUR.GS.projVector; \
+    CUR.FT_GS.freeVector = CUR.FT_GS.projVector; \
     COMPUTE_Funcs();
 
 
@@ -2666,9 +2666,9 @@
     S = (FT_Short)args[0];                      \
     X = (FT_Long)S;                             \
                                                 \
-    NORMalize( X, Y, &CUR.GS.projVector );      \
+    NORMalize( X, Y, &CUR.FT_GS.projVector );      \
                                                 \
-    CUR.GS.dualVector = CUR.GS.projVector;      \
+    CUR.FT_GS.dualVector = CUR.FT_GS.projVector;      \
     GUESS_VECTOR( freeVector );                 \
     COMPUTE_Funcs();                            \
   }
@@ -2686,7 +2686,7 @@
     S = (FT_Short)args[0];                      \
     X = S;                                      \
                                                 \
-    NORMalize( X, Y, &CUR.GS.freeVector );      \
+    NORMalize( X, Y, &CUR.FT_GS.freeVector );      \
     GUESS_VECTOR( projVector );                 \
     COMPUTE_Funcs();                            \
   }
@@ -2696,18 +2696,18 @@
 #define DO_GPV                                   \
     if ( CUR.face->unpatented_hinting )          \
     {                                            \
-      args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
-      args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
+      args[0] = CUR.FT_GS.both_x_axis ? 0x4000 : 0; \
+      args[1] = CUR.FT_GS.both_x_axis ? 0 : 0x4000; \
     }                                            \
     else                                         \
     {                                            \
-      args[0] = CUR.GS.projVector.x;             \
-      args[1] = CUR.GS.projVector.y;             \
+      args[0] = CUR.FT_GS.projVector.x;             \
+      args[1] = CUR.FT_GS.projVector.y;             \
     }
 #else
 #define DO_GPV                                   \
-    args[0] = CUR.GS.projVector.x;               \
-    args[1] = CUR.GS.projVector.y;
+    args[0] = CUR.FT_GS.projVector.x;               \
+    args[1] = CUR.FT_GS.projVector.y;
 #endif
 
 
@@ -2715,72 +2715,72 @@
 #define DO_GFV                                   \
     if ( CUR.face->unpatented_hinting )          \
     {                                            \
-      args[0] = CUR.GS.both_x_axis ? 0x4000 : 0; \
-      args[1] = CUR.GS.both_x_axis ? 0 : 0x4000; \
+      args[0] = CUR.FT_GS.both_x_axis ? 0x4000 : 0; \
+      args[1] = CUR.FT_GS.both_x_axis ? 0 : 0x4000; \
     }                                            \
     else                                         \
     {                                            \
-      args[0] = CUR.GS.freeVector.x;             \
-      args[1] = CUR.GS.freeVector.y;             \
+      args[0] = CUR.FT_GS.freeVector.x;             \
+      args[1] = CUR.FT_GS.freeVector.y;             \
     }
 #else
 #define DO_GFV                                   \
-    args[0] = CUR.GS.freeVector.x;               \
-    args[1] = CUR.GS.freeVector.y;
+    args[0] = CUR.FT_GS.freeVector.x;               \
+    args[1] = CUR.FT_GS.freeVector.y;
 #endif
 
 
 #define DO_SRP0                      \
-    CUR.GS.rp0 = (FT_UShort)args[0];
+    CUR.FT_GS.rp0 = (FT_UShort)args[0];
 
 
 #define DO_SRP1                      \
-    CUR.GS.rp1 = (FT_UShort)args[0];
+    CUR.FT_GS.rp1 = (FT_UShort)args[0];
 
 
 #define DO_SRP2                      \
-    CUR.GS.rp2 = (FT_UShort)args[0];
+    CUR.FT_GS.rp2 = (FT_UShort)args[0];
 
 
 #define DO_RTHG                                         \
-    CUR.GS.round_state = TT_Round_To_Half_Grid;         \
+    CUR.FT_GS.round_state = TT_Round_To_Half_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Half_Grid;
 
 
 #define DO_RTG                                     \
-    CUR.GS.round_state = TT_Round_To_Grid;         \
+    CUR.FT_GS.round_state = TT_Round_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Grid;
 
 
 #define DO_RTDG                                           \
-    CUR.GS.round_state = TT_Round_To_Double_Grid;         \
+    CUR.FT_GS.round_state = TT_Round_To_Double_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_To_Double_Grid;
 
 
 #define DO_RUTG                                       \
-    CUR.GS.round_state = TT_Round_Up_To_Grid;         \
+    CUR.FT_GS.round_state = TT_Round_Up_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_Up_To_Grid;
 
 
 #define DO_RDTG                                         \
-    CUR.GS.round_state = TT_Round_Down_To_Grid;         \
+    CUR.FT_GS.round_state = TT_Round_Down_To_Grid;         \
     CUR.func_round = (TT_Round_Func)Round_Down_To_Grid;
 
 
 #define DO_ROFF                                 \
-    CUR.GS.round_state = TT_Round_Off;          \
+    CUR.FT_GS.round_state = TT_Round_Off;          \
     CUR.func_round = (TT_Round_Func)Round_None;
 
 
 #define DO_SROUND                                \
     SET_SuperRound( 0x4000, args[0] );           \
-    CUR.GS.round_state = TT_Round_Super;         \
+    CUR.FT_GS.round_state = TT_Round_Super;         \
     CUR.func_round = (TT_Round_Func)Round_Super;
 
 
 #define DO_S45ROUND                                 \
     SET_SuperRound( 0x2D41, args[0] );              \
-    CUR.GS.round_state = TT_Round_Super_45;         \
+    CUR.FT_GS.round_state = TT_Round_Super_45;         \
     CUR.func_round = (TT_Round_Func)Round_Super_45;
 
 
@@ -2788,19 +2788,19 @@
     if ( args[0] < 0 )                 \
       CUR.error = TT_Err_Bad_Argument; \
     else                               \
-      CUR.GS.loop = args[0];
+      CUR.FT_GS.loop = args[0];
 
 
 #define DO_SMD                         \
-    CUR.GS.minimum_distance = args[0];
+    CUR.FT_GS.minimum_distance = args[0];
 
 
 #define DO_SCVTCI                                     \
-    CUR.GS.control_value_cutin = (FT_F26Dot6)args[0];
+    CUR.FT_GS.control_value_cutin = (FT_F26Dot6)args[0];
 
 
 #define DO_SSWCI                                     \
-    CUR.GS.single_width_cutin = (FT_F26Dot6)args[0];
+    CUR.FT_GS.single_width_cutin = (FT_F26Dot6)args[0];
 
 
     /* XXX: UNDOCUMENTED! or bug in the Windows engine?   */
@@ -2810,23 +2810,23 @@
     /*      units.                                        */
     /*                                                    */
 #define DO_SSW                                                 \
-    CUR.GS.single_width_value = (FT_F26Dot6)( args[0] >> 10 );
+    CUR.FT_GS.single_width_value = (FT_F26Dot6)( args[0] >> 10 );
 
 
 #define DO_FLIPON            \
-    CUR.GS.auto_flip = TRUE;
+    CUR.FT_GS.auto_flip = TRUE;
 
 
 #define DO_FLIPOFF            \
-    CUR.GS.auto_flip = FALSE;
+    CUR.FT_GS.auto_flip = FALSE;
 
 
 #define DO_SDB                             \
-    CUR.GS.delta_base = (FT_Short)args[0];
+    CUR.FT_GS.delta_base = (FT_Short)args[0];
 
 
 #define DO_SDS                              \
-    CUR.GS.delta_shift = (FT_Short)args[0];
+    CUR.FT_GS.delta_shift = (FT_Short)args[0];
 
 
 #define DO_MD  /* nothing */
@@ -4776,7 +4776,7 @@
 
     /* not part of the specs, but here for safety */
 
-    if ( CUR.GS.gep2 == 0 )
+    if ( CUR.FT_GS.gep2 == 0 )
       CUR.zp2.org[L] = CUR.zp2.cur[L];
   }
 
@@ -4889,7 +4889,7 @@
       A = -C;
     }
 
-    NORMalize( A, B, &CUR.GS.dualVector );
+    NORMalize( A, B, &CUR.FT_GS.dualVector );
 
     {
       FT_Vector*  v1 = CUR.zp1.cur + p2;
@@ -4907,7 +4907,7 @@
       A = -C;
     }
 
-    NORMalize( A, B, &CUR.GS.projVector );
+    NORMalize( A, B, &CUR.FT_GS.projVector );
 
     GUESS_VECTOR( freeVector );
 
@@ -4940,7 +4940,7 @@
       return;
     }
 
-    CUR.GS.gep0 = (FT_UShort)args[0];
+    CUR.FT_GS.gep0 = (FT_UShort)args[0];
   }
 
 
@@ -4969,7 +4969,7 @@
       return;
     }
 
-    CUR.GS.gep1 = (FT_UShort)args[0];
+    CUR.FT_GS.gep1 = (FT_UShort)args[0];
   }
 
 
@@ -4998,7 +4998,7 @@
       return;
     }
 
-    CUR.GS.gep2 = (FT_UShort)args[0];
+    CUR.FT_GS.gep2 = (FT_UShort)args[0];
   }
 
 
@@ -5030,9 +5030,9 @@
     CUR.zp1 = CUR.zp0;
     CUR.zp2 = CUR.zp0;
 
-    CUR.GS.gep0 = (FT_UShort)args[0];
-    CUR.GS.gep1 = (FT_UShort)args[0];
-    CUR.GS.gep2 = (FT_UShort)args[0];
+    CUR.FT_GS.gep0 = (FT_UShort)args[0];
+    CUR.FT_GS.gep1 = (FT_UShort)args[0];
+    CUR.FT_GS.gep2 = (FT_UShort)args[0];
   }
 
 
@@ -5061,8 +5061,8 @@
     if ( L != 0 )
         L = K;
 
-    CUR.GS.instruct_control = FT_BOOL(
-      ( (FT_Byte)CUR.GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );
+    CUR.FT_GS.instruct_control = FT_BOOL(
+      ( (FT_Byte)CUR.FT_GS.instruct_control & ~(FT_Byte)K ) | (FT_Byte)L );
   }
 
 
@@ -5083,12 +5083,12 @@
 
     if ( A == 0xFF )
     {
-      CUR.GS.scan_control = TRUE;
+      CUR.FT_GS.scan_control = TRUE;
       return;
     }
     else if ( A == 0 )
     {
-      CUR.GS.scan_control = FALSE;
+      CUR.FT_GS.scan_control = FALSE;
       return;
     }
 
@@ -5096,25 +5096,25 @@
 
 #if 0
     if ( ( args[0] & 0x100 ) != 0 && CUR.metrics.pointSize <= A )
-      CUR.GS.scan_control = TRUE;
+      CUR.FT_GS.scan_control = TRUE;
 #endif
 
     if ( ( args[0] & 0x200 ) != 0 && CUR.tt_metrics.rotated )
-      CUR.GS.scan_control = TRUE;
+      CUR.FT_GS.scan_control = TRUE;
 
     if ( ( args[0] & 0x400 ) != 0 && CUR.tt_metrics.stretched )
-      CUR.GS.scan_control = TRUE;
+      CUR.FT_GS.scan_control = TRUE;
 
 #if 0
     if ( ( args[0] & 0x800 ) != 0 && CUR.metrics.pointSize > A )
-      CUR.GS.scan_control = FALSE;
+      CUR.FT_GS.scan_control = FALSE;
 #endif
 
     if ( ( args[0] & 0x1000 ) != 0 && CUR.tt_metrics.rotated )
-      CUR.GS.scan_control = FALSE;
+      CUR.FT_GS.scan_control = FALSE;
 
     if ( ( args[0] & 0x2000 ) != 0 && CUR.tt_metrics.stretched )
-      CUR.GS.scan_control = FALSE;
+      CUR.FT_GS.scan_control = FALSE;
   }
 
 
@@ -5135,7 +5135,7 @@
       if ( args[0] == 3 )
         args[0] = 2;
 
-      CUR.GS.scan_type = (FT_Int)args[0];
+      CUR.FT_GS.scan_type = (FT_Int)args[0];
     }
   }
 
@@ -5163,13 +5163,13 @@
     FT_UNUSED_ARG;
 
 
-    if ( CUR.top < CUR.GS.loop )
+    if ( CUR.top < CUR.FT_GS.loop )
     {
       CUR.error = TT_Err_Too_Few_Arguments;
       return;
     }
 
-    while ( CUR.GS.loop > 0 )
+    while ( CUR.FT_GS.loop > 0 )
     {
       CUR.args--;
 
@@ -5186,10 +5186,10 @@
       else
         CUR.pts.tags[point] ^= FT_CURVE_TAG_ON;
 
-      CUR.GS.loop--;
+      CUR.FT_GS.loop--;
     }
 
-    CUR.GS.loop = 1;
+    CUR.FT_GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
@@ -5264,12 +5264,12 @@
     if ( CUR.opcode & 1 )
     {
       zp = CUR.zp0;
-      p  = CUR.GS.rp1;
+      p  = CUR.FT_GS.rp1;
     }
     else
     {
       zp = CUR.zp1;
-      p  = CUR.GS.rp2;
+      p  = CUR.FT_GS.rp2;
     }
 
     if ( BOUNDS( p, zp.n_points ) )
@@ -5288,7 +5288,7 @@
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
-      if ( CUR.GS.both_x_axis )
+      if ( CUR.FT_GS.both_x_axis )
       {
         *x = d;
         *y = 0;
@@ -5303,10 +5303,10 @@
 #endif
     {
       *x = TT_MULDIV( d,
-                      (FT_Long)CUR.GS.freeVector.x * 0x10000L,
+                      (FT_Long)CUR.FT_GS.freeVector.x * 0x10000L,
                       CUR.F_dot_P );
       *y = TT_MULDIV( d,
-                      (FT_Long)CUR.GS.freeVector.y * 0x10000L,
+                      (FT_Long)CUR.FT_GS.freeVector.y * 0x10000L,
                       CUR.F_dot_P );
     }
 
@@ -5323,7 +5323,7 @@
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
-      if ( CUR.GS.both_x_axis )
+      if ( CUR.FT_GS.both_x_axis )
       {
         CUR.zp2.cur[point].x += dx;
         if ( touch )
@@ -5339,14 +5339,14 @@
     }
 #endif
 
-    if ( CUR.GS.freeVector.x != 0 )
+    if ( CUR.FT_GS.freeVector.x != 0 )
     {
       CUR.zp2.cur[point].x += dx;
       if ( touch )
         CUR.zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
     }
 
-    if ( CUR.GS.freeVector.y != 0 )
+    if ( CUR.FT_GS.freeVector.y != 0 )
     {
       CUR.zp2.cur[point].y += dy;
       if ( touch )
@@ -5374,7 +5374,7 @@
     FT_UNUSED_ARG;
 
 
-    if ( CUR.top < CUR.GS.loop )
+    if ( CUR.top < CUR.FT_GS.loop )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
@@ -5383,7 +5383,7 @@
     if ( COMPUTE_Point_Displacement( &dx, &dy, &zp, &refp ) )
       return;
 
-    while ( CUR.GS.loop > 0 )
+    while ( CUR.FT_GS.loop > 0 )
     {
       CUR.args--;
       point = (FT_UShort)CUR.stack[CUR.args];
@@ -5400,10 +5400,10 @@
         /* XXX: UNDOCUMENTED! SHP touches the points */
         MOVE_Zp2_Point( point, dx, dy, TRUE );
 
-      CUR.GS.loop--;
+      CUR.FT_GS.loop--;
     }
 
-    CUR.GS.loop = 1;
+    CUR.FT_GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
@@ -5497,9 +5497,9 @@
     /*      Twilight zone has no contours, so use `n_points'.   */
     /*      Normal zone's `n_points' includes phantoms, so must */
     /*      use end of last contour.                            */
-    if ( CUR.GS.gep2 == 0 && CUR.zp2.n_points > 0 )
+    if ( CUR.FT_GS.gep2 == 0 && CUR.zp2.n_points > 0 )
       last_point = (FT_UShort)( CUR.zp2.n_points - 1 );
-    else if ( CUR.GS.gep2 == 1 && CUR.zp2.n_contours > 0 )
+    else if ( CUR.FT_GS.gep2 == 1 && CUR.zp2.n_contours > 0 )
       last_point = (FT_UShort)( CUR.zp2.contours[CUR.zp2.n_contours - 1] );
     else
       last_point = 0;
@@ -5526,7 +5526,7 @@
     FT_UShort   point;
 
 
-    if ( CUR.top < CUR.GS.loop + 1 )
+    if ( CUR.top < CUR.FT_GS.loop + 1 )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
@@ -5535,7 +5535,7 @@
 #ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING
     if ( CUR.face->unpatented_hinting )
     {
-      if ( CUR.GS.both_x_axis )
+      if ( CUR.FT_GS.both_x_axis )
       {
         dx = TT_MulFix14( args[0], 0x4000 );
         dy = 0;
@@ -5549,11 +5549,11 @@
     else
 #endif
     {
-      dx = TT_MulFix14( args[0], CUR.GS.freeVector.x );
-      dy = TT_MulFix14( args[0], CUR.GS.freeVector.y );
+      dx = TT_MulFix14( args[0], CUR.FT_GS.freeVector.x );
+      dy = TT_MulFix14( args[0], CUR.FT_GS.freeVector.y );
     }
 
-    while ( CUR.GS.loop > 0 )
+    while ( CUR.FT_GS.loop > 0 )
     {
       CUR.args--;
 
@@ -5570,10 +5570,10 @@
       else
         MOVE_Zp2_Point( point, dx, dy, TRUE );
 
-      CUR.GS.loop--;
+      CUR.FT_GS.loop--;
     }
 
-    CUR.GS.loop = 1;
+    CUR.FT_GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
@@ -5594,7 +5594,7 @@
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
-         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
+         BOUNDS( CUR.FT_GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
@@ -5602,24 +5602,24 @@
     }
 
     /* XXX: UNDOCUMENTED! behaviour */
-    if ( CUR.GS.gep1 == 0 )   /* if the point that is to be moved */
+    if ( CUR.FT_GS.gep1 == 0 )   /* if the point that is to be moved */
                               /* is in twilight zone              */
     {
-      CUR.zp1.org[point] = CUR.zp0.org[CUR.GS.rp0];
+      CUR.zp1.org[point] = CUR.zp0.org[CUR.FT_GS.rp0];
       CUR_Func_move_orig( &CUR.zp1, point, args[1] );
       CUR.zp1.cur[point] = CUR.zp1.org[point];
     }
 
     distance = CUR_Func_project( CUR.zp1.cur + point,
-                                 CUR.zp0.cur + CUR.GS.rp0 );
+                                 CUR.zp0.cur + CUR.FT_GS.rp0 );
 
     CUR_Func_move( &CUR.zp1, point, args[1] - distance );
 
-    CUR.GS.rp1 = CUR.GS.rp0;
-    CUR.GS.rp2 = point;
+    CUR.FT_GS.rp1 = CUR.FT_GS.rp0;
+    CUR.FT_GS.rp2 = point;
 
     if ( ( CUR.opcode & 1 ) != 0 )
-      CUR.GS.rp0 = point;
+      CUR.FT_GS.rp0 = point;
   }
 
 
@@ -5659,8 +5659,8 @@
 
     CUR_Func_move( &CUR.zp0, point, distance );
 
-    CUR.GS.rp0 = point;
-    CUR.GS.rp1 = point;
+    CUR.FT_GS.rp0 = point;
+    CUR.FT_GS.rp1 = point;
   }
 
 
@@ -5714,10 +5714,10 @@
 
     distance = CUR_Func_read_cvt( cvtEntry );
 
-    if ( CUR.GS.gep0 == 0 )   /* If in twilight zone */
+    if ( CUR.FT_GS.gep0 == 0 )   /* If in twilight zone */
     {
-      CUR.zp0.org[point].x = TT_MulFix14( distance, CUR.GS.freeVector.x );
-      CUR.zp0.org[point].y = TT_MulFix14( distance, CUR.GS.freeVector.y ),
+      CUR.zp0.org[point].x = TT_MulFix14( distance, CUR.FT_GS.freeVector.x );
+      CUR.zp0.org[point].y = TT_MulFix14( distance, CUR.FT_GS.freeVector.y ),
       CUR.zp0.cur[point]   = CUR.zp0.org[point];
     }
 
@@ -5725,7 +5725,7 @@
 
     if ( ( CUR.opcode & 1 ) != 0 )   /* rounding and control cutin flag */
     {
-      if ( FT_ABS( distance - org_dist ) > CUR.GS.control_value_cutin )
+      if ( FT_ABS( distance - org_dist ) > CUR.FT_GS.control_value_cutin )
         distance = org_dist;
 
       distance = CUR_Func_round( distance, CUR.tt_metrics.compensations[0] );
@@ -5733,8 +5733,8 @@
 
     CUR_Func_move( &CUR.zp0, point, distance - org_dist );
 
-    CUR.GS.rp0 = point;
-    CUR.GS.rp1 = point;
+    CUR.FT_GS.rp0 = point;
+    CUR.FT_GS.rp1 = point;
   }
 
 
@@ -5754,7 +5754,7 @@
     point = (FT_UShort)args[0];
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
-         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
+         BOUNDS( CUR.FT_GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
@@ -5766,10 +5766,10 @@
 
     /* XXX: UNDOCUMENTED: twilight zone special case */
 
-    if ( CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 )
+    if ( CUR.FT_GS.gep0 == 0 || CUR.FT_GS.gep1 == 0 )
     {
       FT_Vector*  vec1 = &CUR.zp1.org[point];
-      FT_Vector*  vec2 = &CUR.zp0.org[CUR.GS.rp0];
+      FT_Vector*  vec2 = &CUR.zp0.org[CUR.FT_GS.rp0];
 
 
       org_dist = CUR_Func_dualproj( vec1, vec2 );
@@ -5777,7 +5777,7 @@
     else
     {
       FT_Vector*  vec1 = &CUR.zp1.orus[point];
-      FT_Vector*  vec2 = &CUR.zp0.orus[CUR.GS.rp0];
+      FT_Vector*  vec2 = &CUR.zp0.orus[CUR.FT_GS.rp0];
 
 
       if ( CUR.metrics.x_scale == CUR.metrics.y_scale )
@@ -5800,13 +5800,13 @@
 
     /* single width cut-in test */
 
-    if ( FT_ABS( org_dist - CUR.GS.single_width_value ) <
-         CUR.GS.single_width_cutin )
+    if ( FT_ABS( org_dist - CUR.FT_GS.single_width_value ) <
+         CUR.FT_GS.single_width_cutin )
     {
       if ( org_dist >= 0 )
-        org_dist = CUR.GS.single_width_value;
+        org_dist = CUR.FT_GS.single_width_value;
       else
-        org_dist = -CUR.GS.single_width_value;
+        org_dist = -CUR.FT_GS.single_width_value;
     }
 
     /* round flag */
@@ -5826,28 +5826,28 @@
     {
       if ( org_dist >= 0 )
       {
-        if ( distance < CUR.GS.minimum_distance )
-          distance = CUR.GS.minimum_distance;
+        if ( distance < CUR.FT_GS.minimum_distance )
+          distance = CUR.FT_GS.minimum_distance;
       }
       else
       {
-        if ( distance > -CUR.GS.minimum_distance )
-          distance = -CUR.GS.minimum_distance;
+        if ( distance > -CUR.FT_GS.minimum_distance )
+          distance = -CUR.FT_GS.minimum_distance;
       }
     }
 
     /* now move the point */
 
     org_dist = CUR_Func_project( CUR.zp1.cur + point,
-                                 CUR.zp0.cur + CUR.GS.rp0 );
+                                 CUR.zp0.cur + CUR.FT_GS.rp0 );
 
     CUR_Func_move( &CUR.zp1, point, distance - org_dist );
 
-    CUR.GS.rp1 = CUR.GS.rp0;
-    CUR.GS.rp2 = point;
+    CUR.FT_GS.rp1 = CUR.FT_GS.rp0;
+    CUR.FT_GS.rp2 = point;
 
     if ( ( CUR.opcode & 16 ) != 0 )
-      CUR.GS.rp0 = point;
+      CUR.FT_GS.rp0 = point;
   }
 
 
@@ -5876,7 +5876,7 @@
 
     if ( BOUNDS( point,      CUR.zp1.n_points ) ||
          BOUNDS( cvtEntry,   CUR.cvtSize + 1 )  ||
-         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
+         BOUNDS( CUR.FT_GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
@@ -5890,36 +5890,36 @@
 
     /* single width test */
 
-    if ( FT_ABS( cvt_dist - CUR.GS.single_width_value ) <
-         CUR.GS.single_width_cutin )
+    if ( FT_ABS( cvt_dist - CUR.FT_GS.single_width_value ) <
+         CUR.FT_GS.single_width_cutin )
     {
       if ( cvt_dist >= 0 )
-        cvt_dist =  CUR.GS.single_width_value;
+        cvt_dist =  CUR.FT_GS.single_width_value;
       else
-        cvt_dist = -CUR.GS.single_width_value;
+        cvt_dist = -CUR.FT_GS.single_width_value;
     }
 
     /* XXX: UNDOCUMENTED! -- twilight zone */
 
-    if ( CUR.GS.gep1 == 0 )
+    if ( CUR.FT_GS.gep1 == 0 )
     {
-      CUR.zp1.org[point].x = CUR.zp0.org[CUR.GS.rp0].x +
-                             TT_MulFix14( cvt_dist, CUR.GS.freeVector.x );
+      CUR.zp1.org[point].x = CUR.zp0.org[CUR.FT_GS.rp0].x +
+                             TT_MulFix14( cvt_dist, CUR.FT_GS.freeVector.x );
 
-      CUR.zp1.org[point].y = CUR.zp0.org[CUR.GS.rp0].y +
-                             TT_MulFix14( cvt_dist, CUR.GS.freeVector.y );
+      CUR.zp1.org[point].y = CUR.zp0.org[CUR.FT_GS.rp0].y +
+                             TT_MulFix14( cvt_dist, CUR.FT_GS.freeVector.y );
 
       CUR.zp1.cur[point] = CUR.zp0.cur[point];
     }
 
     org_dist = CUR_Func_dualproj( &CUR.zp1.org[point],
-                                  &CUR.zp0.org[CUR.GS.rp0] );
+                                  &CUR.zp0.org[CUR.FT_GS.rp0] );
     cur_dist = CUR_Func_project ( &CUR.zp1.cur[point],
-                                  &CUR.zp0.cur[CUR.GS.rp0] );
+                                  &CUR.zp0.cur[CUR.FT_GS.rp0] );
 
     /* auto-flip test */
 
-    if ( CUR.GS.auto_flip )
+    if ( CUR.FT_GS.auto_flip )
     {
       if ( ( org_dist ^ cvt_dist ) < 0 )
         cvt_dist = -cvt_dist;
@@ -5932,8 +5932,8 @@
       /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
       /*      refer to the same zone.                                  */
 
-      if ( CUR.GS.gep0 == CUR.GS.gep1 )
-        if ( FT_ABS( cvt_dist - org_dist ) >= CUR.GS.control_value_cutin )
+      if ( CUR.FT_GS.gep0 == CUR.FT_GS.gep1 )
+        if ( FT_ABS( cvt_dist - org_dist ) >= CUR.FT_GS.control_value_cutin )
           cvt_dist = org_dist;
 
       distance = CUR_Func_round(
@@ -5951,25 +5951,25 @@
     {
       if ( org_dist >= 0 )
       {
-        if ( distance < CUR.GS.minimum_distance )
-          distance = CUR.GS.minimum_distance;
+        if ( distance < CUR.FT_GS.minimum_distance )
+          distance = CUR.FT_GS.minimum_distance;
       }
       else
       {
-        if ( distance > -CUR.GS.minimum_distance )
-          distance = -CUR.GS.minimum_distance;
+        if ( distance > -CUR.FT_GS.minimum_distance )
+          distance = -CUR.FT_GS.minimum_distance;
       }
     }
 
     CUR_Func_move( &CUR.zp1, point, distance - cur_dist );
 
-    CUR.GS.rp1 = CUR.GS.rp0;
+    CUR.FT_GS.rp1 = CUR.FT_GS.rp0;
 
     if ( ( CUR.opcode & 16 ) != 0 )
-      CUR.GS.rp0 = point;
+      CUR.FT_GS.rp0 = point;
 
     /* XXX: UNDOCUMENTED! */
-    CUR.GS.rp2 = point;
+    CUR.FT_GS.rp2 = point;
   }
 
 
@@ -5988,15 +5988,15 @@
     FT_UNUSED_ARG;
 
 
-    if ( CUR.top < CUR.GS.loop ||
-         BOUNDS( CUR.GS.rp0, CUR.zp0.n_points ) )
+    if ( CUR.top < CUR.FT_GS.loop ||
+         BOUNDS( CUR.FT_GS.rp0, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
       return;
     }
 
-    while ( CUR.GS.loop > 0 )
+    while ( CUR.FT_GS.loop > 0 )
     {
       CUR.args--;
 
@@ -6013,15 +6013,15 @@
       else
       {
         distance = CUR_Func_project( CUR.zp1.cur + point,
-                                     CUR.zp0.cur + CUR.GS.rp0 );
+                                     CUR.zp0.cur + CUR.FT_GS.rp0 );
 
         CUR_Func_move( &CUR.zp1, point, -distance );
       }
 
-      CUR.GS.loop--;
+      CUR.FT_GS.loop--;
     }
 
-    CUR.GS.loop = 1;
+    CUR.FT_GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
@@ -6160,7 +6160,7 @@
     FT_UNUSED_ARG;
 
 
-    if ( CUR.top < CUR.GS.loop )
+    if ( CUR.top < CUR.FT_GS.loop )
     {
       CUR.error = TT_Err_Invalid_Reference;
       return;
@@ -6171,9 +6171,9 @@
      * Otherwise, by definition, the value of CUR.twilight.orus[n] is (0,0),
      * for every n.
      */
-    twilight = CUR.GS.gep0 == 0 || CUR.GS.gep1 == 0 || CUR.GS.gep2 == 0;
+    twilight = CUR.FT_GS.gep0 == 0 || CUR.FT_GS.gep1 == 0 || CUR.FT_GS.gep2 == 0;
 
-    if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) )
+    if ( BOUNDS( CUR.FT_GS.rp1, CUR.zp0.n_points ) )
     {
       if ( CUR.pedantic_hinting )
         CUR.error = TT_Err_Invalid_Reference;
@@ -6181,18 +6181,18 @@
     }
 
     if ( twilight )
-      orus_base = &CUR.zp0.org[CUR.GS.rp1];
+      orus_base = &CUR.zp0.org[CUR.FT_GS.rp1];
     else
-      orus_base = &CUR.zp0.orus[CUR.GS.rp1];
+      orus_base = &CUR.zp0.orus[CUR.FT_GS.rp1];
 
-    cur_base = &CUR.zp0.cur[CUR.GS.rp1];
+    cur_base = &CUR.zp0.cur[CUR.FT_GS.rp1];
 
     /* XXX: There are some glyphs in some braindead but popular */
     /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
     /*      calling IP[] with bad values of rp[12].             */
     /*      Do something sane when this odd thing happens.      */
-    if ( BOUNDS( CUR.GS.rp1, CUR.zp0.n_points ) ||
-         BOUNDS( CUR.GS.rp2, CUR.zp1.n_points ) )
+    if ( BOUNDS( CUR.FT_GS.rp1, CUR.zp0.n_points ) ||
+         BOUNDS( CUR.FT_GS.rp2, CUR.zp1.n_points ) )
     {
       old_range = 0;
       cur_range = 0;
@@ -6200,16 +6200,16 @@
     else
     {
       if ( twilight )
-        old_range = CUR_Func_dualproj( &CUR.zp1.org[CUR.GS.rp2],
+        old_range = CUR_Func_dualproj( &CUR.zp1.org[CUR.FT_GS.rp2],
                                        orus_base );
       else
-        old_range = CUR_Func_dualproj( &CUR.zp1.orus[CUR.GS.rp2],
+        old_range = CUR_Func_dualproj( &CUR.zp1.orus[CUR.FT_GS.rp2],
                                        orus_base );
 
-      cur_range = CUR_Func_project ( &CUR.zp1.cur[CUR.GS.rp2], cur_base );
+      cur_range = CUR_Func_project ( &CUR.zp1.cur[CUR.FT_GS.rp2], cur_base );
     }
 
-    for ( ; CUR.GS.loop > 0; --CUR.GS.loop )
+    for ( ; CUR.FT_GS.loop > 0; --CUR.FT_GS.loop )
     {
       FT_UInt     point = (FT_UInt)CUR.stack[--CUR.args];
       FT_F26Dot6  org_dist, cur_dist, new_dist;
@@ -6242,7 +6242,7 @@
 
       CUR_Func_move( &CUR.zp2, (FT_UShort)point, new_dist - cur_dist );
     }
-    CUR.GS.loop = 1;
+    CUR.FT_GS.loop = 1;
     CUR.new_top = CUR.args;
   }
 
@@ -6271,10 +6271,10 @@
 
     mask = 0xFF;
 
-    if ( CUR.GS.freeVector.x != 0 )
+    if ( CUR.FT_GS.freeVector.x != 0 )
       mask &= ~FT_CURVE_TAG_TOUCH_X;
 
-    if ( CUR.GS.freeVector.y != 0 )
+    if ( CUR.FT_GS.freeVector.y != 0 )
       mask &= ~FT_CURVE_TAG_TOUCH_Y;
 
     CUR.zp0.tags[point] &= mask;
@@ -6585,14 +6585,14 @@
           break;
         }
 
-        C += CUR.GS.delta_base;
+        C += CUR.FT_GS.delta_base;
 
         if ( CURRENT_Ppem() == (FT_Long)C )
         {
           B = ( (FT_ULong)B & 0xF ) - 8;
           if ( B >= 0 )
             B++;
-          B = B * 64 / ( 1L << CUR.GS.delta_shift );
+          B = B * 64 / ( 1L << CUR.FT_GS.delta_shift );
 
           CUR_Func_move( &CUR.zp0, A, B );
         }
@@ -6680,14 +6680,14 @@
           break;
         }
 
-        C += CUR.GS.delta_base;
+        C += CUR.FT_GS.delta_base;
 
         if ( CURRENT_Ppem() == (FT_Long)C )
         {
           B = ( (FT_ULong)B & 0xF ) - 8;
           if ( B >= 0 )
             B++;
-          B = B * 64 / ( 1L << CUR.GS.delta_shift );
+          B = B * 64 / ( 1L << CUR.FT_GS.delta_shift );
 
           CUR_Func_move_cvt( A, B );
         }
@@ -7127,7 +7127,7 @@
     }
 
     COMPUTE_Funcs();
-    COMPUTE_Round( (FT_Byte)exc->GS.round_state );
+    COMPUTE_Round( (FT_Byte)exc->FT_GS.round_state );
 
     do
     {
@@ -7197,11 +7197,11 @@
 
             if ( opcode < 4 )
             {
-              CUR.GS.projVector.x = AA;
-              CUR.GS.projVector.y = BB;
+              CUR.FT_GS.projVector.x = AA;
+              CUR.FT_GS.projVector.y = BB;
 
-              CUR.GS.dualVector.x = AA;
-              CUR.GS.dualVector.y = BB;
+              CUR.FT_GS.dualVector.x = AA;
+              CUR.FT_GS.dualVector.y = BB;
             }
             else
             {
@@ -7210,8 +7210,8 @@
 
             if ( ( opcode & 2 ) == 0 )
             {
-              CUR.GS.freeVector.x = AA;
-              CUR.GS.freeVector.y = BB;
+              CUR.FT_GS.freeVector.x = AA;
+              CUR.FT_GS.freeVector.y = BB;
             }
             else
             {
