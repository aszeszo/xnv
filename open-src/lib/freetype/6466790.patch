Fixes for Sun CR 6466790, which includes:

CVE-2006-0747: Integer underflow in Freetype before 2.2 allows remote
attackers to cause a denial of service (crash) via a font file with an
odd number of blue values, which causes the underflow when
decrementing by 2 in a context that assumes an even number of values.

CVE-2006-1861: Multiple integer overflows in FreeType before 2.2 allow
remote attackers to cause a denial of service (crash) and possibly
execute arbitrary code via attack vectors related to (1) bdf/bdflib.c,
(2) sfnt/ttcmap.c, (3) cff/cffgload.c, and (4) the read_lwfn function
and a crafted LWFN file in base/ftmac.c. NOTE: item 4 was originally
identified by CVE-2006-2493.

CVE-2006-3467: Integer overflow in FreeType before 2.2 allows remote
attackers to cause a denial of service (crash) and possibly execute
arbitrary code via a crafted PCF file, as demonstrated by the Red Hat
bad1.pcf test file, due to a partial fix of CVE-2006-1861.


diff -urp -x '*~' include/freetype/fterrdef.h include/freetype/fterrdef.h
--- include/freetype/fterrdef.h	2006-09-01 15:48:49.349090000 -0700
+++ include/freetype/fterrdef.h	2006-09-01 15:48:51.171873000 -0700
@@ -228,6 +228,8 @@
                 "`ENCODING' field missing" )
   FT_ERRORDEF_( Missing_Bbx_Field,                           0xB6, \
                 "`BBX' field missing" )
+  FT_ERRORDEF_( Bbx_Too_Big,                                 0xB7, \
+                "`BBX' too big" )
 
 
 /* END */
diff -urp -x '*~' src/bdf/bdflib.c src/bdf/bdflib.c
--- src/bdf/bdflib.c	2005-05-21 10:19:52.000000000 -0700
+++ src/bdf/bdflib.c	2006-09-01 15:48:51.234663000 -0700
@@ -1092,6 +1092,7 @@
 #define ERRMSG1  "[line %ld] Missing \"%s\" line.\n"
 #define ERRMSG2  "[line %ld] Font header corrupted or missing fields.\n"
 #define ERRMSG3  "[line %ld] Font glyphs corrupted or missing fields.\n"
+#define ERRMSG4  "[line %ld] BBX too big.\n"
 
 
   static FT_Error
@@ -1561,6 +1562,14 @@
 
       p->glyph_enc = _bdf_atol( p->list.field[1], 0, 10 );
 
+      /* Check that the encoding is in the range [0,65536] because        */
+      /* otherwise p->have (a bitmap with static size) overflows.         */
+      if ( p->glyph_enc >= sizeof(p->have)*8 )
+      {
+        error = BDF_Err_Invalid_File_Format;
+        goto Exit;
+      }
+
       /* Check to see whether this encoding has already been encountered. */
       /* If it has then change it to unencoded so it gets added if        */
       /* indicated.                                                       */
@@ -1805,6 +1814,9 @@
     /* And finally, gather up the bitmap. */
     if ( ft_memcmp( line, "BITMAP", 6 ) == 0 )
     {
+      unsigned long  bitmap_size;
+
+
       if ( !( p->flags & _BDF_BBX ) )
       {
         /* Missing BBX field. */
@@ -1815,7 +1827,16 @@
 
       /* Allocate enough space for the bitmap. */
       glyph->bpr   = ( glyph->bbx.width * p->font->bpp + 7 ) >> 3;
-      glyph->bytes = (unsigned short)( glyph->bpr * glyph->bbx.height );
+
+      bitmap_size = glyph->bpr * glyph->bbx.height;
+      if ( bitmap_size > 0xFFFFU )
+      {
+        FT_ERROR(( "_bdf_parse_glyphs: " ERRMSG4, lineno ));
+        error = BDF_Err_Bbx_Too_Big;
+        goto Exit;
+      }
+      else
+        glyph->bytes = (unsigned short)bitmap_size;
 
       if ( FT_NEW_ARRAY( glyph->bitmap, glyph->bytes ) )
         goto Exit;
diff -urp -x '*~' src/cff/cffgload.c src/cff/cffgload.c
--- src/cff/cffgload.c	2006-09-01 15:48:49.387149000 -0700
+++ src/cff/cffgload.c	2006-09-01 15:48:51.180965000 -0700
@@ -2287,7 +2287,7 @@
   FT_LOCAL_DEF( FT_Error )
   cff_slot_load( CFF_GlyphSlot  glyph,
                  CFF_Size       size,
-                 FT_Int         glyph_index,
+                 FT_UInt        glyph_index,
                  FT_Int32       load_flags )
   {
     FT_Error      error;
@@ -2332,8 +2332,8 @@
 
 
         error = sfnt->load_sbit_image( face,
-                                       (FT_ULong)size->strike_index,
-                                       (FT_UInt)glyph_index,
+                                       size->strike_index,
+                                       glyph_index,
                                        (FT_Int)load_flags,
                                        stream,
                                        &glyph->root.bitmap,
@@ -2396,7 +2396,12 @@
       /* subsetted font, glyph_indices and CIDs are identical, though */
       if ( cff->top_font.font_dict.cid_registry != 0xFFFFU &&
            cff->charset.cids )
-        glyph_index = cff->charset.cids[glyph_index];
+      {
+        if ( glyph_index < cff->charset.max_cid )
+          glyph_index = cff->charset.cids[glyph_index];
+        else
+          glyph_index = 0;
+      }
 
       cff_decoder_init( &decoder, face, size, glyph, hinting,
                         FT_LOAD_TARGET_MODE( load_flags ) );
diff -urp -x '*~' src/cff/cffgload.h src/cff/cffgload.h
--- src/cff/cffgload.h	2004-05-13 14:59:17.000000000 -0700
+++ src/cff/cffgload.h	2006-09-01 15:48:51.182161000 -0700
@@ -4,7 +4,7 @@
 /*                                                                         */
 /*    OpenType Glyph Loader (specification).                               */
 /*                                                                         */
-/*  Copyright 1996-2001, 2002, 2003, 2004 by                               */
+/*  Copyright 1996-2001, 2002, 2003, 2004, 2006 by                         */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -196,7 +196,7 @@ FT_BEGIN_HEADER
   FT_LOCAL( FT_Error )
   cff_slot_load( CFF_GlyphSlot  glyph,
                  CFF_Size       size,
-                 FT_Int         glyph_index,
+                 FT_UInt        glyph_index,
                  FT_Int32       load_flags );
 
 
diff -urp -x '*~' src/cff/cffload.c src/cff/cffload.c
--- src/cff/cffload.c	2006-09-01 15:48:49.391174000 -0700
+++ src/cff/cffload.c	2006-09-01 15:48:51.184145000 -0700
@@ -1235,7 +1235,7 @@
       }
 
       /* access element */
-      if ( off1 )
+      if ( off1 && off2 > off1 )
       {
         *pbyte_len = off2 - off1;
 
@@ -1688,6 +1688,8 @@
 
       for ( i = 0; i < num_glyphs; i++ )
         charset->cids[charset->sids[i]] = (FT_UShort)i;
+
+      charset->max_cid = max_cid;
     }
 
   Exit:
@@ -2040,6 +2042,9 @@
       FT_FRAME_EXIT();
       if ( error )
         goto Exit;
+
+      /* ensure that 'num_blue_values' is even */
+      priv->num_blue_values &= ~1;
     }
 
     /* read the local subrs, if any */
diff -urp -x '*~' src/cff/cfftypes.h src/cff/cfftypes.h
--- src/cff/cfftypes.h	2003-12-19 23:30:05.000000000 -0800
+++ src/cff/cfftypes.h	2006-09-01 15:48:51.231959000 -0700
@@ -5,7 +5,7 @@
 /*    Basic OpenType/CFF type definitions and interface (specification     */
 /*    only).                                                               */
 /*                                                                         */
-/*  Copyright 1996-2001, 2002, 2003 by                                     */
+/*  Copyright 1996-2001, 2002, 2003, 2006 by                               */
 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
 /*                                                                         */
 /*  This file is part of the FreeType project, and may only be used,       */
@@ -84,6 +84,7 @@ FT_BEGIN_HEADER
     FT_UShort*  sids;
     FT_UShort*  cids;       /* the inverse mapping of `sids'; only needed */
                             /* for CID-keyed fonts                        */
+    FT_UInt     max_cid;
   } CFF_CharsetRec, *CFF_Charset;
 
 
diff -urp -x '*~' src/pcf/pcfread.c src/pcf/pcfread.c
--- src/pcf/pcfread.c	2006-09-01 15:48:49.339986000 -0700
+++ src/pcf/pcfread.c	2006-09-01 15:48:51.236686000 -0700
@@ -439,6 +439,14 @@ THE SOFTWARE.
 
     for ( i = 0; i < nprops; i++ )
     {
+      /* 2006:0500 (mbarnes) - Detect invalid string length.
+       * XXX Is this is best error code to return? */
+      if ( props[i].name < 0 )
+      {
+        error = FT_Err_Invalid_File_Format;
+        goto Bail;
+      }
+
       /* XXX: make atom */
       if ( FT_NEW_ARRAY( properties[i].name,
                          ft_strlen( strings + props[i].name ) + 1 ) )
@@ -451,6 +459,14 @@ THE SOFTWARE.
 
       if ( props[i].isString )
       {
+	/* 2006:0500 (mbarnes) - Detect invalid string length.
+         * XXX Is this the best error code to return? */
+        if ( props[i].value < 0 )
+        {
+          error = FT_Err_Invalid_File_Format;
+          goto Bail;
+        }
+
         if ( FT_NEW_ARRAY( properties[i].value.atom,
                            ft_strlen( strings + props[i].value ) + 1 ) )
           goto Bail;
diff -urp -x '*~' src/pshinter/pshglob.c src/pshinter/pshglob.c
--- src/pshinter/pshglob.c	2004-04-01 23:13:53.000000000 -0800
+++ src/pshinter/pshglob.c	2006-09-01 15:48:51.158986000 -0700
@@ -150,7 +150,7 @@
     FT_UNUSED( target );
 
 
-    for ( ; read_count > 0; read_count -= 2 )
+    for ( ; read_count > 1; read_count -= 2 )
     {
       FT_Int         reference, delta;
       FT_UInt        count;
diff -urp -x '*~' src/sfnt/ttcmap.c src/sfnt/ttcmap.c
--- src/sfnt/ttcmap.c	2005-05-11 07:37:40.000000000 -0700
+++ src/sfnt/ttcmap.c	2006-09-01 15:48:51.177575000 -0700
@@ -2145,6 +2145,7 @@
       offset              = TT_NEXT_ULONG( p );
 
       if ( offset                     &&
+           offset <= face->cmap_size - 2 &&
            table + offset + 2 < limit &&
            table + offset >= table    )
       {
diff -urp -x '*~' src/type1/t1load.c src/type1/t1load.c
--- src/type1/t1load.c	2005-04-14 04:39:28.000000000 -0700
+++ src/type1/t1load.c	2006-09-01 15:48:51.164479000 -0700
@@ -1989,6 +1989,9 @@
                         keyword_flags );
     if ( error )
       goto Exit;
+ 
+    /* ensure even-ness of 'num_blue_values' */
+    priv->num_blue_values &= ~1;
 
 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
 
