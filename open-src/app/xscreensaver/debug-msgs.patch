/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 *
 */

Various tidbits found to aid debugging over the years.

diff -urp -x '*~' driver/demo-Gtk.c driver/demo-Gtk.c
--- driver/demo-Gtk.c	2006-08-08 15:25:01.015494000 -0700
+++ driver/demo-Gtk.c	2006-08-08 15:25:07.860347000 -0700
@@ -2823,9 +2823,23 @@ populate_prefs_page (state *s)
 
 #ifdef HAVE_DPMS_EXTENSION
     {
+      char buf [300];
       int op = 0, event = 0, error = 0;
+
       if (XQueryExtension (dpy, "DPMS", &op, &event, &error))
+       {
         dpms_supported = True;
+        if (s->debug_p)
+         {
+          sprintf (buf, "XQueryExtension() says DPMS is supported.");
+          perror (buf);
+    }
+       }
+      else if (s->debug_p)
+       {
+        sprintf (buf, "XQueryExtension() says DPMS not supported.");
+        perror (buf);
+       }
     }
 #endif /* HAVE_DPMS_EXTENSION */
 
diff -urp -x '*~' driver/prefs.c driver/prefs.c
--- driver/prefs.c	2006-08-08 15:25:01.023671000 -0700
+++ driver/prefs.c	2006-08-08 15:25:07.942311000 -0700
@@ -482,6 +482,12 @@ init_file_changed_p (saver_preferences *
   const char *name = init_file_name();
   struct stat st;
 
+  if (p->verbose_p)
+   {
+    fprintf(stderr, "--> init_file_changed()\n");
+    fflush (stderr);
+   }
+
   if (!name) return False;
 
   if (stat(name, &st) != 0)
@@ -490,6 +496,12 @@ init_file_changed_p (saver_preferences *
   if (p->init_file_date == st.st_mtime)
     return False;
 
+  if (p->verbose_p)
+   {
+    fprintf(stderr, "<-- init_file_has changed should reload init file\n");
+    fflush (stderr);
+   }
+
   return True;
 }
 
diff -urp -x '*~' driver/timers.c driver/timers.c
--- driver/timers.c	2006-08-08 15:25:01.024861000 -0700
+++ driver/timers.c	2006-08-08 15:25:07.958865000 -0700
@@ -175,7 +175,7 @@ notice_events (saver_info *si, Window wi
    */
   XSelectInput (si->dpy, window, SubstructureNotifyMask | events);
 
-  if (top_p && p->debug_p && (events & KeyPressMask))
+  if (top_p && p->verbose_p && (events & KeyPressMask))
     {
       /* Only mention one window per tree (hack hack). */
       fprintf (stderr, "%s: %d: selected KeyPress on 0x%lX\n",
@@ -258,6 +258,9 @@ cycle_timer (XtPointer closure, XtInterv
   saver_preferences *p = &si->prefs;
   Time how_long = p->cycle;
 
+  if (p->verbose_p)
+    fprintf (stderr,"-->cycle_timer()\n");
+
   if (si->selection_mode > 0 &&
       screenhack_running_p (si))
     /* If we're in "SELECT n" mode, the cycle timer going off will just
@@ -277,7 +280,14 @@ cycle_timer (XtPointer closure, XtInterv
     }
   else
     {
+      if (p->verbose_p)
+       {
+        fprintf (stderr,"-->cycle_timer()..in else..i.e. no lock dialog present...");
+        fprintf (stderr,"...calling maybe_relaod_init_file\n");
+       }
+
       maybe_reload_init_file (si);
+
       kill_screenhack (si);
 
       /* if we are root then dont run hacks*/
@@ -297,13 +307,13 @@ cycle_timer (XtPointer closure, XtInterv
       si->cycle_id = XtAppAddTimeOut (si->app, how_long, cycle_timer,
                                       (XtPointer) si);
 
-      if (p->debug_p)
+      if (p->verbose_p)
         fprintf (stderr, "%s: starting cycle_timer (%ld, %ld)\n",
                  blurb(), how_long, si->cycle_id);
     }
   else
     {
-      if (p->debug_p)
+      if (p->verbose_p)
         fprintf (stderr, "%s: not starting cycle_timer: how_long == %ld\n",
                  blurb(), (unsigned long) how_long);
     }
@@ -345,7 +355,7 @@ reset_timers (saver_info *si)
 
   if (si->timer_id)
     {
-      if (p->debug_p)
+      if (p->verbose_p)
         fprintf (stderr, "%s: killing idle_timer  (%ld, %ld)\n",
                  blurb(), p->timeout, si->timer_id);
       XtRemoveTimeOut (si->timer_id);
@@ -723,6 +733,9 @@ sleep_until_idle (saver_info *si, Bool u
                                    si->using_sgi_saver_extension) ||
 				   si->using_xinputdev_extension);
 
+  if (si->prefs.debug_p)
+   fprintf(stderr,"--> sleep_until_idle()\n");
+
   if (until_idle_p)
     {
       if (polling_for_idleness)
@@ -800,17 +813,24 @@ sleep_until_idle (saver_info *si, Bool u
                    an event (again, user activity.)
                  */
 		idle = 1000 * (si->last_activity_time - time ((time_t *) 0));
+  		    if (si->prefs.verbose_p)
+   		      fprintf(stderr,"No idle extension in use (sleep_until_idle), idle=%d\n", idle);
+
 	      }
 
 	    if (idle >= p->timeout)
               {
                 /* Look, we've been idle long enough.  We're done. */
+  	        if (si->prefs.verbose_p)
+   	         fprintf(stderr,"idle long enough..DONE (sleep_until_idle)\n");
                 goto DONE;
               }
             else if (si->emergency_lock_p)
               {
                 /* Oops, the wall clock has jumped far into the future, so
                    we need to lock down in a hurry! */
+  	        if (si->prefs.verbose_p)
+   	         fprintf(stderr,"emergency_lock_p..DONE (sleep_until_idle)\n");
                 goto DONE;
               }
             else
@@ -821,6 +841,9 @@ sleep_until_idle (saver_info *si, Bool u
                    user has been idle for 2 minutes, then set this timer to
                    go off in 3 minutes.
                  */
+  	        if (si->prefs.verbose_p)
+   	         fprintf(stderr,"polling_for_idleness (sleep_until_idle)\n");
+
                 if (polling_for_idleness)
                   schedule_wakeup_event (si, p->timeout - idle, p->debug_p);
               }
@@ -890,7 +913,7 @@ sleep_until_idle (saver_info *si, Bool u
       case ButtonRelease:
       case MotionNotify:
 
-	if (p->debug_p)
+	if (p->debug_p || p->verbose_p)
 	  {
             Window root=0, window=0;
             int x=-1, y=-1;
@@ -910,6 +933,13 @@ sleep_until_idle (saver_info *si, Bool u
                 window = event.xkey.window;
                 x = y = -1;
               }
+	    else if (event.xany.type == KeyRelease)
+              {
+                type = "KeyRelease";
+                root = event.xkey.root;
+                window = event.xkey.window;
+                x = y = -1;
+              }
 	    else if (event.xany.type == ButtonPress)
               {
                 type = "ButtonPress";
@@ -918,6 +948,14 @@ sleep_until_idle (saver_info *si, Bool u
                 x = event.xmotion.x_root;
                 y = event.xmotion.y_root;
               }
+	    else if (event.xany.type == ButtonRelease)
+              {
+                type = "ButtonRelease";
+                root = event.xkey.root;
+                window = event.xkey.window;
+                x = event.xmotion.x_root;
+                y = event.xmotion.y_root;
+              }
 
             if (type)
               {
@@ -945,6 +983,14 @@ sleep_until_idle (saver_info *si, Bool u
                 else
                   fprintf (stderr, " at %d,%d.\n", x, y);
               }
+
+            fprintf(stderr,"************************************\n");
+	    fprintf(stderr,"-->sleep_until_idle() event: Motion or Key Press\n"); 
+            fprintf(stderr,"\t Window of Motion or KeyPress:%x\n",
+				window);
+            fprintf(stderr,"\t until_idle_p=%d g_passwd_dialog_created=%d\n",
+				until_idle_p, g_passwd_dialog_created);
+	    fflush(stderr);
 	  }
 
 	/* If any widgets want to handle this event, let them. */
@@ -987,7 +1033,11 @@ sleep_until_idle (saver_info *si, Bool u
 	    else
 	      /* If we're not demoing, then any activity causes deactivation.
 	       */
+	     {
+              if (si->prefs.verbose_p)
+	       fprintf(stderr, "===> timers.c goto DONE user activity detected\n");
 	      goto DONE;
+             }
 	  }
 	else
 	  reset_timers (si);
@@ -1491,6 +1541,9 @@ watchdog_timer (XtPointer closure, XtInt
                              p->dpms_off / 1000,
                              False);
 
+  if (p->verbose_p)
+   fprintf (stderr, "--->watchdog_timer()\n");
+
   if (si->screen_blanked_p)
     {
       Bool running_p = screenhack_running_p (si);
@@ -1504,7 +1557,7 @@ watchdog_timer (XtPointer closure, XtInt
         }
       else
         {
-          if (si->prefs.debug_p)
+          if (si->prefs.verbose_p)
             fprintf (stderr, "%s: watchdog timer raising %sscreen.\n",
                      blurb(), (running_p ? "" : "and clearing "));
 
@@ -1516,7 +1569,8 @@ watchdog_timer (XtPointer closure, XtInt
 	{
 	  if (si->prefs.verbose_p)
 	    fprintf (stderr,
-		     "%s: X says monitor has powered down; "
+		     /*mali     "%s: X says monitor has powered down; "**/
+		     "%s: X says dpms is disabled; "
 		     "killing running hacks.\n", blurb());
 	  kill_screenhack (si);
 	}
@@ -1546,7 +1600,7 @@ reset_watchdog_timer (saver_info *si, Bo
       si->watchdog_id = XtAppAddTimeOut (si->app, p->watchdog_timeout,
 					 watchdog_timer, (XtPointer) si);
 
-      if (p->debug_p)
+      if (p->verbose_p)
 	fprintf (stderr, "%s: restarting watchdog_timer (%ld, %ld)\n",
 		 blurb(), p->watchdog_timeout, si->watchdog_id);
     }
diff -urp -x '*~' driver/xscreensaver.c driver/xscreensaver.c
--- driver/xscreensaver.c	2006-08-08 15:25:01.031812000 -0700
+++ driver/xscreensaver.c	2006-08-08 15:25:07.960461000 -0700
@@ -706,7 +706,7 @@ print_banner (saver_info *si)
 
   if (p->debug_p)
     fprintf (stderr, "\n"
-	     "%s: Warning: running in DEBUG MODE.  Be afraid.\n"
+	     "%s: Warning: running in DEBUG MODE.\n"
 	     "\n"
 	     "\tNote that in debug mode, the xscreensaver window will only\n"
 	     "\tcover the left half of the screen.  (The idea is that you\n"
@@ -1455,7 +1455,12 @@ main (int argc, char **argv)
   saver_info the_si;
   saver_info *si = &the_si;
   saver_preferences *p = &si->prefs;
-  int i;
+  int i,debug_flag;
+
+/*Wait till we can attach debugger to the process*/
+debug_flag=0;
+while (debug_flag)
+ sleep(1);
 
 #ifdef ENABLE_NLS
   if (!setlocale (LC_ALL, ""))
