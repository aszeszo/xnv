/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 *
 */

Support for the SCF smartcard framework in Solaris.   SCF has been declared
obsolete by Sun and is being removed from the Solaris "Nevada" release, so
this code will be removed as well soon.

diff -urp -x '*~' config.h.in config.h.in
--- config.h.in	2006-05-10 08:48:35.644044000 -0700
+++ config.h.in	2006-05-10 08:48:40.856997000 -0700
@@ -269,6 +269,24 @@
  */
 #define PAM_SERVICE_NAME "xscreensaver"
 
+/* Define this if using SCF to handle smart cards. 
+ * bugid(4985708) xscreensaver uses its own pam stack and using
+ * "xscreensaver" as the pam service name when authenticating using
+ * smartcards, see bugid(4976405) fixing smartcard(im)
+ */
+
+#define HAVE_SCF_SMARTCARD
+
+/* If using smart cards for authentication use xscreensaver as pam service name
+ */
+#define SCF_PAM_SERVICE_NAME "xscreensaver"
+
+/* Define this if fork1 is defined; this should happen only on Solaris
+ * and only if HAVE_SCF_SMARTCARD is defined.
+ */
+
+#undef HAVE_FORK1
+
 /* Define if you have PAM and pam_strerror() requires two arguments.  */
 #undef PAM_STRERROR_TWO_ARGS
 
diff -urp -x '*~' configure.in configure.in
--- configure.in	2006-05-10 08:48:35.646544000 -0700
+++ configure.in	2006-05-10 08:48:40.859304000 -0700
@@ -1552,6 +1552,32 @@ if test "$enable_locking" = yes -a "$wit
   fi
 fi
 
+#--- Begin SUNW addition
+###############################################################################
+#
+#       Check for SCF smartcard framework.
+#
+###############################################################################
+
+have_scf_smartcard=no
+with_scf_smartcard_req=unspecified
+
+AC_ARG_WITH(scf-smartcard, 
+[  --with-scf-smartcard        Include support for SCF smartcard authentication.],
+  [with_scf_smartcard="$withval"; with_scf_smartcard_req="$withval"],
+	[with_scf_smartcard=yes])
+
+HANDLE_X_PATH_ARG(with_scf_smartcard, --with-scf-smartcard, scf-smartcard)
+
+if test "$enable_locking" = yes -a "$with_scf_smartcard" = yes; then
+  AC_CHECK_LIB(smartcard, SCF_Session_getSession,
+	[PASSWD_LIBS="$PASSWD_LIBS -lsmartcard"
+	 PASSWD_SRCS="$PASSWD_SRCS \$(SCF_SRCS)"
+	 PASSWD_OBJS="$PASSWD_OBJS \$(SCF_OBJS)"])
+
+fi
+
+#--- End SUNW addition
 
 ###############################################################################
 #
diff -urp -x '*~' driver/Makefile.in driver/Makefile.in
--- driver/Makefile.in	2006-05-10 08:48:35.667263000 -0700
+++ driver/Makefile.in	2006-05-10 08:48:40.892557000 -0700
@@ -110,6 +110,9 @@ KERBEROS_OBJS	= passwd-kerberos.o
 PAM_SRCS	= passwd-pam.c
 PAM_OBJS	= passwd-pam.o
 
+SCF_SRCS	= scf-smartcard.c
+SCF_OBJS	= scf-smartcard.o
+
 LOCK_SRCS_1	= lock.c passwd.c
 LOCK_OBJS_1	= lock.o passwd.o
 NOLOCK_SRCS_1	= lock.c
diff -urp -x '*~' driver/XScreenSaver.ad.in driver/XScreenSaver.ad.in
--- driver/XScreenSaver.ad.in	2006-05-10 08:48:35.580225000 -0700
+++ driver/XScreenSaver.ad.in	2006-05-10 08:48:40.872445000 -0700
@@ -449,6 +449,37 @@ XScreenSaver.bourneShell:		/bin/sh
 *splash.demo.label:		Settings
 *splash.help.label:		Help
 
+! Resources for smartcard OCF messages
+!
+*message.OCF.nouser:                                 \
+The user name could not be obtained from the card. \n\
+Please remove and reinsert your card.
+
+*message.OCF.waitforcard:       \
+There is no card in the reader.\n\
+Insert your card to unlock the display.\n\
+The display is locked by user %s.
+
+*message.OCF.waitremovallogoutwait: \
+There is no card in the reader.\n\
+Re-insert you card and authenticate yourself within %d seconds or you will \n\
+be automatically logged out. \n\
+The display is locked by user %s.
+
+*message.OCF.authrequired:      \
+Smart Card detected. Authentication is required on this card .\n\
+Locking the display for user %s.
+
+*message.OCF.wronguser: \
+The card's owner is not permitted to unlock \n\
+this display. Please remove the card.\n\
+The display is locked by user %s.
+
+*message.OCF.default:   \
+Unexpected card state: %x.\n\
+Try reinserting your card. If the problem persists, \n\
+contact your system administrator.\n\
+The display is locked by user %s.
 
 ! Resources for the Motif dialog boxes of the "xscreensaver-demo" program.
 ! 
diff -urp -x '*~' driver/lock.c driver/lock.c
--- driver/lock.c	2006-05-10 08:48:35.674843000 -0700
+++ driver/lock.c	2006-05-10 08:48:40.932264000 -0700
@@ -17,6 +17,12 @@
 # include "config.h"
 #endif
 
+#ifdef HAVE_SCF_SMARTCARD
+#include <thread.h>
+#include <signal.h>
+#include <security/pam_appl.h>
+#endif  /* HAVE_SCF_SMARTCARD */
+
 #include <X11/Intrinsic.h>
 #include <X11/Xos.h>		/* for time() */
 #include <time.h>
@@ -74,12 +80,82 @@ vms_passwd_valid_p(char *pw, Bool verbos
 extern void await_dying_children (saver_info *si);
 void hack_uid (saver_info *si);
 
+
+#ifdef HAVE_SCF_SMARTCARD 
+static void * smartcard_authenticate (void *);
+static void scfevent_handler (SCF_Event_t event, 
+                                  SCF_Terminal_t eventTerminal, void *unused);
+static void card_removal_timeout (XtPointer, XtIntervalId *);
+static void card_removal_logout_wait (XtPointer, XtIntervalId *);
+static void start_wait_removal_timer (saver_info *);
+static void report_smartcard_init_error (saver_info*, char*, uint32_t);
+static void report_smartcard_error (char*, uint32_t);
+static char * get_message (saver_info *);
+static void set_smartcard_lock_state (saver_info *);
+static Bool is_valid_unlock_user(char *);
+static void force_exit (saver_info *si);
+ 
+static XtIntervalId card_removal_timeout_id;
+static XtIntervalId card_removal_logout_wait_id;
+/*
+** S10 SCF API did  not use client_name and client_version
+static char *client_name = "dtsession";
+static char *client_version = "1";
+*/
+
+static cond_t c_event_processed = DEFAULTCV;
+static mutex_t m_event_processed = DEFAULTMUTEX;
+static Bool b_event_processed = 1;
+
+static char * get_username(void);
+static int run_PAMsession(char *, saver_info*);
+
+static cond_t c_got_message = DEFAULTCV;
+static mutex_t m_got_message;
+static Bool b_got_message = False;
+
+static cond_t c_got_response = DEFAULTCV;
+static mutex_t m_got_response;
+static Bool b_got_response = False;
+
+static cond_t c_got_username = DEFAULTCV;
+static mutex_t m_got_username;
+static Bool b_got_username = False;
+
+static cond_t c_validated_response = DEFAULTCV;
+static mutex_t m_validated_response;
+static Bool b_validated_response = False;
+
+static Bool  b_validation_succeeded;
+static Bool b_validation_finished;
+static Bool b_PAM_prompted;
+static Bool b_got_PAM_message;
+static Bool b_first_prompt;
+
+static thread_t pam_thread = (thread_t) NULL;
+
+static void wait_for_got_message (void);
+
+static char *saved_user_input = NULL;
+static struct pam_message safe_pam_message;
+static struct pam_message *saved_pam_message = &safe_pam_message;
+static int conversation_function(int, const struct pam_message**,
+				 struct pam_response **, void *);
+#endif /* HAVE_SCF_SMARTCARD */
+
 Bool g_passwd_dialog_created = 0;
 
 #undef MAX
 #define MAX(a,b) ((a)>(b)?(a):(b))
 
+#ifdef HAVE_SCF_SMARTCARD
+#include "scf-smartcard.h"
+/*
+ * enum passwd_state is defined in scf-smartcard.h
+ */
+#else
 enum passwd_state { pw_read, pw_ok, pw_null, pw_fail, pw_cancel, pw_time };
+#endif
 
 
 
@@ -91,6 +167,15 @@ enum passwd_state { pw_read, pw_ok, pw_n
 
 
 static void make_window (saver_info *si, enum window_type w_type);
+
+#ifdef HAVE_SCF_SMARTCARD
+void make_passwd_window (saver_info *si);
+static void make_message_window (saver_info *si);
+static void message_animate_timer (XtPointer closure, XtIntervalId *id);
+static void message_event_loop (saver_info *si);
+
+#endif /* HAVE_SCF_SMARTCARD */
+
 static void draw_passwd_window (saver_info *si);
 void update_passwd_window (saver_info *si, const char *printed_passwd,
 				  float ratio);
@@ -290,6 +375,17 @@ spawn_external_passwd_process (saver_inf
        */
       hack_uid (si);
 
+#ifdef HAVE_SCF_SMARTCARD
+      if (si->scf_si && si->scf_si->use_smartcard)
+	{
+          char* command_with_arg = malloc (strlen(command) + 
+						strlen("+use_smartcard"));
+          sprintf(command_with_arg, "%s +use_smartcard", command);
+          exec_command (p->shell, command_with_arg, 0);
+	}
+      else
+#endif /*HAVE_SCF_SMARTCARD*/
+
       exec_command (p->shell, command, 0);
       /* print_path_error (command); */
       fprintf (stderr, "%s: couldn't exec: %s\n", 
@@ -351,6 +447,10 @@ make_window (saver_info *si, enum window
      fprintf(stderr, "-->make_window()\n");
 
 #ifdef HAVE_XSCREENSAVER_LOCK
+#ifdef HAVE_SCF_SMARTCARD
+  if (w_type == w_dialog) /*if it is message then dont create the lock dialog*/
+#endif /*HAVE_SCF_SMARTCARD*/
+    {
       if (spawn_external_passwd_process (si, si->pw_data))
 	{ 
 /***************
@@ -392,6 +492,18 @@ make_window (saver_info *si, enum window
 
   si->pw_data->heading_label = get_string_resource ("passwd.heading.label",
 					   "Dialog.Label.Label");
+#ifdef HAVE_SCF_SMARTCARD
+   /* we never create dialog window; only pw_data->w_type == w_message */
+    {
+      si->pw_data->message_body_label = get_scf_message (si);
+      if (si->prefs.verbose_p)
+       {
+	fprintf (stderr, "**SCF: calling get_scf_message() msg = %s*** \n",si->pw_data->message_body_label);
+        fflush (stderr);
+       }
+    }
+#endif /* HAVE_SCF_SMARTCARD */
+
   si->pw_data->date_label = get_string_resource ("dateFormat", "DateFormat");
 
   if (!si->pw_data->heading_label)
@@ -479,6 +591,26 @@ make_window (saver_info *si, enum window
     if (overall.width > si->pw_data->width) si->pw_data->width = overall.width;
     si->pw_data->height += ascent + descent;
 
+#ifdef HAVE_SCF_SMARTCARD  
+    /* else  si->pw_data->w_type == w_message */
+      {
+	char **label_lines = si->pw_data->message_body_label;
+
+	while (*label_lines && **label_lines)
+	  {
+	    XTextExtents (si->pw_data->body_font,
+			  *label_lines, strlen(*label_lines),
+			  &direction, &ascent, &descent, &overall);
+	    if (overall.width > si->pw_data->width) si->pw_data->width = overall.width;
+	    si->pw_data->height += ascent + descent;
+	    if (*label_lines && **label_lines)
+	      label_lines++;
+	    else
+	      break;
+	  }
+      }
+#endif  /* HAVE_SCF_SMARTCARD */ 
+
     si->pw_data->width  += (si->pw_data->internal_border * 2);
     si->pw_data->height += (si->pw_data->internal_border * 4);
 
@@ -607,17 +739,35 @@ draw_passwd_window (saver_info *si)
   int sw;
   int tb_height;
 
+#ifdef HAVE_SCF_SMARTCARD
+  if (pw->w_type == w_dialog)
+#endif /* HAVE_SCF_SMARTCARD */
+    {
 
-  if (si->prefs.verbose_p)
-    fprintf (stderr, "-->draw_passwd_window() case w_dialog!!\n");
+      if (si->prefs.verbose_p)
+	fprintf (stderr, "-->draw_passwd_window() case w_dialog!!\n");
+
+      height = (pw->heading_font->ascent + pw->heading_font->descent +
+		pw->body_font->ascent + pw->body_font->descent +
+		(2 * MAX ((pw->label_font->ascent + pw->label_font->descent),
+			  (pw->passwd_font->ascent + pw->passwd_font->descent +
+			   (pw->shadow_width * 4)))) +
+		pw->date_font->ascent + pw->date_font->descent
+		);
+    }
+#ifdef HAVE_SCF_SMARTCARD
+  else /* pw->w_type == w_message */
+    {
+      if (si->prefs.verbose_p)
+	fprintf (stderr, "--> SCF::draw_passwd_window() case w_message!!\n");
+
+      height = (pw->heading_font->ascent + pw->heading_font->descent +
+		pw->body_font->ascent + pw->body_font->descent +
+		pw->date_font->ascent + pw->date_font->descent
+		);
+    }
+#endif /* HAVE_SCF_SMARTCARD */
 
-  height = (pw->heading_font->ascent + pw->heading_font->descent +
-	    pw->body_font->ascent + pw->body_font->descent +
-	    (2 * MAX ((pw->label_font->ascent + pw->label_font->descent),
-		      (pw->passwd_font->ascent + pw->passwd_font->descent +
-		       (pw->shadow_width * 4)))) +
-            pw->date_font->ascent + pw->date_font->descent
-            );
   spacing = ((pw->height - (2 * pw->shadow_width) -
 	      pw->internal_border - height)) / 8;
   if (spacing < 0) spacing = 0;
@@ -641,90 +791,117 @@ draw_passwd_window (saver_info *si)
   /* text below top heading
    */
   XSetFont (si->dpy, gc1, pw->body_font->fid);
-  y1 += spacing + pw->body_font->ascent + pw->body_font->descent;
-  sw = string_width (pw->body_font, pw->body_label);
-  x2 = (x1 + ((x3 - x1 - sw) / 2));
-  XDrawString (si->dpy, si->passwd_dialog, gc1, x2, y1,
-	       pw->body_label, strlen(pw->body_label));
 
+#ifdef HAVE_SCF_SMARTCARD
+  if (pw->w_type == w_dialog)
+#endif /* HAVE_SCF_SMARTCARD */
+    {
+      y1 += spacing + pw->body_font->ascent + pw->body_font->descent;
+      sw = string_width (pw->body_font, pw->body_label);
+      x2 = (x1 + ((x3 - x1 - sw) / 2));
+      XDrawString (si->dpy, si->passwd_dialog, gc1, x2, y1,
+		   pw->body_label, strlen(pw->body_label));
 
-  tb_height = (pw->passwd_font->ascent + pw->passwd_font->descent +
-	       (pw->shadow_width * 4));
 
-  /* the "User:" prompt
-   */
-  y1 += spacing;
-  y2 = y1;
-  XSetForeground (si->dpy, gc1, pw->foreground);
-  XSetFont (si->dpy, gc1, pw->label_font->fid);
-  y1 += (spacing + tb_height);
-  x2 = (x1 + pw->internal_border +
-	MAX(string_width (pw->label_font, pw->user_label),
-	    string_width (pw->label_font, pw->passwd_label)));
-  XDrawString (si->dpy, si->passwd_dialog, gc1,
-	       x2 - string_width (pw->label_font, pw->user_label),
-	       y1,
-	       pw->user_label, strlen(pw->user_label));
+      tb_height = (pw->passwd_font->ascent + pw->passwd_font->descent +
+		   (pw->shadow_width * 4));
 
-  /* the "Password:" prompt
-   */
-  y1 += (spacing + tb_height);
-  XDrawString (si->dpy, si->passwd_dialog, gc1,
-	       x2 - string_width (pw->label_font, pw->passwd_label),
-	       y1,
-	       pw->passwd_label, strlen(pw->passwd_label));
+      /* the "User:" prompt
+       */
+      y1 += spacing;
+      y2 = y1;
+      XSetForeground (si->dpy, gc1, pw->foreground);
+      XSetFont (si->dpy, gc1, pw->label_font->fid);
+      y1 += (spacing + tb_height);
+      x2 = (x1 + pw->internal_border +
+	    MAX(string_width (pw->label_font, pw->user_label),
+		string_width (pw->label_font, pw->passwd_label)));
+      XDrawString (si->dpy, si->passwd_dialog, gc1,
+		   x2 - string_width (pw->label_font, pw->user_label),
+		   y1,
+		   pw->user_label, strlen(pw->user_label));
 
+      /* the "Password:" prompt
+       */
+      y1 += (spacing + tb_height);
+      XDrawString (si->dpy, si->passwd_dialog, gc1,
+		   x2 - string_width (pw->label_font, pw->passwd_label),
+		   y1,
+		   pw->passwd_label, strlen(pw->passwd_label));
 
-  XSetForeground (si->dpy, gc2, pw->passwd_background);
+      XSetForeground (si->dpy, gc2, pw->passwd_background);
 
-  /* the "user name" text field
-   */
-  y1 = y2;
-  XSetForeground (si->dpy, gc1, pw->passwd_foreground);
-  XSetFont (si->dpy, gc1, pw->passwd_font->fid);
-  y1 += (spacing + tb_height);
-  x2 += (pw->shadow_width * 4);
-
-  pw->passwd_field_width = x3 - x2 - pw->internal_border;
-  pw->passwd_field_height = (pw->passwd_font->ascent +
-			     pw->passwd_font->descent +
-			     pw->shadow_width);
-
-  XFillRectangle (si->dpy, si->passwd_dialog, gc2,
-		  x2 - pw->shadow_width,
-		  y1 - (pw->passwd_font->ascent + pw->passwd_font->descent),
-		  pw->passwd_field_width, pw->passwd_field_height);
-  XDrawString (si->dpy, si->passwd_dialog, gc1, x2, y1,
-	       pw->user_string, strlen(pw->user_string));
+      /* the "user name" text field
+       */
+      y1 = y2;
+      XSetForeground (si->dpy, gc1, pw->passwd_foreground);
+      XSetFont (si->dpy, gc1, pw->passwd_font->fid);
+      y1 += (spacing + tb_height);
+      x2 += (pw->shadow_width * 4);
+
+      pw->passwd_field_width = x3 - x2 - pw->internal_border;
+      pw->passwd_field_height = (pw->passwd_font->ascent +
+				 pw->passwd_font->descent +
+				 pw->shadow_width);
 
-  /* the "password" text field
-   */
-  y1 += (spacing + tb_height);
+      XFillRectangle (si->dpy, si->passwd_dialog, gc2,
+		      x2 - pw->shadow_width,
+		      y1 - (pw->passwd_font->ascent + pw->passwd_font->descent),
+		      pw->passwd_field_width, pw->passwd_field_height);
+      XDrawString (si->dpy, si->passwd_dialog, gc1, x2, y1,
+		   pw->user_string, strlen(pw->user_string));
 
-  pw->passwd_field_x = x2 - pw->shadow_width;
-  pw->passwd_field_y = y1 - (pw->passwd_font->ascent +
-			     pw->passwd_font->descent);
+      /* the "password" text field
+       */
+      y1 += (spacing + tb_height);
 
-  /* The shadow around the text fields
-   */
-  y1 = y2;
-  y1 += (spacing + (pw->shadow_width * 3));
-  x1 = x2 - (pw->shadow_width * 2);
-  x2 = pw->passwd_field_width + (pw->shadow_width * 2);
-  y2 = pw->passwd_field_height + (pw->shadow_width * 2);
+      pw->passwd_field_x = x2 - pw->shadow_width;
+      pw->passwd_field_y = y1 - (pw->passwd_font->ascent +
+				 pw->passwd_font->descent);
 
-  draw_shaded_rectangle (si->dpy, si->passwd_dialog,
-			 x1, y1, x2, y2,
-			 pw->shadow_width,
-			 pw->shadow_bottom, pw->shadow_top);
+      /* The shadow around the text fields
+       */
+      y1 = y2;
+      y1 += (spacing + (pw->shadow_width * 3));
+      x1 = x2 - (pw->shadow_width * 2);
+      x2 = pw->passwd_field_width + (pw->shadow_width * 2);
+      y2 = pw->passwd_field_height + (pw->shadow_width * 2);
+
+      draw_shaded_rectangle (si->dpy, si->passwd_dialog,
+			     x1, y1, x2, y2,
+			     pw->shadow_width,
+			     pw->shadow_bottom, pw->shadow_top);
+
+      y1 += (spacing + pw->passwd_font->ascent + pw->passwd_font->descent +
+	     (pw->shadow_width * 4));
+      draw_shaded_rectangle (si->dpy, si->passwd_dialog,
+			     x1, y1, x2, y2,
+			     pw->shadow_width,
+			     pw->shadow_bottom, pw->shadow_top);
+    }
+#ifdef HAVE_SCF_SMARTCARD
+  else /* pw->w_type == w_message  */
+    {
+      char ** label_lines = pw->message_body_label;
+   
+      y1 += spacing;
+      while (*label_lines && **label_lines)
+	{ 
+	  y1 += pw->body_font->ascent + pw->body_font->descent;
+	  sw = string_width (pw->body_font, *label_lines);
+	  x2 = (x1 + ((x3 - x1 - sw) / 2));
+	  XDrawString (si->dpy, si->passwd_dialog, gc1, x2, y1,
+		       *label_lines, strlen(*label_lines));
+	  if (*label_lines && **label_lines)
+	      label_lines++;
+	   else
+	      break;
+	}
 
-  y1 += (spacing + pw->passwd_font->ascent + pw->passwd_font->descent +
-	 (pw->shadow_width * 4));
-  draw_shaded_rectangle (si->dpy, si->passwd_dialog,
-			 x1, y1, x2, y2,
-			 pw->shadow_width,
-			 pw->shadow_bottom, pw->shadow_top);
+      tb_height = 0;
 
+    }
+#endif /* HAVE_SCF_SMARTCARD */
 
   /* The date, below the text fields
    */
@@ -839,68 +1016,86 @@ update_passwd_window (saver_info *si, co
   XRectangle rects[1];
 
   pw->ratio = ratio;
-
-  if (si->prefs.verbose_p)
-    fprintf (stderr, "-->update_passwd_window() w_dialog !!\n");
-  
-  if (!si->pw_data->got_windowid )
+#ifdef HAVE_SCF_SMARTCARD
+  if (pw->w_type == w_dialog)
+#endif /* HAVE_SCF_SMARTCARD */
     {
+
       if (si->prefs.verbose_p)
-	fprintf (stderr, "-->update_passwd_window() lockdialog not created returning.. !!\n");
-      return;
+	fprintf (stderr, "-->update_passwd_window() w_dialog !!\n");
+
+     if (!si->pw_data->got_windowid )
+      {
+        if (si->prefs.verbose_p)
+	   fprintf (stderr, "-->update_passwd_window() lockdialog not created returning.. !!\n");
+        return;
+      }
+
+      gcv.foreground = pw->passwd_foreground;
+      if (pw->passwd_font)
+       gcv.font = pw->passwd_font->fid;
+      gc1 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground|GCFont, &gcv);
+      gcv.foreground = pw->passwd_background;
+    }
+#ifdef HAVE_SCF_SMARTCARD
+  else /* pw->w_type == w_message */
+    {
+      gcv.foreground = pw->foreground;
+      gc1 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground, &gcv);
+      gcv.foreground = pw->background;
     }
-  
-  gcv.foreground = pw->passwd_foreground;
-  if (pw->passwd_font)
-    gcv.font = pw->passwd_font->fid;
-  gc1 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground|GCFont, &gcv);
-  gcv.foreground = pw->passwd_background;
+#endif /* HAVE_SCF_SMARTCARD */
+
   gc2 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground, &gcv);
 
-  if (printed_passwd)
+#ifdef HAVE_SCF_SMARTCARD
+  if (pw->w_type == w_dialog)
+#endif /* HAVE_SCF_SMARTCARD */
     {
-      char *s = strdup (printed_passwd);
-      if (pw->passwd_string) free (pw->passwd_string);
-      pw->passwd_string = s;
-    }
+      if (printed_passwd)
+	{
+	  char *s = strdup (printed_passwd);
+	  if (pw->passwd_string) free (pw->passwd_string);
+	  pw->passwd_string = s;
+	}
 
-  /* the "password" text field
-   */
-  rects[0].x =  pw->passwd_field_x;
-  rects[0].y =  pw->passwd_field_y;
-  rects[0].width = pw->passwd_field_width;
-  rects[0].height = pw->passwd_field_height;
+      /* the "password" text field
+       */
+      rects[0].x =  pw->passwd_field_x;
+      rects[0].y =  pw->passwd_field_y;
+      rects[0].width = pw->passwd_field_width;
+      rects[0].height = pw->passwd_field_height;
 
-  XFillRectangle (si->dpy, si->passwd_dialog, gc2,
-                  rects[0].x, rects[0].y, rects[0].width, rects[0].height);
+      XFillRectangle (si->dpy, si->passwd_dialog, gc2,
+		      rects[0].x, rects[0].y, rects[0].width, rects[0].height);
 
-  XSetClipRectangles (si->dpy, gc1, 0, 0, rects, 1, Unsorted);
+      XSetClipRectangles (si->dpy, gc1, 0, 0, rects, 1, Unsorted);
 
-  XDrawString (si->dpy, si->passwd_dialog, gc1,
-               rects[0].x + pw->shadow_width,
-               rects[0].y + (pw->passwd_font->ascent +
-                             pw->passwd_font->descent),
-               pw->passwd_string, strlen(pw->passwd_string));
+      XDrawString (si->dpy, si->passwd_dialog, gc1,
+		   rects[0].x + pw->shadow_width,
+		   rects[0].y + (pw->passwd_font->ascent +
+				 pw->passwd_font->descent),
+		   pw->passwd_string, strlen(pw->passwd_string));
 
-  XSetClipMask (si->dpy, gc1, None);
+      XSetClipMask (si->dpy, gc1, None);
 
-  /* The I-beam
-   */
-  if (pw->i_beam != 0)
-    {
-      x = (rects[0].x + pw->shadow_width +
-	   string_width (pw->passwd_font, pw->passwd_string));
-      y = rects[0].y + pw->shadow_width;
+      /* The I-beam
+       */
+      if (pw->i_beam != 0)
+	{
+	  x = (rects[0].x + pw->shadow_width +
+	       string_width (pw->passwd_font, pw->passwd_string));
+	  y = rects[0].y + pw->shadow_width;
+
+	  if (x > rects[0].x + rects[0].width - 1)
+	    x = rects[0].x + rects[0].width - 1;
+	  XDrawLine (si->dpy, si->passwd_dialog, gc1, 
+		     x, y, x, y + pw->passwd_font->ascent);
+	}
 
-      if (x > rects[0].x + rects[0].width - 1)
-        x = rects[0].x + rects[0].width - 1;
-      XDrawLine (si->dpy, si->passwd_dialog, gc1, 
-		 x, y, x, y + pw->passwd_font->ascent);
+      pw->i_beam = (pw->i_beam + 1) % 4;
     }
 
-  pw->i_beam = (pw->i_beam + 1) % 4;
-
-
   /* the thermometer
    */
   y = (pw->thermo_field_height - 2) * (1.0 - pw->ratio);
@@ -1051,6 +1246,25 @@ destroy_passwd_window (saver_info *si)
       
       if (pw->heading_label) free (pw->heading_label);
       if (pw->body_label)    free (pw->body_label);
+
+#ifdef HAVE_SCF_SMARTCARD
+      if (pw->message_body_label)
+	{
+	  char ** label_lines = pw->message_body_label;
+
+	  /*
+	   * The array of character strings was originally one character
+	   * string before each line was split into a different string
+	   * so just one free is required.
+	   */
+	  if (*label_lines)
+	    {
+	      free (*label_lines);
+	    }
+	  free (pw->message_body_label);
+	}
+#endif /* HAVE_SCF_SMARTCARD */
+
       if (pw->user_label)    free (pw->user_label);
       if (pw->passwd_label)  free (pw->passwd_label);
       if (pw->date_label)    free (pw->date_label);
@@ -1068,10 +1282,15 @@ destroy_passwd_window (saver_info *si)
       if (pw->background != black && pw->background != white)
 	XFreeColors (si->dpy, cmap, &pw->background, 1, 0L);
 
-      if (pw->passwd_foreground != black && pw->passwd_foreground != white)
-	XFreeColors (si->dpy, cmap, &pw->passwd_foreground, 1, 0L);
-      if (pw->passwd_background != black && pw->passwd_background != white)
-	XFreeColors (si->dpy, cmap, &pw->passwd_background, 1, 0L);
+#ifdef HAVE_SCF_SMARTCARD
+      if (pw->w_type == w_dialog)
+#endif /* HAVE_SCF_SMARTCARD */
+	{
+	  if (pw->passwd_foreground != black && pw->passwd_foreground != white)
+	    XFreeColors (si->dpy, cmap, &pw->passwd_foreground, 1, 0L);
+	  if (pw->passwd_background != black && pw->passwd_background != white)
+	    XFreeColors (si->dpy, cmap, &pw->passwd_background, 1, 0L);
+	}
       if (pw->thermo_foreground != black && pw->thermo_foreground != white)
 	XFreeColors (si->dpy, cmap, &pw->thermo_foreground, 1, 0L);
       if (pw->thermo_background != black && pw->thermo_background != white)
@@ -1423,10 +1642,18 @@ handle_passwd_key (saver_info *si, XKeyE
           XSync (si->dpy, False);
 
 /***************mali99************************************************
+ **** No need to call scf_passwd_valid_p, only xscreensaver.c calls 
+ **** pam_passwd_valid_p() which drives pam. *************************
+#ifdef HAVE_SCF_SMARTCARD
+          pw->state = scf_passwd_valid_p(si, typed_passwd);
+	  if (si->prefs.verbose_p)
+	    fprintf (stderr,"scf_passwd_valid_p() returns status = %d\n",pw->state);
+#else * ! HAVE_SCF_SMARTCARD *
           if (passwd_valid_p (typed_passwd, p->verbose_p, PAM_SERVICE))
             pw->state = pw_ok;
           else
             pw->state = pw_fail;
+#endif * HAVE_SCF_SMARTCARD *
           update_passwd_window (si, "", pw->ratio);
 ****************************************************************************/
             pw->state = pw_ok;
@@ -1507,6 +1734,18 @@ passwd_event_loop (saver_info *si)
       else if (event.xany.type == KeyPress)
 	handle_passwd_key (si, &event.xkey);
 #endif /* !HAVE_XSCREENSAVER_LOCK */
+#ifdef HAVE_SCF_SMARTCARD
+      else if  ((event.xany.type == 0) && has_smartcard_event_occurred())
+	/* Synthethic event has been signalled  because of card insertion
+         * or removal
+         */
+	{
+	  if (si->prefs.verbose_p)
+	    fprintf (stderr, "**SCF: calling handle_scf_event() ***\n");
+	  handle_scf_event (si);
+	  si->pw_data->state = pw_cancel;
+	}
+#endif /* HAVE_SCF_SMARTCARD */
       else if (event.xany.window == si->passwd_dialog && event.xany.type == Expose &&
                si->pw_data->passwd_label != NULL)
        {
@@ -1531,6 +1770,9 @@ passwd_event_loop (saver_info *si)
     case pw_read: msg = strdup("pw_read"); break;
     case pw_fail: msg = strdup("pw_fail"); break;
     case pw_cancel: msg = strdup("pw_cancel"); break;
+#ifdef HAVE_SCF_SMARTCARD
+    case pw_another:   msg = strdup("pw_another"); break;
+#endif
     default:      msg = 0; 
 	fprintf(stderr, "si->pw_data->state is bad, serious error\n");
         break;
@@ -1721,6 +1963,15 @@ unlock_p (saver_info *si)
   passwd_event_loop (si);
 
   status = (si->pw_data->state == pw_ok);
+#ifdef HAVE_SCF_SMARTCARD
+  if (si->pw_data->state == pw_another)
+    {
+      /*
+       * Generate synthetic event so that dialog is displayed
+       */
+      idle_timer ((XtPointer) si, 0);
+    }
+#endif /* HAVE_SCF_SMARTCARD */
 
   destroy_passwd_window (si);
 
@@ -1734,6 +1985,10 @@ unlock_p (saver_info *si)
 void
 set_locked_p (saver_info *si, Bool locked_p)
 {
+#ifdef HAVE_SCF_SMARTCARD
+  scf_set_locked_p (si, locked_p);
+#endif /* HAVE_SCF_SMARTCARD */
+
   si->locked_p = locked_p;
 
 #ifdef HAVE_XHPDISABLERESET
@@ -1749,6 +2004,116 @@ set_locked_p (saver_info *si, Bool locke
   store_saver_status (si);			/* store locked-p */
 }
 
+#ifdef HAVE_SCF_SMARTCARD
+static void
+make_message_window (saver_info *si)
+{
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "**make_passwd_window() dialog should be message(1)!!\n");
+
+  make_window (si, w_message); 
+}
+
+static void
+message_animate_timer (XtPointer closure, XtIntervalId *id)
+{
+  saver_info *si = (saver_info *) closure;
+  int tick = 166;
+  scf_saver_info *scf_si = si->scf_si;
+  passwd_dialog_data *pw = si->pw_data;
+
+  if (!pw|| !pw->prompt_screen) return;
+
+  if (si->scf_si->scdata->message_timeout)
+    pw->ratio -= (1.0 / ((double) scf_si->scdata->message_timeout / (double) tick));
+  if (pw->ratio < 0)
+    {
+      pw->ratio = 0;
+      if (pw->state == pw_read)
+	pw->state = pw_time;
+    }
+
+  update_passwd_window (si, NULL, pw->ratio);
+
+  if (pw->state == pw_read)
+    pw->timer = XtAppAddTimeOut (si->app, tick, message_animate_timer,
+				 (XtPointer) si);
+  else
+    pw->timer = 0;
+
+  idle_timer ((XtPointer) si, id);
+}
+/*GOK BUG */
+
+
+static void
+message_event_loop (saver_info *si)
+{
+  saver_preferences *p = &si->prefs;
+  XEvent event;
+  message_animate_timer ((XtPointer) si, 0);
+
+  while (si->pw_data && si->pw_data->state == pw_read)
+    {
+      XtAppNextEvent (si->app, &event);
+      if (event.xany.window == si->passwd_dialog && event.xany.type == Expose)
+	draw_passwd_window (si);
+      else if (event.xany.type == KeyPress)
+        /* ignore KeyPress events */
+        continue;
+      else if  ((event.xany.type == 0) && has_smartcard_event_occurred())
+	/* Synthethic event has been signalled */
+	{
+
+	  if (si->prefs.verbose_p)
+	    fprintf (stderr, "**message_animate_timer() calling handle_scf_event()*** \n");
+	  handle_scf_event (si);
+	  si->pw_data->state = pw_cancel;
+	}
+    else
+	XtDispatchEvent (&event);
+    }
+
+  if (si->pw_data && p->verbose_p)
+    switch (si->pw_data->state)
+      {
+      case pw_null:
+      case pw_cancel:
+	fprintf (stderr, "%s: message entry cancelled.\n", blurb()); break;
+      case pw_time:
+	fprintf (stderr, "%s: message entry timed out.\n", blurb()); break;
+      default: 
+	fprintf (stderr, "%s: unexpected message entry: %d\n", blurb(),
+		 si->pw_data->state); break;
+      }
+}
+
+Bool
+display_message (saver_info *si)
+{
+  Screen *screen = si->default_screen->screen;
+  Colormap cmap = DefaultColormapOfScreen (screen);
+  Bool status = False;
+
+  raise_window (si, True, True, True);
+
+  if (si->pw_data || si->passwd_dialog)
+    destroy_passwd_window (si);
+
+  make_message_window (si);
+  if (cmap) XInstallColormap (si->dpy, cmap);
+
+  message_event_loop (si);
+
+  destroy_passwd_window (si);
+
+  cmap = si->default_screen->cmap;
+  if (cmap) XInstallColormap (si->dpy, cmap);
+
+  return status;
+}
+
+#endif /* HAVE_SCF_SMARTCARD */
 
 #else  /*  NO_LOCKING -- whole file */
 
diff -urp -x '*~' driver/passwd-pam.c driver/passwd-pam.c
--- driver/passwd-pam.c	2006-05-10 08:48:35.676003000 -0700
+++ driver/passwd-pam.c	2006-05-10 08:48:40.893332000 -0700
@@ -62,6 +62,12 @@
 
 #include <sys/stat.h>
 
+#ifdef HAVE_SCF_SMARTCARD
+#include <thread.h>
+#include <signal.h>
+#include <security/pam_appl.h>
+#endif  /* HAVE_SCF_SMARTCARD */
+
 #include <X11/Intrinsic.h>
 #include <X11/Xos.h>            /* for time() */
 #include <time.h>
@@ -201,7 +207,7 @@ static void *suns_pam_implementation_blo
 Bool
 pam_passwd_valid_p ()
 {
-  const char *service = PAM_SERVICE_NAME;
+  const char *service;
   uid_t euid;
   pam_handle_t *pamh = 0;
   int pam_auth_status = 0;  /* Specific for pam_authenticate() status*/
@@ -220,6 +226,8 @@ pam_passwd_valid_p ()
     fprintf (stderr, "-->pam_passwd_valid_p()\n");
 
   if (!p) return False;
+  /* 4818344(P1) xscreensaver does not  use PAM correctly */
+  service = strdup (SCF_PAM_SERVICE_NAME);
 
   euid = geteuid();
 
@@ -496,6 +504,7 @@ pam_passwd_valid_p ()
 
 
  DONE:
+  if (service) free((void *)service);
   if (user) free (user);
   if (pamh)
     {
@@ -737,6 +746,27 @@ pam_conversation (int nmsgs,
           write_to_child (si, tmp_msg);
           sleep(1);
 
+          fprintf (stderr,"scf_scdata_state = %d\n",
+                              si->scf_si->scdata->state);
+          /* The following need to change to some other variable which gets set 
+           * when the user hits OK button in the dialog displaying the TEXT_INFO or
+           * ERROR_MSG. But we dont have buttons in dialog, and at the moment this
+           * case only happens for smartcards so the following will work.
+           */
+          while (si->scf_si->use_smartcard && si->scf_si->scdata->state == SCD_WAIT_FOR_CARD)
+           {
+            XEvent event;
+            XtAppNextEvent (si->app, &event);
+            XtDispatchEvent (&event);
+#if 0
+             /* handle_typeahead (si);**/
+              passwd_event_loop (si);
+          if (c->verbose_p)
+                fprintf (stderr,"scf_scdata_state = %d\n",
+                              si->scf_si->scdata->state);
+#endif /*0*/
+           }
+
           if (c->verbose_p)
             fprintf(stderr, "PAM_ERROR/PAM_TEXT_INFO msg[%d]-> %s\n",
 					replies,msg[replies]->msg);
diff -urp -x '*~' driver/subprocs.c driver/subprocs.c
--- driver/subprocs.c	2006-05-10 08:48:35.788404000 -0700
+++ driver/subprocs.c	2006-05-10 08:48:40.879329000 -0700
@@ -44,6 +44,11 @@
 # define fork  vfork
 #endif /* VMS */
 
+#ifdef sun
+#define fork fork1
+#endif
+
+
 #include <signal.h>		/* for the signal names */
 
 #if !defined(SIGCHLD) && defined(SIGCLD)
diff -urp -x '*~' driver/timers.c driver/timers.c
--- driver/timers.c	2006-05-10 08:48:35.781471000 -0700
+++ driver/timers.c	2006-05-10 08:48:40.874330000 -0700
@@ -56,6 +56,9 @@ extern Bool pam_passwd_valid_p(void);
 extern Bool blank_screen (saver_info *si);
 extern void unblank_screen (saver_info *si);
 
+#ifdef HAVE_SCF_SMARTCARD
+extern Bool Ignore_SmartCard;
+#endif /* HAVE_SCF_SMARTCARD */
 
 void
 idle_timer (XtPointer closure, XtIntervalId *id)
@@ -580,6 +583,10 @@ sleep_until_idle (saver_info *si, Bool u
   saver_preferences *p = &si->prefs;
   XEvent event;
 
+#ifdef HAVE_SCF_SMARTCARD
+  scf_saver_info *scf_si = si->scf_si;
+#endif
+
   /* We need to select events on all windows if we're not using any extensions.
      Otherwise, we don't need to. */
   Bool scanning_all_windows = !(si->using_xidle_extension ||
@@ -607,6 +614,22 @@ sleep_until_idle (saver_info *si, Bool u
                                    si->using_mit_saver_extension ||
                                    si->using_sgi_saver_extension));
 
+#ifdef HAVE_SCF_SMARTCARD
+  static Bool display_required = False;
+
+  /*
+   * When a card event occurs when we are waiting for idleness
+   * we want to display the message immediately and not wait until 
+   * the user presses a key or moves the mouse. The variable display_required
+   * is set to true to indicate this situation.
+   */
+  if (display_required)
+    {
+      display_required = False;
+      return;
+    }
+#endif /* HAVE_SCF_SMARTCARD */
+
   if (until_idle_p)
     {
       if (polling_for_idleness)
@@ -629,6 +652,24 @@ sleep_until_idle (saver_info *si, Bool u
 
       switch (event.xany.type) {
       case 0:		/* our synthetic "timeout" event has been signalled */
+#ifdef HAVE_SCF_SMARTCARD
+	/*
+         * If the synthetic event has been signalled because of a
+	 * smartcard event deal with it
+	 */
+	if (scf_si->use_smartcard && !Ignore_SmartCard)
+	  {
+	    if (has_smartcard_event_occurred ())
+	      {
+		handle_scf_event (si);
+		set_smartcard_event_occurred (False);
+  		if (si->prefs.verbose_p)
+   		  fprintf(stderr,"case 0: (sleep_until_idle)\n");
+		continue;
+	      }
+	  }
+#endif /* HAVE_SCF_SMARTCARD */
+
 	if (until_idle_p)
 	  {
 	    Time idle;
@@ -680,6 +721,28 @@ sleep_until_idle (saver_info *si, Bool u
 		idle = 1000 * (si->last_activity_time - time ((time_t *) 0));
 	      }
 
+#ifdef HAVE_SCF_SMARTCARD
+	    if (scf_si->use_smartcard  && !Ignore_SmartCard)
+              {
+                if ((scf_si->scdata->state == SCD_WAIT_FOR_CARD) ||
+		    (scf_si->scdata->state == SCD_WAIT_REMOVAL_LOGOUT_WAIT) ||
+		    (scf_si->scdata->state == SCD_AUTH_REQUIRED))
+		  {
+		    /*
+		     * The smart card was removed or inserted while waiting for 
+		     * idle timeout to occur. We set display_required so that the
+		     * next time this function is called it will return
+		     * immediately instead of waiting for mouse movement or
+		     * key press.
+		     */
+		    display_required = True;
+  		    if (si->prefs.debug_p)
+   		      fprintf(stderr,"use_smartcard, setting display_required (sleep_until_idle)\n");
+		    goto DONE;
+		  }
+              }
+#endif /* HAVE_SCF_SMARTCARD */
+
 	    if (idle >= p->timeout)
               {
                 /* Look, we've been idle long enough.  We're done. */
@@ -700,6 +763,25 @@ sleep_until_idle (saver_info *si, Bool u
                   schedule_wakeup_event (si, p->timeout - idle, p->debug_p);
               }
 	  }
+#ifdef HAVE_SCF_SMARTCARD
+	else
+          {
+            /*
+             * A smart card was reinserted or the smart card was removed 
+             * after locking the screen so we want to get the dialog displayed.
+             */
+            if (scf_si->use_smartcard  && !Ignore_SmartCard)
+	      {  
+		if ((scf_si->scdata->state == SCD_WAIT_FOR_CARD) ||
+		    (scf_si->scdata->state == SCD_AUTH_REQUIRED))
+		  {
+  	           if (si->prefs.debug_p)
+   	            fprintf(stderr,"else(until_idle_p) (sleep_until_idle)\n");
+		    goto DONE;
+		  }
+	      }
+          } 
+#endif /* HAVE_SCF_SMARTCARD */
 	break;
 
       case ClientMessage:
diff -urp -x '*~' driver/xscreensaver.c driver/xscreensaver.c
--- driver/xscreensaver.c	2006-05-10 08:48:35.764178000 -0700
+++ driver/xscreensaver.c	2006-05-10 08:48:40.913194000 -0700
@@ -156,11 +156,23 @@
 #include "visual.h"
 #include "usleep.h"
 
+#ifdef HAVE_SCF_SMARTCARD
+#include "scf-smartcard.h"
+#endif /* HAVE_SCF_SMARTCARD */
+
 extern Bool pam_passwd_valid_p ();
 
 saver_info *global_si_kludge = 0;	/* I hate C so much... */
 
 /* Globals */
+#ifdef HAVE_SCF_SMARTCARD
+  scf_saver_info the_scf_si;
+  scf_saver_info  *ptr_osi = &the_scf_si;
+  smartcard_info the_smi;
+  smartcard_info *ptr_smi = &the_smi;
+  Bool Ignore_SmartCard = True;
+#endif /* HAVE_SCF_SMARTCARD */
+
 Bool ok_to_unblank = False;
 
 /* Global storage for gtk passwd lock dialog 
@@ -182,6 +194,9 @@ static Atom XA_RESTART, XA_SELECT;
 static Atom XA_THROTTLE, XA_UNTHROTTLE;
 Atom XA_DEMO, XA_PREFS, XA_EXIT, XA_LOCK, XA_BLANK;
 Atom XA_UNLOCK_RATIO;
+#ifdef HAVE_SCF_SMARTCARD
+Atom XA_SMARTCARD;
+#endif
 
 
 static XrmOptionDescRec options [] = {
@@ -470,6 +485,9 @@ privileged_initialization (saver_info *s
   lock_priv_init (*argc, argv, si->prefs.verbose_p);
 #endif /* NO_LOCKING */
 
+#ifdef HAVE_SCF_SMARTCARD
+  init_scf_properties (si);
+#endif /* HAVE_SCF_SMARTCARD */
   hack_uid (si);
 }
 
@@ -571,6 +589,9 @@ connect_to_server (saver_info *si, int *
   XA_THROTTLE = XInternAtom (si->dpy, "THROTTLE", False);
   XA_UNTHROTTLE = XInternAtom (si->dpy, "UNTHROTTLE", False);
   XA_UNLOCK_RATIO = XInternAtom (si->dpy, "UNLOCK_RATIO", False);
+#ifdef HAVE_SCF_SMARTCARD
+  XA_SMARTCARD = XInternAtom (si->dpy, "SMARTCARD", False);
+#endif 
 
   return toplevel_shell;
 }
@@ -1260,6 +1281,13 @@ main (int argc, char **argv)
 
   memset(si, 0, sizeof(*si));
 
+#ifdef HAVE_SCF_SMARTCARD
+  memset(ptr_osi, 0, sizeof(*ptr_osi));
+  memset(ptr_smi, 0, sizeof(*ptr_smi));
+  si->scf_si = ptr_osi;
+  si->scf_si->scdata = ptr_smi;
+#endif /* HAVE_SCF_SMARTCARD */
+
 /* Initialize and point si to pw_data i.e. the lock dialog struct */
   memset(ptr_mygtkpwd, 0, sizeof(*ptr_mygtkpwd));
   si->pw_data = ptr_mygtkpwd;
@@ -1318,6 +1346,12 @@ main (int argc, char **argv)
                              False);
 
   initialize_stderr (si);
+
+
+#ifdef HAVE_SCF_SMARTCARD
+  init_scf_handler(si);
+#endif
+
   handle_signals (si);
 
   make_splash_dialog (si);
@@ -1816,6 +1850,14 @@ handle_clientmessage (saver_info *si, XE
             }
 	}
     }
+#ifdef HAVE_SCF_SMARTCARD
+  else if (type == XA_SMARTCARD)
+    {
+   	handle_scf_event (si);
+   	return False;
+    }
+#endif /*HAVE_SCF_SMARTCARD*/
+
   else
     {
       char buf [1024];
diff -urp -x '*~' driver/xscreensaver.h driver/xscreensaver.h
--- driver/xscreensaver.h	2006-05-10 08:48:35.728700000 -0700
+++ driver/xscreensaver.h	2006-05-10 08:48:40.873132000 -0700
@@ -20,6 +20,11 @@
 #include <string.h>
 #include <stdio.h>
 
+#ifdef HAVE_SCF_SMARTCARD
+#include <smartcard/scf.h>
+#include "scf-smartcard.h"
+#endif
+
 #include "prefs.h"
 
 extern char *progname;
@@ -183,9 +188,14 @@ struct saver_info {
 
   XtIntervalId stderr_popup_timer;
 
+  /* =======================================================================
+     SCF properties to support smart card use
+     ======================================================================= */
+#ifdef HAVE_SCF_SMARTCARD
+  scf_saver_info *scf_si;
+#endif /* HAVE_SCF_SMARTCARD */
 };
 
-
 /* This structure holds all the data that applies to the screen-specific parts
    of the display connection; if the display has multiple screens, there will
    be one of these for each screen.
@@ -335,6 +345,10 @@
                             int to_screen_no);
 extern int mouse_screen (saver_info *si);
 
+#ifdef HAVE_SCF_SMARTCARD
+extern Bool display_message (saver_info *si);
+#endif /* HAVE_SCF_SMARTCARD */
+
 /* =======================================================================
    For lock.c
    ======================================================================= */
@@ -509,9 +524,28 @@ extern Bool display_is_on_console_p (sav
 extern Visual *get_best_gl_visual (saver_screen_info *ssi);
 extern void check_for_leaks (const char *where);
 
+/* ========================================================================
+   functions exported from scf-smartcard.c
+   ======================================================================== */
+#ifdef HAVE_SCF_SMARTCARD
+extern void scf_set_locked_p (saver_info *si, Bool locked_p);
+extern enum passwd_state scf_passwd_valid_p (saver_info *si, char *typed_passwd);
+extern Bool check_smartcard_dialog (saver_info *si);
+extern char ** get_scf_message (saver_info *);
+extern void init_scf_properties (saver_info *si);
+extern void init_scf_handler (saver_info *si);
+extern void handle_scf_event (saver_info *si);
+extern char * scf_set_passwd_label (saver_info *si);
+extern Bool has_smartcard_event_occurred (void);
+extern void set_smartcard_event_occurred (Bool);
+#endif /* HAVE_SCF_SMARTCARD */
+
 extern Atom XA_VROOT, XA_XSETROOT_ID, XA_ESETROOT_PMAP_ID, XA_XROOTPMAP_ID;
 extern Atom XA_SCREENSAVER, XA_SCREENSAVER_VERSION, XA_SCREENSAVER_ID;
 extern Atom XA_SCREENSAVER_STATUS, XA_LOCK, XA_BLANK;
 extern Atom XA_DEMO, XA_PREFS;
+#ifdef HAVE_SCF_SMARTCARD
+extern Atom XA_SMARTCARD;
+#endif /*HAVE_SCF_SMARTCARD*/
 
 #endif /* __XSCREENSAVER_H__ */
