/*
 * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, and/or sell copies of the Software, and to permit persons
 * to whom the Software is furnished to do so, provided that the above
 * copyright notice(s) and this permission notice appear in all copies of
 * the Software and that both the above copyright notice(s) and this
 * permission notice appear in supporting documentation.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
 * OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * HOLDERS INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL
 * INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING
 * FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * Except as contained in this notice, the name of a copyright holder
 * shall not be used in advertising or otherwise to promote the sale, use
 * or other dealings in this Software without prior written authorization
 * of the copyright holder.
 *
 */

Solaris uses the gtk unlock dialog program originally written by 
Ximian & Wipro, in order to provide a dialog box that works with
the GNOME accessibility framework.   This was done as a fork of
the original xscreensaver because the maintainer would not allow
use of a toolkit in the lock dialog - he has since softened his
stance a bit, but this has not been presented to him to see if it
meets his requirements as spelled out at:
	http://www.jwz.org/xscreensaver/toolkits.html

This file contains changes to the existing xscreensaver source to
enable that - the lock dialog itself is contained in the separate
file sun-src/driver/lock-Gtk.c.

This file also contains changes to make the pam code in xscreensaver
act more like a correct pam client, allowing different interaction
models than just a single password for authentication.

diff -urp -x '*~' config.h.in config.h.in
--- config.h.in	2006-09-18 14:39:56.000000000 -0700
+++ config.h.in	2006-09-19 17:08:14.999476000 -0700
@@ -132,6 +132,9 @@
 /* Define this if you have Gtk 2.x. */
 #undef HAVE_GTK2
 
+/* Define this to build the external lock dialog */
+#undef HAVE_XSCREENSAVER_LOCK
+
 /* Define this if you are running HPUX with so-called ``Secure Passwords'' (if
    you have /usr/include/hpsecurity.h, you probably have this.) I haven't
    tested this one, let me know if it works. */
diff -urp -x '*~' configure.in configure.in
--- configure.in	2006-09-18 13:56:10.000000000 -0700
+++ configure.in	2006-09-19 17:08:15.011239000 -0700
@@ -1858,7 +1858,7 @@ if test "$enable_locking" = yes -a "$wit
     AC_DEFINE(HAVE_PAM)
     AC_DEFINE_UNQUOTED(PAM_SERVICE_NAME,"$pam_service_name")
     
-    PASSWD_LIBS="${PASSWD_LIBS} -lpam"
+    PASSWD_LIBS="${PASSWD_LIBS} -lcmd -lpam"
 
     # libpam typically requires dlopen and dlsym.  On FreeBSD,
     # those are in libc.  On Linux and Solaris, they're in libdl.
@@ -2432,6 +2432,8 @@ if test "$with_gtk" = yes; then
   pkg_check_version        libglade-2.0  1.99.0
   pkg_check_version      gdk-pixbuf-2.0  2.0.0
   pkg_check_version gdk-pixbuf-xlib-2.0  2.0.0
+  pkg_check_version           gconf-2.0  2.6.1
+  pkg_check_version  libloginhelper-1.0  1.0
   have_gtk="$ok"
 
   if test "$have_gtk" = no; then
@@ -2447,6 +2449,9 @@ if test "$with_gtk" = yes; then
   fi
 
   if test "$have_gtk" = yes; then
+#--- Begin SUNW addition
+    AC_DEFINE(HAVE_XSCREENSAVER_LOCK)
+#--- End SUNW addition
     AC_CACHE_CHECK([for Gtk includes], ac_cv_gtk_config_cflags,
                    [ac_cv_gtk_config_cflags=`$pkg_config --cflags $pkgs`])
     AC_CACHE_CHECK([for Gtk libs], ac_cv_gtk_config_libs,
@@ -3500,6 +3505,28 @@ if test "$have_gtk" = yes; then
   ALL_DEMO_PROGRAMS="$PREFERRED_DEMO_PROGRAM $ALL_DEMO_PROGRAMS"
 fi
 
+#--- Begin SUNW addition
+PREFERRED_LOCK_PROGRAM=
+ALL_LOCK_PROGRAMS=
+LOCK_PROGRAM=
+if test "$have_gtk" = yes; then
+  PREFERRED_LOCK_PROGRAM=xscreensaver-lock-Gtk
+  ALL_LOCK_PROGRAMS="$PREFERRED_LOCK_PROGRAM $ALL_LOCK_PROGRAMS"
+  LOCK_PROGRAM=xscreensaver-lock
+fi
+
+if test -r driver/sunlogo.xpm ; then
+	XPM_LOGO_FILE=sunlogo.xpm
+	XPM_LOGO_NAME=sunlogo_xpm
+else
+	XPM_LOGO_FILE=../utils/images/logo-180.xpm
+	XPM_LOGO_NAME=logo_180_xpm
+fi
+
+AC_SUBST([XPM_LOGO_FILE])
+AC_SUBST([XPM_LOGO_NAME])
+
+#--- End SUNW addition
 
 if test "$have_kerberos" = yes; then
   PASSWD_SRCS="$PASSWD_SRCS \$(KERBEROS_SRCS)"
@@ -3642,6 +3669,11 @@ AC_SUBST(INCLUDES)
 
 AC_SUBST(PREFERRED_DEMO_PROGRAM)
 AC_SUBST(ALL_DEMO_PROGRAMS)
+#--- Begin SUNW addition
+AC_SUBST(PREFERRED_LOCK_PROGRAM)
+AC_SUBST(ALL_LOCK_PROGRAMS)
+AC_SUBST(LOCK_PROGRAM)
+#--- End SUNW addition
 AC_SUBST(SAVER_LIBS)
 AC_SUBST(MOTIF_LIBS)
 AC_SUBST(GTK_LIBS)
@@ -4126,7 +4158,8 @@ HACK_CONF_DIR=`echo "${HACK_CONF_DIR}" |
 
 
 # Sanity check the hackdir
-for bad_choice in xscreensaver xscreensaver-demo xscreensaver-command ; do
+# SUNW addition: added xscreensaver-lock to list on next line
+for bad_choice in xscreensaver xscreensaver-demo xscreensaver-command xscreensaver-lock ; do
   if test "${HACKDIR}" = "${bindir}/${bad_choice}" ; then
     echo ""
     AC_MSG_ERROR([\"--with-hackdir=${bindir}/${bad_choice}\" won't work.
diff -urp -x '*~' driver/Makefile.in driver/Makefile.in
--- driver/Makefile.in	2006-09-19 17:08:10.183708000 -0700
+++ driver/Makefile.in	2006-09-19 17:08:15.026509000 -0700
@@ -28,6 +28,7 @@ GTK_APPDIR	= $(GTK_DATADIR)/applications
 GTK_ICONDIR	= $(GTK_DATADIR)/pixmaps
 GTK_GLADEDIR	= $(prefix)/lib/xscreensaver/config
 HACK_CONF_DIR	= @HACK_CONF_DIR@
+LOCK_DIR	= $(libexecdir)
 
 CC		= @CC@
 OBJCC		= @OBJCC@
@@ -41,6 +42,7 @@ SUBP_DEFS	= $(DEFS) -DHACK_PATH='"@HACKD
 GTK_DEFS	= $(DEFS) -DDEFAULT_ICONDIR='"$(GTK_GLADEDIR)"' \
 			-DBINDIR='"$(bindir)"'
 CONF_DEFS	= -DHACK_CONFIGURATION_PATH='"$(HACK_CONF_DIR)"'
+LOCK_DEFS	= $(DEFS) -DLOCKDIR=\"$(LOCK_DIR)\"
 
 LIBS		= @LIBS@
 INTL_LIBS	= @INTLLIBS@
@@ -98,6 +100,8 @@ GTK_SRCS	= demo-Gtk.c demo-Gtk-conf.c \
 		  demo-Gtk-widgets.c demo-Gtk-support.c
 GTK_EXTRA_OBJS  = demo-Gtk-widgets.o demo-Gtk-support.o
 GTK_OBJS	= demo-Gtk.o demo-Gtk-conf.o @GTK_EXTRA_OBJS@
+GTK_LOCK_SRCS	= lock-Gtk.c remote.c
+GTK_LOCK_OBJS	= lock-Gtk.o remote.o
 
 PWENT_SRCS	= passwd-pwent.c
 PWENT_OBJS	= passwd-pwent.o
@@ -216,8 +220,8 @@ GETIMG_LIBS	= $(LIBS) $(X_LIBS) $(XPM_LI
 		  $(X_PRE_LIBS) -lXt -lX11 $(XMU_LIBS) -lXext $(X_EXTRA_LIBS)
 
 EXES		= xscreensaver xscreensaver-command xscreensaver-demo \
-		  xscreensaver-getimage @EXES_OSX@
-EXES2		= @ALL_DEMO_PROGRAMS@
+		  xscreensaver-getimage @EXES_OSX@ @LOCK_PROGRAM@
+EXES2		= @ALL_DEMO_PROGRAMS@ @ALL_LOCK_PROGRAMS@
 EXES_OSX	= pdf2jpeg
 
 SCRIPTS_1	= xscreensaver-getimage-file xscreensaver-getimage-video \
@@ -247,7 +251,7 @@ VMSFILES	= compile_axp.com compile_decc.
 		  vms-getpwnam.c vms-pwd.h vms-hpwd.c vms-validate.c \
 		  vms_axp.opt vms_axp_12.opt vms_decc.opt vms_decc_12.opt
 
-TARFILES	= $(EXTRAS) $(VMSFILES) $(SAVER_SRCS_1) \
+TARFILES	= $(EXTRAS) $(VMSFILES) $(SAVER_SRCS_1) $(GTK_LOCK_SRCS) \
 		  $(MOTIF_SRCS) $(GTK_SRCS) $(PWENT_SRCS) $(PWHELPER_SRCS) \
 		  $(KERBEROS_SRCS) $(PAM_SRCS) $(LOCK_SRCS_1) $(DEMO_SRCS_1) \
 		  $(CMD_SRCS) $(GETIMG_SRCS_1) $(PDF2JPEG_SRCS) $(HDRS) \
@@ -260,7 +264,7 @@ all: $(EXES) $(EXES2)
 tests: $(TEST_EXES)
 
 install:   install-program   install-ad    install-scripts \
-	   install-gnome     install-man   install-xml install-pam
+	   install-gnome     install-man   install-xml 
 uninstall: uninstall-program uninstall-ad  \
 	   uninstall-gnome   uninstall-man uninstall-xml  
 
@@ -272,6 +276,9 @@ install-program: $(EXES)
 	@if [ ! -d $(install_prefix)$(bindir) ]; then			\
 	  $(INSTALL_DIRS) $(install_prefix)$(bindir) ;			\
 	 fi
+	@if [ -n "@LOCK_PROGRAM@" -a ! -d $(install_prefix)$(LOCK_DIR) ]; then \
+	  $(INSTALL_DIRS) $(install_prefix)$(LOCK_DIR) ; 		\
+	 fi
 	@inst="$(INSTALL_PROGRAM)" ;					\
 	if [ @NEED_SETUID@ = yes ]; then				\
 	   me=`PATH="$$PATH:/usr/ucb" whoami` ;				\
@@ -300,6 +307,12 @@ install-program: $(EXES)
 	  echo $(INSTALL_PROGRAM) $$exe $(install_prefix)$(bindir)/$$exe ; \
 	       $(INSTALL_PROGRAM) $$exe $(install_prefix)$(bindir)/$$exe ; \
 	 done
+	@if [ -n "@LOCK_PROGRAM@" ]; then				     \
+	  echo $(INSTALL_PROGRAM) xscreensaver-lock \
+	    $(install_prefix)$(LOCK_DIR)/xscreensaver-lock ; \
+	   $(INSTALL_PROGRAM) xscreensaver-lock \
+	    $(install_prefix)$(LOCK_DIR)/xscreensaver-lock ; \
+	fi
 
 install-ad: XScreenSaver.ad
 	@if [ ! -d $(install_prefix)$(AD_DIR) ]; then			      \
@@ -736,7 +749,7 @@ $(SAVER_UTIL_OBJS):
 
 # How we build object files in this directory.
 .c.o:
-	$(CC) -c $(INCLUDES) $(DEFS) $(CFLAGS) $(X_CFLAGS) $<
+	$(CC) -c $(INCLUDES) $(DEFS) $(INTL_DEFS) $(CFLAGS) $(X_CFLAGS) $<
 
 .m.o:
 	$(OBJCC) -c $(INCLUDES) $(DEFS) $(CFLAGS) $(X_CFLAGS) $<
@@ -757,6 +770,19 @@ demo-Gtk-conf.o: demo-Gtk-conf.c
 	$(CC) -c $(INCLUDES) $(CONF_DEFS) $(GTK_DEFS) $(CFLAGS) $(X_CFLAGS) \
 	  $(srcdir)/demo-Gtk-conf.c
 
+# lock takes an extra -D option.
+lock.o:
+	$(CC) -c $(INCLUDES) $(LOCK_DEFS) $(CFLAGS) $(X_CFLAGS) \
+	  $(srcdir)/lock.c
+
+# lock-Gtk takes extra -D and -I options.
+GTK_LOCK_LOGO_DEFS=-DXPM_LOGO_FILE=\"@XPM_LOGO_FILE@\" \
+		  -DXPM_LOGO_NAME=@XPM_LOGO_NAME@
+
+lock-Gtk.o: lock-Gtk.c
+	$(CC) -c $(INCLUDES) -I$(ICON_SRC) $(GTK_DEFS) \
+	  $(CFLAGS) $(X_CFLAGS) $(INTL_DEFS) $(GTK_LOCK_LOGO_DEFS) \
+	  $(srcdir)/lock-Gtk.c
 
 # How we build the default app-defaults file into the program.
 #
@@ -787,6 +813,15 @@ xscreensaver-demo: @PREFERRED_DEMO_PROGR
 	       cp -p @PREFERRED_DEMO_PROGRAM@@EXEEXT@ $@@EXEEXT@      ;	\
 	fi
 
+xscreensaver-lock: @PREFERRED_LOCK_PROGRAM@
+	$(INSTALL_PROGRAM) @PREFERRED_LOCK_PROGRAM@ $@
+
+xscreensaver-lock-Gtk: $(GTK_LOCK_OBJS)
+	$(CC) $(LDFLAGS) -o $@ $(GTK_LOCK_OBJS) $(LIBS) $(X_LIBS) \
+	$(GTK_LIBS) $(XML_LIBS) $(X_PRE_LIBS) -lXt -lX11 \
+	$(XDPMS_LIBS) -lXext \
+	$(X_EXTRA_LIBS)
+
 xscreensaver-demo-Xm: $(DEMO_OBJS) $(MOTIF_OBJS)
 	$(CC) $(LDFLAGS) -o $@ $(DEMO_OBJS) $(MOTIF_OBJS) $(LIBS) $(X_LIBS) \
 	$(MOTIF_LIBS) $(INTL_LIBS) $(X_PRE_LIBS) -lXt -lX11 \
@@ -808,7 +843,7 @@ pdf2jpeg: $(PDF2JPEG_OBJS)
 
 
 TEST_PASSWD_OBJS = test-passwd.o $(LOCK_OBJS_1) $(PASSWD_OBJS) \
-	 subprocs.o setuid.o splash.o prefs.o \
+	 subprocs.o setuid.o splash.o prefs.o exec.o stderr.o \
 	$(SAVER_UTIL_OBJS)
 test-passwd.o: XScreenSaver_ad.h
 
diff -urp -x '*~' driver/dpms.c driver/dpms.c
--- driver/dpms.c	2005-03-21 18:07:21.000000000 -0800
+++ driver/dpms.c	2006-09-19 17:08:15.026976000 -0700
@@ -50,6 +50,7 @@
 
 #include <stdio.h>
 #include <X11/Xlib.h>
+# include <X11/Intrinsic.h>
 
 #ifdef HAVE_DPMS_EXTENSION   /* almost the whole file */
 
diff -urp -x '*~' driver/lock.c driver/lock.c
--- driver/lock.c	2006-05-17 16:35:54.000000000 -0700
+++ driver/lock.c	2006-09-19 17:08:15.056092000 -0700
@@ -23,6 +23,9 @@
 #include <X11/Xos.h>		/* for time() */
 #include <time.h>
 #include <sys/time.h>
+#include <errno.h>
+#include <signal.h>
+#include "exec.h"
 #include "xscreensaver.h"
 #include "resources.h"
 
@@ -74,110 +77,296 @@ vms_passwd_valid_p(char *pw, Bool verbos
 
 #endif /* VMS */
 
+extern int kill_job (saver_info *si, pid_t pid, int signal);
+extern struct screenhack_job *make_job (pid_t pid, int screen, const char *cmd);
+void hack_uid (saver_info *si);
+ 
+Bool g_passwd_dialog_created = 0;
 
 #undef MAX
 #define MAX(a,b) ((a)>(b)?(a):(b))
 
-enum passwd_state { pw_read, pw_ok, pw_null, pw_fail, pw_cancel, pw_time };
-
-struct passwd_dialog_data {
-
-  saver_screen_info *prompt_screen;
-  int previous_mouse_x, previous_mouse_y;
-
-  enum passwd_state state;
-  char typed_passwd [80];
-  XtIntervalId timer;
-  int i_beam;
-
-  float ratio;
-  Position x, y;
-  Dimension width;
-  Dimension height;
-  Dimension border_width;
-
-  Bool show_stars_p; /* "I regret that I have but one asterisk for my country."
-                        -- Nathan Hale, 1776. */
-
-  char *heading_label;
-  char *body_label;
-  char *user_label;
-  char *passwd_label;
-  char *date_label;
-  char *user_string;
-  char *passwd_string;
-  char *login_label;
-  char *uname_label;
-
-  Bool show_uname_p;
-
-  XFontStruct *heading_font;
-  XFontStruct *body_font;
-  XFontStruct *label_font;
-  XFontStruct *passwd_font;
-  XFontStruct *date_font;
-  XFontStruct *button_font;
-  XFontStruct *uname_font;
-
-  Pixel foreground;
-  Pixel background;
-  Pixel passwd_foreground;
-  Pixel passwd_background;
-  Pixel thermo_foreground;
-  Pixel thermo_background;
-  Pixel shadow_top;
-  Pixel shadow_bottom;
-  Pixel button_foreground;
-  Pixel button_background;
-
-  Dimension logo_width;
-  Dimension logo_height;
-  Dimension thermo_width;
-  Dimension internal_border;
-  Dimension shadow_width;
-
-  Dimension passwd_field_x, passwd_field_y;
-  Dimension passwd_field_width, passwd_field_height;
-
-  Dimension login_button_x, login_button_y;
-  Dimension login_button_width, login_button_height;
-
-  Dimension thermo_field_x, thermo_field_y;
-  Dimension thermo_field_height;
-
-  Pixmap logo_pixmap;
-  Pixmap logo_clipmask;
-  int logo_npixels;
-  unsigned long *logo_pixels;
-
-  Cursor passwd_cursor;
-  Bool login_button_down_p;
-  Bool login_button_p;
-  Bool login_button_enabled_p;
-
-  Pixmap save_under;
-};
+/* enum passwd_state & struct passwd_dialog_data moved to xscreensaver.h */
 
+static void make_window (saver_info *si, enum window_type w_type);
 static void draw_passwd_window (saver_info *si);
-static void update_passwd_window (saver_info *si, const char *printed_passwd,
+       void update_passwd_window (saver_info *si, const char *printed_passwd,
 				  float ratio);
-static void destroy_passwd_window (saver_info *si);
+       void destroy_passwd_window (saver_info *si);
 static void undo_vp_motion (saver_info *si);
 static void handle_passwd_button (saver_info *si, XEvent *event);
 
+extern Atom XA_UNLOCK_RATIO;
 
-static void
+
+static int  ignore_all_errors_ehandler (Display *dpy, XErrorEvent *error);
+
+#ifdef HAVE_XSCREENSAVER_LOCK
+
+int
+write_to_child (saver_info* si, char* msg)
+{
+      if (si->external_passwd && g_passwd_dialog_created && si->pw_data->stdin_fd != -1)
+	{
+	  ssize_t len;
+	  char *nlmsg;
+
+	  nlmsg = (char *)malloc (strlen (msg) + 2);
+	  sprintf (nlmsg, "%s\n", msg);
+
+	  if (si->prefs.verbose_p)
+	    {
+              fprintf (stderr, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+              fprintf (stderr, "HAVE_SCRSVR_LOCK message is:%s writing to fd:%d\n",
+	                 	   msg, si->pw_data->stdin_fd);
+              fprintf (stderr, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+	    }
+
+	write_msg:
+	  len = write (si->pw_data->stdin_fd, nlmsg, strlen (nlmsg));
+	  if (len < 0 && errno == EINTR)
+	    goto write_msg;
+
+	  free (nlmsg);	  
+          return (1);
+	}
+      return (0); /* if we didnt write anything return 0*/
+}
+
+static int
+sane_dup2 (int fd1, int fd2)
+{
+  int ret;
+
+ retry:
+  ret = dup2 (fd1, fd2);
+  if (ret < 0 && errno == EINTR)
+    goto retry;
+
+  return ret;
+}
+
+static int
+close_and_invalidate (int *fd)
+{
+  int ret;
+
+  ret = close (*fd);
+  *fd = -1;
+
+  return ret;
+}
+
+void
+handle_passwd_input (XtPointer data, int *fd, XtInputId *id)
+{
+  saver_info *si = (saver_info *)data;
+  saver_preferences *p = &si->prefs;
+  char buffer[1024];
+  char *s;
+
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "passwd input handler() fd=%d\n",*fd);
+
+  s = fgets (buffer, sizeof (buffer), si->pw_data->input_file);
+  if (!s)
+    {
+      if (si->prefs.verbose_p)
+	{
+	  fprintf (stderr, "done reading...\n");
+	  fprintf (stderr, "removing input handler...\n");
+	}
+      XtRemoveInput (*id);
+      si->pw_data->stdout_input_id = 0;
+
+      if (si->pw_data->state == pw_read)
+	si->pw_data->state = pw_null;
+
+      if (si->prefs.verbose_p)
+        fprintf (stderr, "passwd input handler() returning...done reading\n");
+ 
+      return;
+    }
+
+  if (si->pw_data->got_windowid)
+    {
+      char *nl;
+      if (si->prefs.verbose_p)
+	fprintf (stderr, "got a password\n");
+      nl = strchr (s, '\n');
+      if (nl)
+	*nl = '\0';
+      si->pw_data->passwd_string = strdup (s);
+      if (si->prefs.verbose_p)
+        fprintf(stderr,"Dude got password and saving it in passwd_string:%s\n", s);
+
+     /* We want to send null to lock dialog to say we are working on authentication*/
+     si->pw_data->state = pw_null;
+    }
+  else /* Get the window id of lock dialog from Child ***/
+    {
+      Window window = strtoul (s, NULL, 0);
+      /* FIXME: what to revert to? */
+      XSetInputFocus (si->dpy, window, RevertToParent, CurrentTime);
+      XSync (si->dpy, False);
+      si->pw_data->got_windowid = True;
+      si->passwd_dialog = window;
+      /**g_passwd_dialog_created = True;**/ /*set global flag to check in timers.c*/
+      if (si->prefs.verbose_p)
+	fprintf (stderr, "<---handle_passwd_input(): gotwindowid:0x%x\n", passwd_win);
+    }
+}
+
+/* returns successful fork/exec */
+Bool
+spawn_external_passwd_process (saver_info *si, passwd_dialog_data *pw)
+{
+  saver_preferences *p = &si->prefs;
+  pid_t forked;
+  const char *command = LOCKDIR "/xscreensaver-lock";
+  int stdin_pipe[2]  = { -1, -1 };
+  int stdout_pipe[2] = { -1, -1 };
+
+  si->passwd_pid = 0;
+  pw->stdin_fd = pw->stdout_fd = -1;
+  pw->got_windowid = False;
+
+  if (si->prefs.verbose_p)
+     fprintf(stderr, "-->spawn_external_passwd()\n");
+
+  if (pipe (stdin_pipe) < 0)
+   {
+    perror ("pipe(stdin_pipe) failed!");
+    return False;
+   }
+
+  if (pipe (stdout_pipe) < 0)
+    {
+      perror ("pipe(stdout_pipe) failed!");
+      close_and_invalidate (&stdin_pipe[0]);
+      close_and_invalidate (&stdin_pipe[1]);
+      return False;
+    }
+  switch ((int) (forked = fork ()))
+    {
+    case -1:
+      fprintf (stderr, "%s: ", blurb ());
+      perror ("couldn't fork");
+
+      close_and_invalidate (&stdin_pipe[0]);
+      close_and_invalidate (&stdin_pipe[1]);
+      close_and_invalidate (&stdout_pipe[0]);
+      close_and_invalidate (&stdout_pipe[1]);
+
+      return False;
+
+    case 0:
+      close (ConnectionNumber (si->dpy)); /* close display fd */
+      /* limit_subproc_memory (p->inferior_memory_limit, p->verbose_p); */
+      /* hack_subproc_environment (ssi); */ /* FIX $DISPLAY */
+
+      /* Inside Child Process */
+      if (p->verbose_p)
+	fprintf (stderr, "%s: spawning \"%s\" in pid %lu.\n",
+		 blurb(), command, (unsigned long) getpid ());
+
+      close_and_invalidate (&stdin_pipe[1]);
+      close_and_invalidate (&stdout_pipe[0]);
+
+      sane_dup2 (stdin_pipe[0], 0);  /* Listen to Parent from here */
+      sane_dup2 (stdout_pipe[1], 9); /* Talk to Parent from here */
+
+      /* Make sure we have relinquished setuid privs or lock dialog gtk
+       * program will not run as libgtk is not setuid safe.
+       */
+      hack_uid (si);
+
+      exec_command (p->shell, command, 0);
+      /* print_path_error (command); */
+      fprintf (stderr, "%s: couldn't exec: %s\n", 
+	       blurb (), command);
+      abort ();
+
+    default:
+      /* In Parent */
+      make_job(forked, 0, command);
+      close_and_invalidate (&stdin_pipe[0]);
+      close_and_invalidate (&stdout_pipe[1]);
+
+      sane_dup2 (stdin_pipe[0], 0);  /* Listen to Child from here */
+      sane_dup2 (stdout_pipe[1], 13); /* Talk to Child from here */
+
+      pw->stdin_fd   = stdin_pipe[1];   /* Talk to child from here */
+      pw->stdout_fd  = stdout_pipe[0];  /* Listen to Child from here */
+      si->passwd_pid = forked;
+
+      write_to_child (si, "Hello There"); /* Send a test message to Child */
+
+      /* Password from child dialog comes through this pipe/fd */
+      pw->input_file = fdopen (pw->stdout_fd, "r");
+
+      pw->stdout_input_id = XtAppAddInput (si->app, pw->stdout_fd,
+					   (XtPointer) XtInputReadMask,
+					   handle_passwd_input,
+					   si);
+
+      /* Set global flag to indicate that lock dialog is visible */
+      g_passwd_dialog_created = True;
+      return True;
+    }
+
+  /* shouldn't reach */
+  abort ();
+  return False;
+}
+#endif /* HAVE_XSCREENSAVER_LOCK */
+
+void
 make_passwd_window (saver_info *si)
 {
+  make_window(si, w_dialog);
+}
+
+
+static void
+make_window (saver_info *si, enum window_type w_type)
+{
   struct passwd *p = getpwuid (getuid ());
   XSetWindowAttributes attrs;
   unsigned long attrmask = 0;
-  passwd_dialog_data *pw = (passwd_dialog_data *) calloc (1, sizeof(*pw));
+  passwd_dialog_data *pw = si->pw_data;
   Screen *screen;
   Colormap cmap;
   char *f;
   saver_screen_info *ssi = &si->screens [mouse_screen (si)];
 
+  if (si->prefs.verbose_p)
+    fprintf(stderr, "-->make_window()\n");
+
+#ifdef HAVE_XSCREENSAVER_LOCK
+  if (spawn_external_passwd_process (si, si->pw_data))
+    { 
+/***************
+          if (si->prefs.verbose_p)
+	    fprintf(stderr, "spawning external passwd process in make_window()\n");
+*******************/
+
+/****************mali blank_fails remove this...
+	  if(!blank_screen(si))
+	    fprintf(stderr, "Failed to blank the screen\n");
+*******************/
+
+      si->pw_data->ratio = 1.0;
+      si->pw_data->w_type = w_type;
+      /*si->pw_data = pw;*/
+      si->external_passwd = True;
+      return;
+    }
+  si->external_passwd = False;
+  /* FIXME: don't abort() */
+  /*abort ();*/
+#endif /* HAVE_XSCREENSAVER_LOCK */ 
+
   /* Display the button only if the "newLoginCommand" pref is non-null.
    */
   pw->login_button_p = (si->prefs.new_login_command &&
@@ -196,6 +385,8 @@ make_passwd_window (saver_info *si)
   screen = pw->prompt_screen->screen;
   cmap = DefaultColormapOfScreen (screen);
 
+  pw->w_type = w_type;  
+  pw->state = pw_read;
   pw->ratio = 1.0;
 
   pw->show_stars_p = get_boolean_resource(si->dpy, "passwd.asterisks", 
@@ -254,9 +445,6 @@ make_passwd_window (saver_info *si)
   }
 # endif
 
-  pw->user_string = strdup (p && p->pw_name ? p->pw_name : "???");
-  pw->passwd_string = strdup("");
-
   f = get_string_resource (si->dpy, "passwd.headingFont", "Dialog.Font");
   pw->heading_font = XLoadQueryFont (si->dpy, (f ? f : "fixed"));
   if (!pw->heading_font) pw->heading_font = XLoadQueryFont (si->dpy, "fixed");
@@ -374,84 +562,6 @@ make_passwd_window (saver_info *si)
 	pw->height += ascent + descent;
       }
 
-    /* Measure the body_label. */
-    XTextExtents (pw->body_font,
-		  pw->body_label, strlen(pw->body_label),
-		  &direction, &ascent, &descent, &overall);
-    if (overall.width > pw->width) pw->width = overall.width;
-    pw->height += ascent + descent;
-
-    {
-      Dimension w2 = 0, w3 = 0, button_w = 0;
-      Dimension h2 = 0, h3 = 0, button_h = 0;
-      const char *passwd_string = "MMMMMMMMMMMM";
-
-      /* Measure the user_label. */
-      XTextExtents (pw->label_font,
-		    pw->user_label, strlen(pw->user_label),
-		    &direction, &ascent, &descent, &overall);
-      if (overall.width > w2)  w2 = overall.width;
-      h2 += ascent + descent;
-
-      /* Measure the passwd_label. */
-      XTextExtents (pw->label_font,
-		    pw->passwd_label, strlen(pw->passwd_label),
-		    &direction, &ascent, &descent, &overall);
-      if (overall.width > w2)  w2 = overall.width;
-      h2 += ascent + descent;
-
-      /* Measure the user_string. */
-      XTextExtents (pw->passwd_font,
-		    pw->user_string, strlen(pw->user_string),
-		    &direction, &ascent, &descent, &overall);
-      overall.width += (pw->shadow_width * 4);
-      ascent += (pw->shadow_width * 4);
-      if (overall.width > w3)  w3 = overall.width;
-      h3 += ascent + descent;
-
-      /* Measure the (maximally-sized, dummy) passwd_string. */
-      XTextExtents (pw->passwd_font,
-		    passwd_string, strlen(passwd_string),
-		    &direction, &ascent, &descent, &overall);
-      overall.width += (pw->shadow_width * 4);
-      ascent += (pw->shadow_width * 4);
-      if (overall.width > w3)  w3 = overall.width;
-      h3 += ascent + descent;
-
-      w2 = w2 + w3 + (pw->shadow_width * 2);
-      h2 = MAX (h2, h3);
-
-      pw->login_button_width = 0;
-      pw->login_button_height = 0;
-
-      if (pw->login_button_p)
-        {
-          pw->login_button_enabled_p = True;
-
-          /* Measure the "New Login" button */
-          XTextExtents (pw->button_font, pw->login_label,
-                        strlen (pw->login_label),
-                        &direction, &ascent, &descent, &overall);
-          button_w = overall.width;
-          button_h = ascent + descent;
-
-          /* Add some horizontal padding inside the buttons. */
-          button_w += ascent;
-
-          button_w += ((ascent + descent) / 2) + (pw->shadow_width * 2);
-          button_h += ((ascent + descent) / 2) + (pw->shadow_width * 2);
-
-          pw->login_button_width = button_w;
-          pw->login_button_height = button_h;
-
-          w2 = MAX (w2, button_w);
-          h2 += button_h * 1.5;
-        }
-
-      if (w2 > pw->width)  pw->width  = w2;
-      pw->height += h2;
-    }
-
     pw->width  += (pw->internal_border * 2);
     pw->height += (pw->internal_border * 4);
 
@@ -570,7 +680,7 @@ make_passwd_window (saver_info *si)
                    pw->prompt_screen->number);
   undo_vp_motion (si);
 
-  si->pw_data = pw;
+  /*mali si->pw_data = pw; */
 
   if (cmap)
     XInstallColormap (si->dpy, cmap);
@@ -590,6 +700,10 @@ draw_passwd_window (saver_info *si)
   int sw;
   int tb_height;
 
+
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "-->draw_passwd_window() case w_dialog!!\n");
+
   height = (pw->heading_font->ascent + pw->heading_font->descent +
             pw->body_font->ascent + pw->body_font->descent +
             (2 * MAX ((pw->label_font->ascent + pw->label_font->descent),
@@ -865,7 +979,7 @@ draw_passwd_window (saver_info *si)
 }
 
 
-static void
+void
 update_passwd_window (saver_info *si, const char *printed_passwd, float ratio)
 {
   passwd_dialog_data *pw = si->pw_data;
@@ -875,8 +989,20 @@ update_passwd_window (saver_info *si, co
   XRectangle rects[1];
 
   pw->ratio = ratio;
+
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "-->update_passwd_window() w_dialog !!\n");
+  
+  if (!si->pw_data->got_windowid )
+    {
+      if (si->prefs.verbose_p)
+	fprintf (stderr, "-->update_passwd_window() lockdialog not created returning.. !!\n");
+      return;
+    }
+  
   gcv.foreground = pw->passwd_foreground;
-  gcv.font = pw->passwd_font->fid;
+  if (pw->passwd_font)
+    gcv.font = pw->passwd_font->fid;
   gc1 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground|GCFont, &gcv);
   gcv.foreground = pw->passwd_background;
   gc2 = XCreateGC (si->dpy, si->passwd_dialog, GCForeground, &gcv);
@@ -988,23 +1114,77 @@ update_passwd_window (saver_info *si, co
 }
 
 
-static void
+void
 destroy_passwd_window (saver_info *si)
 {
   saver_preferences *p = &si->prefs;
   passwd_dialog_data *pw = si->pw_data;
-  saver_screen_info *ssi = pw->prompt_screen;
-  Colormap cmap = DefaultColormapOfScreen (ssi->screen);
-  Pixel black = BlackPixelOfScreen (ssi->screen);
-  Pixel white = WhitePixelOfScreen (ssi->screen);
+  saver_screen_info *ssi;
+  Colormap cmap;
+  Pixel black, white;
   XEvent event;
 
-  memset (pw->typed_passwd, 0, sizeof(pw->typed_passwd));
-  memset (pw->passwd_string, 0, strlen(pw->passwd_string));
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "destroy_passwd_window\n");
+
+  if (pw == NULL || pw->got_windowid == 0 || si->external_passwd == 0)
+    return;
 
   if (pw->timer)
     XtRemoveTimeOut (pw->timer);
 
+  /*reset global flag to indicate passwd dialog is no longer there*/
+  g_passwd_dialog_created = 0;
+
+#ifdef HAVE_XSCREENSAVER_LOCK
+  if (si->external_passwd)
+    {
+      /* kill the child etc. */
+      
+      if (si->passwd_dialog)
+	{
+	  XErrorHandler old_handler;
+	  
+	  XSync (si->dpy, False);
+	  old_handler = XSetErrorHandler (ignore_all_errors_ehandler);
+	  
+	  XDestroyWindow (si->dpy, si->passwd_dialog);
+	  XSync (si->dpy, False);
+	  XSetErrorHandler (old_handler);
+	  
+	  si->passwd_dialog = 0;
+	}
+      
+      if (pw->stdout_input_id)
+	XtRemoveInput (pw->stdout_input_id);
+      if (pw->stdin_fd != -1)
+	close_and_invalidate (&pw->stdin_fd);
+      if (pw->input_file)
+	fclose (pw->input_file);
+      else if (pw->stdout_fd != -1)
+	close_and_invalidate (&pw->stdout_fd);
+      
+      if (si->passwd_pid)
+	{
+	  kill_job (si, si->passwd_pid, SIGTERM);
+	  si->passwd_pid = 0;
+	}
+      
+      si->external_passwd = False;
+     }     
+  else
+#endif /* HAVE_XSCREENSAVER_LOCK */
+{
+  if (p->verbose_p)
+    fprintf (stderr, "In destroy_passwd else case..i.e. si->external-passwd is False already\n");
+
+  memset (pw->typed_passwd, 0, sizeof(pw->typed_passwd));
+  memset (pw->passwd_string, 0, strlen(pw->passwd_string));
+
+  ssi = pw->prompt_screen;
+  cmap = DefaultColormapOfScreen (ssi->screen);
+  black = BlackPixelOfScreen (ssi->screen);
+  white = WhitePixelOfScreen (ssi->screen);
   move_mouse_grab (si, RootWindowOfScreen (ssi->screen),
                    ssi->cursor, ssi->number);
 
@@ -1105,10 +1285,13 @@ destroy_passwd_window (saver_info *si)
 
   if (cmap)
     XInstallColormap (si->dpy, cmap);
-
+}
   memset (pw, 0, sizeof(*pw));
+/*** NO mali99 we only create a copy of pw in main and keep it
+     so dont free it.
   free (pw);
   si->pw_data = 0;
+  ************/
 }
 
 
@@ -1314,17 +1497,64 @@ passwd_animate_timer (XtPointer closure,
   int tick = 166;
   passwd_dialog_data *pw = si->pw_data;
 
-  if (!pw) return;
+/*  if (si->prefs.verbose_p)
+   fprintf (stderr,"-->passwd_animate_timer()\n");
+**/
+
+  /*We want to make sure dialog isup before we try to animate**/
+  if (!si->external_passwd || !g_passwd_dialog_created) 
+   {
+    if (si->prefs.verbose_p)
+      fprintf (stderr,"-->passwd_animate_timer() returning..no dialog yet\n");
+    return;
+   }
 
   pw->ratio -= (1.0 / ((double) si->prefs.passwd_timeout / (double) tick));
   if (pw->ratio < 0)
     {
       pw->ratio = 0;
-      if (pw->state == pw_read)
+      if (pw->state == pw_read || pw->state == pw_null)
+       {
 	pw->state = pw_time;
+       }
     }
 
+/*** Communicating with the Child lock dialog...sending ratio back... mali99***/
+#ifdef HAVE_XSCREENSAVER_LOCK
+  if (si->passwd_dialog)
+    {
+      XEvent event;
+      Bool status;
+      XErrorHandler old_handler;
+
+/*      fprintf (stderr,"-->passwd_animate_timer() sending ratio to child\n");
+**/
+
+      event.xany.type = ClientMessage;
+      event.xclient.display = si->dpy;
+      event.xclient.window = si->passwd_dialog;
+      event.xclient.message_type = XA_UNLOCK_RATIO;
+      event.xclient.format = 32;
+      memset (&event.xclient.data, 0, sizeof (event.xclient.data));
+      event.xclient.data.l[0] = (long)(pw->ratio * 100);
+      event.xclient.data.l[1] = 0;
+      event.xclient.data.l[2] = 0;
+
+      XSync (si->dpy, False);
+      old_handler = XSetErrorHandler (ignore_all_errors_ehandler);
+      
+      status = XSendEvent (si->dpy, si->passwd_dialog, False, 0L, &event);
+
+      XSync (si->dpy, False);
+      XSetErrorHandler (old_handler);
+
+      if (!status)
+	fprintf (stderr, "%s: error sending ratio to lock dialog\n", blurb ());
+      
+    }
+#else /* !HAVE_XSCREENSAVER_LOCK */
   update_passwd_window (si, 0, pw->ratio);
+#endif /* !HAVE_XSCREENSAVER_LOCK */
 
   if (pw->state == pw_read)
     pw->timer = XtAppAddTimeOut (si->app, tick, passwd_animate_timer,
@@ -1420,11 +1650,15 @@ handle_passwd_key (saver_info *si, XKeyE
         {
           update_passwd_window (si, "Checking...", pw->ratio);
           XSync (si->dpy, False);
-          if (passwd_valid_p (typed_passwd, p->verbose_p))
+
+/***************mali99************************************************
+          if (passwd_valid_p (typed_passwd, p->verbose_p, PAM_SERVICE))
             pw->state = pw_ok;
           else
             pw->state = pw_fail;
           update_passwd_window (si, "", pw->ratio);
+****************************************************************************/
+            pw->state = pw_ok;
         }
       break;
 
@@ -1467,7 +1701,7 @@ handle_passwd_key (saver_info *si, XKeyE
 }
 
 
-static void
+void
 passwd_event_loop (saver_info *si)
 {
   saver_preferences *p = &si->prefs;
@@ -1480,6 +1714,43 @@ passwd_event_loop (saver_info *si)
   while (si->pw_data && si->pw_data->state == pw_read)
     {
       XtAppNextEvent (si->app, &event);
+#ifdef HAVE_XSCREENSAVER_LOCK
+      if (event.xany.type == KeyPress)
+	{
+	  if (si->pw_data->got_windowid)
+	    {
+	      Bool status;
+	      XErrorHandler old_handler;
+	     
+              if(p->verbose_p)
+               fprintf (stderr, "event loop..gotwindowid..and keypress event...\n");
+
+               event.xany.window = si->passwd_dialog;
+
+              XSync (si->dpy, False);
+              old_handler = XSetErrorHandler (ignore_all_errors_ehandler);
+
+              status = 
+	XSendEvent (si->dpy, si->passwd_dialog, False, KeyPressMask, &event);
+              XSync (si->dpy, False);
+              XSetErrorHandler (old_handler);
+
+              if (p->verbose_p)
+                {
+                  if (status)
+                    fprintf (stderr, "sent key...\n");
+                  else
+                    fprintf (stderr, "error sending key...\n");
+                }
+	    }
+	  else
+	    {
+	      if (p->verbose_p)
+		fprintf (stderr, "got keypress but no window id yet :(\n");
+	      XtDispatchEvent (&event);
+	    }
+	}
+#else /* !HAVE_XSCREENSAVER_LOCK */
       if (event.xany.window == si->passwd_dialog && event.xany.type == Expose)
 	draw_passwd_window (si);
       else if (event.xany.type == KeyPress)
@@ -1491,16 +1762,34 @@ passwd_event_loop (saver_info *si)
                 event.xany.type == ButtonRelease) && 
                si->pw_data->login_button_p)
 	handle_passwd_button (si, &event);
+#endif /* !HAVE_XSCREENSAVER_LOCK */
+      else if (event.xany.window == si->passwd_dialog && event.xany.type == Expose &&
+               si->pw_data->passwd_label != NULL)
+       {
+          if(p->verbose_p)
+            fprintf (stderr, "event loop...and expose event.should update lock with new label...\n");
+          /***if (si->pw_data->passwd_label)**/
+          update_passwd_window (si, si->pw_data->passwd_label, pw->ratio);
+          free (si->pw_data->passwd_label);
+          si->pw_data->passwd_label = 0;
+	  si->pw_data->state = pw_read;
+       }
+
       else
 	XtDispatchEvent (&event);
     }
 
   switch (si->pw_data->state)
     {
-    case pw_ok:   msg = 0; break;
-    case pw_null: msg = ""; break;
-    case pw_time: msg = "Timed out!"; break;
-    default:      msg = (caps_p ? "CapsLock?" : "Sorry!"); break;
+    case pw_ok:   msg = strdup("pw_ok"); break;
+    case pw_null: msg = strdup("pw_null"); break;
+    case pw_time: msg = strdup("pw_time"); break;
+    case pw_read: msg = strdup("pw_read"); break;
+    case pw_fail: msg = strdup("pw_fail"); break;
+    case pw_cancel: msg = strdup("pw_cancel"); break;
+    default:      msg = 0; 
+	fprintf(stderr, "si->pw_data->state is bad, serious error\n");
+        break;
     }
 
   if (si->pw_data->state == pw_fail)
@@ -1510,7 +1799,12 @@ passwd_event_loop (saver_info *si)
     switch (si->pw_data->state)
       {
       case pw_ok:
-	fprintf (stderr, "%s: password correct.\n", blurb()); break;
+       {
+	fprintf (stderr, "%s: password correct.\n", blurb());
+	fprintf (stderr, "%s: setting state to be null.\n", blurb());
+        si->pw_data->state = pw_null;
+        break;
+       }
       case pw_fail:
 	fprintf (stderr, "%s: password incorrect!%s\n", blurb(),
                  (caps_p ? "  (CapsLock)" : ""));
@@ -1520,7 +1814,8 @@ passwd_event_loop (saver_info *si)
 	fprintf (stderr, "%s: password entry cancelled.\n", blurb()); break;
       case pw_time:
 	fprintf (stderr, "%s: password entry timed out.\n", blurb()); break;
-      default: break;
+      default: 
+        break;
       }
 
 #ifdef HAVE_SYSLOG
@@ -1568,17 +1863,57 @@ passwd_event_loop (saver_info *si)
 	fprintf (real_stderr,
 		 "%s: WARNING: %d failed attempts to unlock the screen.\n",
 		 blurb(), si->unlock_failures);
-      fflush (real_stderr);
 
       si->unlock_failures = 0;
     }
 
   if (msg)
     {
+	  if (p->verbose_p)
+	    {
+              fprintf (stderr, "..eventloop...msg is:%s\n",msg);
+            }
+#ifdef HAVE_XSCREENSAVER_LOCK
+    /* DONT NEED TO SEND ANY INFO TO CHILD AT THIS STAGE */
+    /*  if (write_to_child (si, msg));**/ /*if write is successful do nothing*/
+      free(msg);
+
+      /*********************************************************
+      if (si->external_passwd && si->pw_data->stdin_fd != -1)
+	{
+	  ssize_t len;
+	  char *nlmsg;
+
+	  nlmsg = (char *)malloc (strlen (msg) + 2);
+	  sprintf (nlmsg, "%s\n", msg);
+
+	  if (p->verbose_p)
+	    {
+              fprintf (stderr, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+              fprintf (stderr, "HAVE_SCRSVR_LOCK message is:%s writing to fd:%d\n",
+	                 	   msg, si->pw_data->stdin_fd);
+              fprintf (stderr, "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n");
+	    }
+
+	write_msg:
+	  len = write (si->pw_data->stdin_fd, nlmsg, strlen (nlmsg));
+	  if (len < 0 && errno == EINTR)
+	    goto write_msg;
+
+	  free (nlmsg);	  
+	}
+      else
+      ******************************************************************************/
+#endif /* HAVE_XSCREENSAVER_LOCK */
+/************
+    {
       si->pw_data->i_beam = 0;
       update_passwd_window (si, msg, 0.0);
+    }
+************/
+
       XSync (si->dpy, False);
-      sleep (1);
+      usleep (250000);  /* 1/4 second */
 
       /* Swallow all pending KeyPress/KeyRelease events. */
       {
@@ -1590,7 +1925,7 @@ passwd_event_loop (saver_info *si)
 }
 
 
-static void
+void
 handle_typeahead (saver_info *si)
 {
   passwd_dialog_data *pw = si->pw_data;
@@ -1607,7 +1942,13 @@ handle_typeahead (saver_info *si)
 
   memset (si->unlock_typeahead, '*', strlen(si->unlock_typeahead));
   si->unlock_typeahead[i] = 0;
+#ifdef HAVE_XSCREENSAVER_LOCK
+  /* FIXME: bugzilla.gnome.org #77077 */
+  /* need to handle this in the external dialog case */
+
+#else
   update_passwd_window (si, si->unlock_typeahead, pw->ratio);
+#endif /* !HAVE_XSCREENSAVER_LOCK */
 
   free (si->unlock_typeahead);
   si->unlock_typeahead = 0;
@@ -1623,12 +1964,14 @@ unlock_p (saver_info *si)
   raise_window (si, True, True, True);
 
   if (p->verbose_p)
-    fprintf (stderr, "%s: prompting for password.\n", blurb());
+    fprintf (stderr, "%s: -->unlock_p()\n", blurb());
 
+/*******mali99**/
   if (si->pw_data || si->passwd_dialog)
     destroy_passwd_window (si);
 
   make_passwd_window (si);
+/****mali99*********/
 
   compose_status = calloc (1, sizeof (*compose_status));
 
@@ -1636,6 +1979,7 @@ unlock_p (saver_info *si)
   passwd_event_loop (si);
 
   status = (si->pw_data->state == pw_ok);
+
   destroy_passwd_window (si);
 
   free (compose_status);
diff -urp -x '*~' driver/passwd-kerberos.c driver/passwd-kerberos.c
--- driver/passwd-kerberos.c	2005-06-21 20:20:11.000000000 -0700
+++ driver/passwd-kerberos.c	2006-09-19 17:08:15.056804000 -0700
@@ -178,7 +178,7 @@ key_to_key(char *user, char *instance, c
    some sites. So, we do a quick, painful hack with a tmpfile.
  */
 Bool
-kerberos_passwd_valid_p (const char *typed_passwd, Bool verbose_p)
+kerberos_passwd_valid_p (const char *typed_passwd, Bool verbose_p, int whichService)
 {
 # ifdef HAVE_DARWIN
     return (klNoErr ==
diff -urp -x '*~' driver/passwd-pam.c driver/passwd-pam.c
--- driver/passwd-pam.c	2006-09-18 14:01:00.000000000 -0700
+++ driver/passwd-pam.c	2006-09-19 17:08:15.067544000 -0700
@@ -39,11 +39,18 @@
 #ifndef NO_LOCKING  /* whole file */
 
 #include <stdlib.h>
+#include <xscreensaver-intl.h>
+
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 
-extern char *blurb(void);
+# ifdef sun
+#  include <deflt.h>
+# endif
+
+
+/*extern char *blurb(void);*/
 
 
 #include <stdio.h>
@@ -57,6 +64,25 @@ extern char *blurb(void);
 
 #include <sys/stat.h>
 
+#include <X11/Intrinsic.h>
+#include <X11/Xos.h>            /* for time() */
+#include <time.h>
+#include <sys/time.h>
+#include <errno.h>
+#include <signal.h>
+#include "xscreensaver.h"
+
+extern int write_to_child (saver_info* si, char* msg);
+extern void make_passwd_window (saver_info* si);
+extern void destroy_passwd_window (saver_info* si);
+extern void handle_typeahead (saver_info* si);
+extern void update_passwd_window (saver_info *si, const char *printed_passwd, float ratio);
+extern void passwd_event_loop(saver_info* si);
+extern passwd_dialog_data* ptr_mygtkpwd;
+
+extern saver_info *global_si_kludge;
+extern Bool g_passwd_dialog_created;
+
 extern sigset_t block_sigchld (void);
 extern void unblock_sigchld (void);
 
@@ -68,6 +94,9 @@ extern void unblock_sigchld (void);
 #define True  1
 #define False 0
 
+
+Bool we_have_pam;
+
 #undef countof
 #define countof(x) (sizeof((x))/sizeof(*(x)))
 
@@ -78,18 +107,18 @@ extern void unblock_sigchld (void);
 # define PAM_REFRESH_CRED PAM_CRED_REFRESH
 #endif
 
-static int pam_conversation (int nmsgs,
-                             const struct pam_message **msg,
+int pam_conversation (int nmsgs,
+                      struct pam_message **msg,
                              struct pam_response **resp,
                              void *closure);
 
 struct pam_closure {
   const char *user;
-  const char *typed_passwd;
+/*  const char *typed_passwd; No need for this, pam_conv should get this*/
   Bool verbose_p;
 };
 
-Bool pam_passwd_valid_p (const char *typed_passwd, Bool verbose_p);
+Bool pam_passwd_valid_p (void);
 Bool pam_priv_init (int argc, char **argv, Bool verbose_p);
 
 #ifdef HAVE_PAM_FAIL_DELAY
@@ -175,24 +204,37 @@ static void *suns_pam_implementation_blo
    to root.
  */
 Bool
-pam_passwd_valid_p (const char *typed_passwd, Bool verbose_p)
+pam_passwd_valid_p (void)
 {
   const char *service = PAM_SERVICE_NAME;
+  uid_t euid;
   pam_handle_t *pamh = 0;
   int status = -1;
+  int pam_auth_status = 0;  /* Specific for pam_authenticate() status*/
+  int acct_rc,setcred_rc,chauth_rc;
   struct pam_conv pc;
   struct pam_closure c;
   char *user = 0;
   sigset_t set;
   struct timespec timeout;
+  char* tmp_buf;
+  int  pam_flags = 0;
+  saver_info *si = global_si_kludge;
 
   struct passwd *p = getpwuid (getuid ());
+  Bool verbose_p = si->prefs.verbose_p;
+
+  if (verbose_p)
+    fprintf (stderr, "-->pam_passwd_valid_p()\n");
+
   if (!p) return False;
 
+  euid = geteuid();
+
   user = strdup (p->pw_name);
 
   c.user = user;
-  c.typed_passwd = typed_passwd;
+/**  c.typed_passwd = typed_passwd; **/
   c.verbose_p = verbose_p;
 
   pc.conv = &pam_conversation;
@@ -202,6 +244,20 @@ pam_passwd_valid_p (const char *typed_pa
      `closure' argument to pc.conv always comes in as random garbage. */
   suns_pam_implementation_blows = (void *) &c;
 
+  if (si->prefs.verbose_p)
+    fprintf (stderr, "Before uid=%d euid=%d \n\n", getuid(), geteuid());
+
+ if (seteuid (0) != 0)
+  {
+   if (verbose_p)
+     perror("Could not change euid to root, pam may not work!\n");
+  }
+  
+  if (verbose_p)
+   fprintf (stderr, "After seteuid(0) uid=%d euid=%d \n\n", getuid(), geteuid());
+
+  if (verbose_p)
+   fprintf (stderr, "PAM is using SERVICE_NAME=\"%s\"\n\n", service);
 
   /* Initialize PAM.
    */
@@ -210,21 +266,61 @@ pam_passwd_valid_p (const char *typed_pa
     fprintf (stderr, "%s: pam_start (\"%s\", \"%s\", ...) ==> %d (%s)\n",
              blurb(), service, c.user,
              status, PAM_STRERROR (pamh, status));
-  if (status != PAM_SUCCESS) goto DONE;
+  if (status != PAM_SUCCESS) 
+   {
+    we_have_pam = False;
+    goto DONE;
+   }
+  else
+    we_have_pam = True; /* if this flag is set we dont want to try shadow
+			 * passwords, i.e. method pwent, so if pam fails
+			 * screen remains locked.
+      			 ***/
+
+/* copying from xlock */
+
+#ifdef sun
+        /* Check /etc/default/login to see if we should add
+           PAM_DISALLOW_NULL_AUTHTOK to pam_flags */
+        if (defopen("/etc/default/login") == 0) {
+            char *ptr;
+            int flags = defcntl(DC_GETFLAGS, 0);
+            TURNOFF(flags, DC_CASE);
+            (void) defcntl(DC_SETFLAGS, flags);
+            if ((ptr = defread("PASSREQ=")) != NULL &&
+              strcasecmp("YES", ptr) == 0) {
+                pam_flags |= PAM_DISALLOW_NULL_AUTHTOK;
+            }
+
+            (void) defopen((char *)NULL); /* close current file */
+        }
+#endif
 
   /* #### We should set PAM_TTY to the display we're using, but we
      don't have that handy from here.  So set it to :0.0, which is a
      good guess (and has the bonus of counting as a "secure tty" as
      far as PAM is concerned...)
    */
+
+/* From the pam trace and log file, it is found out that the 
+   Sun pam modules can drive itself.
+*/
+
+#if 0
+
   {
-    char *tty = strdup (":0.0");
+    char *tty,*displayname;
+    if ((displayname = getenv ("DISPLAY")) != NULL)
+        tty = strdup(displayname);
+    else
+   	tty = strdup (":0.0");
     status = pam_set_item (pamh, PAM_TTY, tty);
     if (verbose_p)
       fprintf (stderr, "%s:   pam_set_item (p, PAM_TTY, \"%s\") ==> %d (%s)\n",
                blurb(), tty, status, PAM_STRERROR(pamh, status));
     free (tty);
   }
+#endif
 
   /* Try to authenticate as the current user.
      We must turn off our SIGCHLD handler for the duration of the call to
@@ -248,29 +344,104 @@ pam_passwd_valid_p (const char *typed_pa
 
   PAM_NO_DELAY(pamh);
 
+/************* no need
+  fprintf(stderr,"before calling pam_authenticate passwd_string: %s\n",si->pw_data->passwd_string);
+  if (si->pw_data->passwd_string)
+****************************/
+   {
+
+  
   timeout.tv_sec = 0;
   timeout.tv_nsec = 1;
   set = block_sigchld();
-  status = pam_authenticate (pamh, 0);
+  pam_auth_status = pam_authenticate (pamh, 0);
   sigtimedwait (&set, NULL, &timeout);
   unblock_sigchld();
 
+     /* Send status message to unlock dialog ***/
+     if (pam_auth_status == PAM_SUCCESS)
+      {
+        write_to_child (si, "pw_ok");
+        tmp_buf = (char*)PAM_STRERROR(pamh, pam_auth_status);
+        write_to_child (si, tmp_buf);
+        if (verbose_p)
+          sleep (1);
+      }
+     else
+      {
+        write_to_child (si, "pw_fail");
+        tmp_buf = (char*)PAM_STRERROR(pamh, pam_auth_status);
+        write_to_child (si, tmp_buf);
+        if (verbose_p)
+          sleep (1);
+        else
+          usleep (500000); /*sleep for 1/2 of sec */
+      }
+
+     /* PAM_SUCCESS defined to be 0 in /usr/include/security/pam_appl.h */
+     si->pw_data->state = (pam_auth_status == PAM_SUCCESS ? pw_ok : pw_fail);
+  if (verbose_p)
+        fprintf(stderr,"after calling pam_authenticate status is:%d state is:%d\n",
+			pam_auth_status,si->pw_data->state);
+
+     /* We get here implies regardless of success/failure nuke lock dialog */
+     /* no..wait till pam_end..to display error msgs...destroy_passwd_window (si);**/
+   }  
+
   if (verbose_p)
     fprintf (stderr, "%s:   pam_authenticate (...) ==> %d (%s)\n",
              blurb(), status, PAM_STRERROR(pamh, status));
-  if (status == PAM_SUCCESS)  /* Win! */
+  if (pam_auth_status == PAM_SUCCESS)  /* Win! */
     {
-      int status2;
-
-      /* We don't actually care if the account modules fail or succeed,
-       * but we need to run them anyway because certain pam modules
-       * depend on side effects of the account modules getting run.
-       */
-      status2 = pam_acct_mgmt (pamh, 0);
+      /* perform PAM account validation procedures for login user only */
+      acct_rc   = pam_acct_mgmt(pamh, pam_flags);
+      
+      /******************************************************************
+           ignore other cases for the time being 
+           PAM_USER_UNKNOWN, PAM_AUTH_ERR, PAM_ACCT_EXPIRED
+           (password mgn service module)
+           same as pam_setcred(), focus on auth. service module only
+       *****************************************************************/
 
       if (verbose_p)
         fprintf (stderr, "%s:   pam_acct_mgmt (...) ==> %d (%s)\n",
-                 blurb(), status2, PAM_STRERROR(pamh, status2));
+                 blurb(), acct_rc, PAM_STRERROR(pamh, acct_rc));
+
+      /******************************************************************
+           ignore other cases for the time being 
+           PAM_USER_UNKNOWN, PAM_AUTH_ERR, PAM_ACCT_EXPIRED
+           (password mgn service module)
+           same as pam_setcred(), focus on auth. service module only
+       *****************************************************************/
+
+      if (acct_rc   == PAM_NEW_AUTHTOK_REQD) {
+	do {
+	  chauth_rc  = pam_chauthtok(pamh, 0);
+	} while (chauth_rc == PAM_AUTHTOK_ERR ||
+		 chauth_rc  == PAM_TRY_AGAIN);
+	if (verbose_p)
+	  fprintf (stderr, "%s:   pam_chauthtok (...) ==> %d (%s)\n",
+		   blurb(), chauth_rc, PAM_STRERROR(pamh, chauth_rc));
+      }
+
+      /* Send status message to unlock dialog ***/
+      if (acct_rc == PAM_SUCCESS)
+	{
+	  write_to_child (si, "pw_acct_ok");
+	  tmp_buf = (char*)PAM_STRERROR(pamh, acct_rc);
+	  write_to_child (si, tmp_buf);
+	  if (verbose_p)
+	    sleep (1);
+	}
+      else
+	{
+	  write_to_child (si, "pw_acct_fail");
+	  tmp_buf = (char*)PAM_STRERROR(pamh, acct_rc);
+	  write_to_child (si, tmp_buf);
+	  if (verbose_p)
+	    sleep (1);
+	}
+
 
       /* Each time we successfully authenticate, refresh credentials,
          for Kerberos/AFS/DCE/etc.  If this fails, just ignore that
@@ -281,13 +452,36 @@ pam_passwd_valid_p (const char *typed_pa
          says that the Linux PAM library ignores that one, and only refreshes
          credentials when using PAM_REINITIALIZE_CRED.
        */
-      status2 = pam_setcred (pamh, PAM_REINITIALIZE_CRED);
+      setcred_rc = pam_setcred (pamh, PAM_REFRESH_CRED);
       if (verbose_p)
         fprintf (stderr, "%s:   pam_setcred (...) ==> %d (%s)\n",
-                 blurb(), status2, PAM_STRERROR(pamh, status2));
+                 blurb(), setcred_rc, PAM_STRERROR(pamh, setcred_rc));
+
+     /* Send status message to unlock dialog ***/
+     if (setcred_rc == PAM_SUCCESS)
+      {
+        write_to_child (si, "pw_setcred_ok");
+        tmp_buf = (char*)PAM_STRERROR(pamh, setcred_rc);
+        write_to_child (si, tmp_buf);
+        if (verbose_p)
+           sleep (1);
+      }
+     else
+      {
+        write_to_child (si, "pw_setcred_fail");
+        tmp_buf = (char*)PAM_STRERROR(pamh, setcred_rc);
+        write_to_child (si, tmp_buf);
+        if (verbose_p)
+          sleep (1);
+      }
+
       goto DONE;
     }
 
+/* security hole if root pwd is not set (or CR)
+   cannot delete it and is user function spec.
+*/
+
 #ifdef ALLOW_ROOT_PASSWD
   /* If that didn't work, set the user to root, and try to authenticate again.
    */
@@ -303,13 +497,28 @@ pam_passwd_valid_p (const char *typed_pa
   PAM_NO_DELAY(pamh);
 
   set = block_sigchld();
-  status = pam_authenticate (pamh, 0);
+  pam_auth_status = pam_authenticate (pamh, 0);
   sigtimedwait(&set, NULL, &timeout);
   unblock_sigchld();
 
+  /* Send status message to unlock dialog ***/
+  if (pam_auth_status == PAM_SUCCESS)
+    {
+      write_to_child (si, "pw_ok");
+      tmp_buf = strdup (_("Letting you in as ROOT!!"));
+      write_to_child (si, tmp_buf);
+      free (tmp_buf);
+
+      if (verbose_p)
+	sleep (1);
+    }
+
+  /* PAM_SUCCESS defined to be 0 in /usr/include/security/pam_appl.h */
+  si->pw_data->state = (pam_auth_status == PAM_SUCCESS ? pw_ok : pw_fail);
+  
   if (verbose_p)
-    fprintf (stderr, "%s:   pam_authenticate (...) ==> %d (%s)\n",
-             blurb(), status, PAM_STRERROR(pamh, status));
+    fprintf (stderr, "%s:   pam_authenticate as root user (...) ==> %d (%s)\n",
+             blurb(), pam_auth_status, PAM_STRERROR(pamh, pam_auth_status));
 
 #endif /* ALLOW_ROOT_PASSWD */
 
@@ -317,14 +526,45 @@ pam_passwd_valid_p (const char *typed_pa
   if (user) free (user);
   if (pamh)
     {
-      int status2 = pam_end (pamh, status);
+      int status2 = pam_end (pamh, pam_auth_status);
       pamh = 0;
       if (verbose_p)
         fprintf (stderr, "%s: pam_end (...) ==> %d (%s)\n",
                  blurb(), status2,
                  (status2 == PAM_SUCCESS ? "Success" : "Failure"));
     }
-  return (status == PAM_SUCCESS ? True : False);
+  
+
+  if (seteuid (euid) != 0)
+    {
+      if (verbose_p)
+	perror("Error pam could not revert euid to user running as euid root, locking may not work now\n");
+    }
+  
+  if (verbose_p)
+     fprintf (stderr, "<--end of pam_authenticate() returning ok_to_unblank = %d\n",
+	      (int) ((pam_auth_status == PAM_SUCCESS) ? True:False));
+
+  /* Now destroy unlock dialog window created in pam_conv func ***/
+
+  destroy_passwd_window (si);
+  usleep (250000); /* if repeatedly tried to unlock dialog with bad passwd,
+		    * old dialog doesnt get completely unmapped before new
+		    * one posts, this should help the unmapping to go through
+		    * before new one is posted
+		    */
+  XSync (si->dpy, False);
+
+  if (si->pw_data->passwd_string)
+    {
+      free (si->pw_data->passwd_string); 
+      si->pw_data->passwd_string = 0;
+    }
+
+  if (pam_auth_status == PAM_SUCCESS) 
+    return (True);
+  else 
+    return (False);
 }
 
 
@@ -344,6 +584,11 @@ pam_priv_init (int argc, char **argv, Bo
   const char file2[] = "/etc/pam.conf";
   struct stat st;
 
+  if (! verbose_p)	/* SUN addition: only print warnings in verbose mode */
+    {			/* since they are rarely useful and mostly just      */
+      return True;	/* cause confusion when users see them.		     */
+    }
+
 # ifndef S_ISDIR
 #  define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)
 # endif
@@ -370,6 +615,9 @@ pam_priv_init (int argc, char **argv, Bo
                 break;
               }
           fclose (f);
+          
+/* 
+** comment out the misleading message
           if (!ok)
             {
               fprintf (stderr,
@@ -377,9 +625,12 @@ pam_priv_init (int argc, char **argv, Bo
                   "%s: password authentication via PAM is unlikely to work.\n",
                        blurb(), file2, PAM_SERVICE_NAME, blurb());
             }
+*/
         }
       /* else warn about file2 existing but being unreadable? */
     }
+/*
+** comment out the misleading message
   else
     {
       fprintf (stderr,
@@ -387,6 +638,7 @@ pam_priv_init (int argc, char **argv, Bo
                "%s: password authentication via PAM is unlikely to work.\n",
                blurb(), file2, file, blurb());
     }
+*/
 
   /* Return true anyway, just in case. */
   return True;
@@ -407,67 +659,144 @@ pam_priv_init (int argc, char **argv, Bo
    would never see this string, and the prompted-for password would be
    ignored.
  */
-static int
+int
 pam_conversation (int nmsgs,
-                  const struct pam_message **msg,
+                  struct pam_message **msg,
                   struct pam_response **resp,
                   void *closure)
 {
   int replies = 0;
   struct pam_response *reply = 0;
   struct pam_closure *c = (struct pam_closure *) closure;
+  saver_info *si = global_si_kludge;
 
   /* On SunOS 5.6, the `closure' argument always comes in as random garbage. */
   c = (struct pam_closure *) suns_pam_implementation_blows;
 
+  if (c->verbose_p)
+     fprintf(stderr, "-->pam_conv() \n");
 
   reply = (struct pam_response *) calloc (nmsgs, sizeof (*reply));
   if (!reply) return PAM_CONV_ERR;
 	
   for (replies = 0; replies < nmsgs; replies++)
     {
+     /* Means pam requires interaction..spawn dialog dont use unlock_p() here
+      * Another issue is pam conv can be called many times by pam, for pam_auth
+      * and then again for pam_setcred etc.. so make sure we dont keep creating
+      * multiple copies of dialog. 
+      */
+        if (!g_passwd_dialog_created)
+         {
+           make_passwd_window (si);
+         }
+
+/**fprintf(stderr, "top of switch %d\n", replies);**/
       switch (msg[replies]->msg_style)
         {
         case PAM_PROMPT_ECHO_ON:
-          reply[replies].resp_retcode = PAM_SUCCESS;
-          reply[replies].resp = strdup (c->user);	   /* freed by PAM */
-          if (c->verbose_p)
-            fprintf (stderr, "%s:     PAM ECHO_ON(\"%s\") ==> \"%s\"\n",
-                     blurb(), msg[replies]->msg,
-                     reply[replies].resp);
-          break;
         case PAM_PROMPT_ECHO_OFF:
-          reply[replies].resp_retcode = PAM_SUCCESS;
-          reply[replies].resp = strdup (c->typed_passwd);   /* freed by PAM */
+         {
           if (c->verbose_p)
             fprintf (stderr, "%s:     PAM ECHO_OFF(\"%s\") ==> password\n",
                      blurb(), msg[replies]->msg);
-          break;
-        case PAM_TEXT_INFO:
-          /* ignore it... */
+
+          /**fprintf(stderr, "PAM_ECHO_OFF/ECHO_ON nmsgs=%d\n",nmsgs);**/
+
+             write_to_child (si, msg[replies]->msg);
+             if (c->verbose_p)
+              sleep (1); /* let user see these */
+
+             if (c->verbose_p)
+                fprintf(stderr, "PAM_ECHO_OFF/ECHO_ON msg[replies]-> %s\n",
+					msg[replies]->msg);
+
+             si->pw_data->state = pw_read;
+             while (!si->pw_data->got_windowid && si->pw_data->state == pw_read)
+              {
+               if (c->verbose_p)
+                 fprintf(stderr,"WAiting for window id from lock dialog\n");
+               handle_typeahead (si);
+               passwd_event_loop (si);
+               if (c->verbose_p)
+                 fprintf(stderr,"<---passwd_event_loop() state =%d\n",si->pw_data->state);
+              }
+
           reply[replies].resp_retcode = PAM_SUCCESS;
-          reply[replies].resp = 0;
+
+             /*Make sure user inputs a response..and dialog is not timiing out **/
+             if (si->pw_data->state != pw_time && si->pw_data->passwd_string != NULL)
+              {
+               reply[replies].resp = strdup (si->pw_data->passwd_string);/*freed by PAM*/
           if (c->verbose_p)
-            fprintf (stderr, "%s:     PAM TEXT_INFO(\"%s\") ==> ignored\n",
-                     blurb(), msg[replies]->msg);
+                 fprintf(stderr, "in ECHO OFF and got a passwd..:%s\n",
+                                       si->pw_data->passwd_string);
+              }
+             else /* Perhaps user does not want to enter input, dialog times out */
+              {
+               /* this shouldnt happen...perhaps sending null passwd to pam is 
+	        * best for now**/
+               /* reply[replies].resp = 0;Dont send any resp*/ /* freed by PAM */
+               /* Reset state to fail */
+               si->pw_data->state = pw_fail;
+
+               if (c->verbose_p)
+                {
+                  fprintf(stderr, "Dude sending null password to pam..\n");
+                  fprintf(stderr,"We didnt receive any input from user!!!\n");
+                }
+              }
           break;
+         }
+        case PAM_TEXT_INFO:
         case PAM_ERROR_MSG:
-          /* ignore it... */
-          reply[replies].resp_retcode = PAM_SUCCESS;
-          reply[replies].resp = 0;
+	{
+	 char* tmp_msg;
+
+          /* display messages coming from pam... */
+          /* we should have dialog up still to show this */
           if (c->verbose_p)
-            fprintf (stderr, "%s:     PAM ERROR_MSG(\"%s\") ==> ignored\n",
-                     blurb(), msg[replies]->msg);
+            fprintf(stderr, "PAM_ERROR/PAM_TEXT_INFO nmsgs=%d\n",nmsgs);
+          if (!g_passwd_dialog_created)
+           {
+            make_passwd_window (si);
+            /*sleep (1);*/ /*make sure window is created by now **/
+           }
+          tmp_msg = strdup (msg[replies]->msg);
+          write_to_child (si, tmp_msg);
+          sleep(1);
+
+          if (c->verbose_p)
+            fprintf(stderr, "PAM_ERROR/PAM_TEXT_INFO msg[%d]-> %s\n",
+					replies,msg[replies]->msg);
+
+          reply[replies].resp_retcode = PAM_CONV_ERR;
+          /*reply[replies].resp = 0;*/
+          /* Reset state to read */
+          si->pw_data->state = pw_read;
+
+          free(tmp_msg);
           break;
+	}
+
         default:
-          /* Must be an error of some sort... */
-          free (reply);
+
+         {
+           int i;
           if (c->verbose_p)
-            fprintf (stderr, "%s:     PAM unknown %d(\"%s\") ==> ignored\n",
+            fprintf (stderr, "%s:     PAM unknown %d(\"%s\") ==> ERROR..default case:\n",
                      blurb(), msg[replies]->msg_style, msg[replies]->msg);
+          /* Must be an error of some sort... */
+            for (i = 0; i < replies; i++)
+                    if (reply[replies].resp != NULL)
+                            free (reply[replies].resp);
+            free (reply);
+            reply = NULL;
           return PAM_CONV_ERR;
-        }
-    }
+
+          } /* end default */
+        } /* end switch */
+    } /* end for loop */
   *resp = reply;
   return PAM_SUCCESS;
 }
diff -urp -x '*~' driver/passwd.c driver/passwd.c
--- driver/passwd.c	2006-05-16 19:14:58.000000000 -0700
+++ driver/passwd.c	2006-09-19 17:08:15.073303000 -0700
@@ -49,11 +49,11 @@ struct auth_methods {
 
 #ifdef HAVE_KERBEROS
 extern Bool kerberos_lock_init (int argc, char **argv, Bool verbose_p);
-extern Bool kerberos_passwd_valid_p (const char *typed_passwd, Bool verbose_p);
+extern Bool kerberos_passwd_valid_p (const char *typed_passwd, Bool verbose_p, int whichService);
 #endif
 #ifdef HAVE_PAM
 extern Bool pam_priv_init (int argc, char **argv, Bool verbose_p);
-extern Bool pam_passwd_valid_p (const char *typed_passwd, Bool verbose_p);
+extern Bool pam_passwd_valid_p (void);
 #endif
 #ifdef PASSWD_HELPER_PROGRAM
 extern Bool ext_priv_init (int argc, char **argv, Bool verbose_p);
@@ -61,7 +61,7 @@ extern Bool ext_passwd_valid_p (const ch
 #endif
 extern Bool pwent_lock_init (int argc, char **argv, Bool verbose_p);
 extern Bool pwent_priv_init (int argc, char **argv, Bool verbose_p);
-extern Bool pwent_passwd_valid_p (const char *typed_passwd, Bool verbose_p);
+extern Bool pwent_passwd_valid_p (const char *typed_passwd, Bool verbose_p, int whichService);
 
 Bool lock_priv_init (int argc, char **argv, Bool verbose_p);
 Bool lock_init (int argc, char **argv, Bool verbose_p);
@@ -80,13 +80,14 @@ struct auth_methods methods[] = {
 # ifdef HAVE_PAM
   { "PAM",              0, pam_priv_init, pam_passwd_valid_p, 
                         False, False },
-# endif
+# else    /* If we dont have PAM only then fall back to shadow passwords authentication */
 # ifdef PASSWD_HELPER_PROGRAM
   { "external",		0, ext_priv_init, ext_passwd_valid_p,
   			False, False },
 #endif
   { "normal",           pwent_lock_init, pwent_priv_init, pwent_passwd_valid_p,
                         False, False }
+# endif
 };
 
 
diff -urp -x '*~' driver/setuid.c driver/setuid.c
--- driver/setuid.c	2006-02-08 18:33:29.000000000 -0800
+++ driver/setuid.c	2006-09-19 17:08:15.073889000 -0700
@@ -15,6 +15,7 @@
 #endif
 
 #include <X11/Xlib.h>		/* not used for much... */
+#include <X11/Intrinsic.h>		/* not used for much... */
 
 /* This file doesn't need the Xt headers, so stub these types out... */
 #undef XtPointer
@@ -145,7 +146,10 @@ set_ids_by_number (uid_t uid, gid_t gid,
     gid_errno = errno ? errno : -1;
 
   errno = 0;
-  if (setuid (uid) != 0)
+/*mali  if (setuid (uid) != 0)**we need root privs back at pam_authenticate
+  this is causing to loose root priv for good, not good **/
+
+ if (seteuid (uid) != 0)
     uid_errno = errno ? errno : -1;
 
   if (uid_errno == 0 && gid_errno == 0 && sgs_errno == 0)
diff -urp -x '*~' driver/subprocs.c driver/subprocs.c
--- driver/subprocs.c	2006-09-19 17:08:10.188909000 -0700
+++ driver/subprocs.c	2006-09-19 17:08:15.079767000 -0700
@@ -20,6 +20,7 @@
 #include <string.h>
 
 #include <X11/Xlib.h>		/* not used for much... */
+#include <X11/Intrinsic.h>		/* not used for much... */
 
 #ifndef ESRCH
 # include <errno.h>
@@ -243,7 +244,7 @@ show_job_list (void)
 
 static void clean_job_list (void);
 
-static struct screenhack_job *
+struct screenhack_job *
 make_job (pid_t pid, int screen, const char *cmd)
 {
   struct screenhack_job *job = (struct screenhack_job *) malloc (sizeof(*job));
@@ -391,7 +392,7 @@ unblock_sigchld (void)
   block_sigchld_handler--;
 }
 
-static int
+int
 kill_job (saver_info *si, pid_t pid, int signal)
 {
   saver_preferences *p = &si->prefs;
@@ -574,9 +575,14 @@ describe_dead_child (saver_info *si, pid
 	 mention them) if we've just killed the subprocess.  But mention them
 	 if they happen on their own.
        */
-      if (!job ||
-	  (exit_status != 0 &&
-	   (p->verbose_p || job->status != job_killed)))
+
+      if ((!job 
+#ifdef HAVE_XSCREENSAVER_LOCK
+	   && kid != si->passwd_pid
+#endif /* HAVE_XSCREENSAVER_LOCK */
+	      ) ||
+	   (exit_status != 0 &&
+	    (p->verbose_p || (job && job->status != job_killed))))
         {
           /* Don't call fprintf() from signal handlers, as it might malloc.
 	  fprintf (stderr,
@@ -616,8 +622,12 @@ describe_dead_child (saver_info *si, pid
   else if (WIFSIGNALED (wait_status))
     {
       if (p->verbose_p ||
-	  !job ||
-	  job->status != job_killed ||
+	  (!job
+#ifdef HAVE_XSCREENSAVER_LOCK
+	   && kid != si->passwd_pid
+#endif /* HAVE_XSCREENSAVER_LOCK */
+		  ) ||
+	  (job && job->status != job_killed) ||
 	  WTERMSIG (wait_status) != SIGTERM)
         {
           /* Don't call fprintf() from signal handlers, as it might malloc.
@@ -685,12 +695,23 @@ describe_dead_child (saver_info *si, pid
   /* Clear out the pid so that screenhack_running_p() knows it's dead.
    */
   if (!job || job->status == job_dead)
+    {
     for (i = 0; i < si->nscreens; i++)
       {
 	saver_screen_info *ssi = &si->screens[i];
 	if (kid == ssi->pid)
 	  ssi->pid = 0;
       }
+#ifdef HAVE_XSCREENSAVER_LOCK
+      if (kid == si->passwd_pid)
+	{
+/*unsafe	  if (p->verbose_p)
+	    fprintf (stderr, "passwd dialog died!\n");
+**/
+	  si->passwd_pid = 0;
+	}
+#endif
+    }
 }
 
 #else  /* VMS */
diff -urp -x '*~' driver/timers.c driver/timers.c
--- driver/timers.c	2005-11-28 02:14:22.000000000 -0800
+++ driver/timers.c	2006-09-19 17:08:15.080886000 -0700
@@ -60,6 +60,12 @@ static Bool proc_interrupts_activity_p (
 #endif /* HAVE_PROC_INTERRUPTS */
 
 static void check_for_clock_skew (saver_info *si);
+static void watchdog_timer (XtPointer closure, XtIntervalId *id);
+extern Bool g_passwd_dialog_created;
+extern Bool ok_to_unblank;
+extern Bool pam_passwd_valid_p(void);
+extern Bool blank_screen (saver_info *si);
+extern void unblank_screen (saver_info *si);
 
 
 void
@@ -255,7 +261,8 @@ cycle_timer (XtPointer closure, XtInterv
        crash.  So, restart the thing once an hour. */
     how_long = 1000 * 60 * 60;
 
-  if (si->dbox_up_p)
+/**mali99  if (si->dbox_up_p)*/
+   if (si->external_passwd)
     {
       if (p->verbose_p)
 	fprintf (stderr, "%s: dialog box up; delaying hack change.\n",
@@ -303,8 +310,20 @@ activate_lock_timer (XtPointer closure, 
   saver_preferences *p = &si->prefs;
 
   if (p->verbose_p)
-    fprintf (stderr, "%s: timed out; activating lock.\n", blurb());
+    fprintf (stderr, "-->activate_lock_timer() %s: timed out; activating lock.\n", 
+					blurb());
+  if (si->screen_blanked_p) /* Make sure screen is blanked before posting dialogbox*/
+   {
   set_locked_p (si, True);
+    ok_to_unblank = pam_passwd_valid_p();
+    if (ok_to_unblank == True) 
+     {
+      set_locked_p(si,False);
+      unblank_screen(si);
+}
+   }
+  else /* blanking of screen failed reset lock flag */
+    set_locked_p (si, False);
 }
 
 
@@ -799,7 +818,10 @@ sleep_until_idle (saver_info *si, Bool u
 
       case ClientMessage:
 	if (handle_clientmessage (si, &event, until_idle_p))
+         {
+          si->emergency_lock_p = True;
 	  goto DONE;
+         }
 	break;
 
       case CreateNotify:
@@ -812,8 +834,47 @@ sleep_until_idle (saver_info *si, Bool u
 	  }
 	break;
 
+      case VisibilityNotify:
+	{
+	  int k;
+
+          if (p->debug_p)
+	   {
+            fprintf(stderr,"************************************\n");
+	    fprintf(stderr,"-->sleep_until_idle() event:VisibilityNotify\n"); 
+            fprintf(stderr,"\t Window of VisibilityNotify:%x\n",
+				event.xvisibility.window);
+            fprintf(stderr,"\t until_idle_p=%d g_passwd_dialog_created=%d\n",
+				until_idle_p, g_passwd_dialog_created);
+	    fflush(stderr);
+	   }
+
+	  /*Dont raise root window when passwd dialog wants to come up */
+	  if (g_passwd_dialog_created == 0 && !until_idle_p)
+	    {
+	      if (event.xvisibility.state != VisibilityUnobscured)
+		{
+		  for (k = 0; k < si->nscreens; k++)
+		    {
+		      saver_screen_info *ssi = &si->screens[k];
+		      XClearWindow (si->dpy, ssi->screensaver_window);
+		      clear_stderr (ssi);
+		      XMapRaised (si->dpy, ssi->screensaver_window);
+		    }
+		  if (p->debug_p)
+		    {
+		      fprintf (stderr,"A window is trying to popup.\n");
+		      fprintf(stderr, "Raising saver root Window.\n");
+		      fprintf(stderr,"************************************\n");
+		      fflush(stderr);
+		    }
+		}
+	    }
+	  break;
+	} 
+
       case KeyPress:
-      case KeyRelease:
+/*mali99      case KeyRelease:**/
       case ButtonPress:
       case ButtonRelease:
       case MotionNotify:
@@ -1380,7 +1441,8 @@ watchdog_timer (XtPointer closure, XtInt
     {
       Bool running_p = screenhack_running_p (si);
 
-      if (si->dbox_up_p)
+      /**mali9 if (si->dbox_up_p)****/
+      if (si->external_passwd)
         {
           if (si->prefs.debug_p)
             fprintf (stderr, "%s: dialog box is up: not raising screen.\n",
diff -urp -x '*~' driver/windows.c driver/windows.c
--- driver/windows.c	2006-05-14 22:13:54.000000000 -0700
+++ driver/windows.c	2006-09-19 17:08:15.082113000 -0700
@@ -35,6 +35,7 @@
 #include <X11/Xutil.h>		/* for XSetClassHint() */
 #include <X11/Xatom.h>
 #include <X11/Xos.h>		/* for time() */
+#include <X11/Intrinsic.h>
 #include <signal.h>		/* for the signal names */
 #include <time.h>
 #include <sys/time.h>
@@ -1411,6 +1412,7 @@ initialize_screensaver_window_1 (saver_s
    */
   attrs.event_mask = (KeyPressMask | KeyReleaseMask |
 		      ButtonPressMask | ButtonReleaseMask |
+		      VisibilityChangeMask |
 		      PointerMotionMask);
 
   attrs.backing_store = NotUseful;
@@ -1713,6 +1715,9 @@ raise_window (saver_info *si,
   saver_preferences *p = &si->prefs;
   int i;
 
+  if (p->verbose_p)
+      fprintf(stderr,"-->raise_window()\n");
+
   if (si->demoing_p)
     inhibit_fade = True;
 
@@ -1927,6 +1932,9 @@ unblank_screen (saver_info *si)
   Bool unfade_p = (si->fading_possible_p && p->unfade_p);
   int i;
 
+  if (p->verbose_p)
+      fprintf(stderr,"-->unblank_screen()\n");
+
   monitor_power_on (si);
   reset_watchdog_timer (si, False);
 
diff -urp -x '*~' driver/xscreensaver.c driver/xscreensaver.c
--- driver/xscreensaver.c	2006-09-19 17:08:10.214882000 -0700
+++ driver/xscreensaver.c	2006-09-19 17:08:15.095484000 -0700
@@ -177,8 +177,21 @@
 #include "visual.h"
 #include "usleep.h"
 
+extern Bool pam_passwd_valid_p ();
+
 saver_info *global_si_kludge = 0;	/* I hate C so much... */
 
+/* Globals */
+Bool ok_to_unblank = False;
+
+/* Global storage for gtk passwd lock dialog 
+ * we assign this to si->pw_data and this is needed
+ * to set user/passwd labels on gtk lock dialog by
+ * pam conv function.
+ */
+passwd_dialog_data mygtkpwd;
+passwd_dialog_data *ptr_mygtkpwd = &mygtkpwd;
+
 char *progname = 0;
 char *progclass = 0;
 XrmDatabase db = 0;
@@ -189,6 +202,7 @@ static Atom XA_ACTIVATE, XA_DEACTIVATE, 
 static Atom XA_RESTART, XA_SELECT;
 static Atom XA_THROTTLE, XA_UNTHROTTLE;
 Atom XA_DEMO, XA_PREFS, XA_EXIT, XA_LOCK, XA_BLANK;
+Atom XA_UNLOCK_RATIO;
 
 
 static XrmOptionDescRec options [] = {
@@ -589,6 +603,7 @@ connect_to_server (saver_info *si, int *
   XA_BLANK = XInternAtom (si->dpy, "BLANK", False);
   XA_THROTTLE = XInternAtom (si->dpy, "THROTTLE", False);
   XA_UNTHROTTLE = XInternAtom (si->dpy, "UNTHROTTLE", False);
+  XA_UNLOCK_RATIO = XInternAtom (si->dpy, "UNLOCK_RATIO", False);
 
   return toplevel_shell;
 }
@@ -1122,7 +1137,7 @@ static void
 main_loop (saver_info *si)
 {
   saver_preferences *p = &si->prefs;
-  Bool ok_to_unblank;
+  /* Bool ok_to_unblank; made this a global flag, gets set in timers.c */
 
   while (1)
     {
@@ -1153,6 +1168,14 @@ main_loop (saver_info *si)
             fprintf (stderr, "%s: idle with blanking disabled at %s.\n",
                      blurb(), timestring());
 
+          /* mali Bug 6221109 Changing mode from disable to anything else,doesnt lock screen.
+           * This is Disable Screen Saver mode, in this mode we dont lock screen
+           * but si->locked_p is already set to True, since someone tried to lock screen,
+           * reset it to False, else when we change mode from disable and try to lock screen,
+           * xscreensaver thinks screen is already locked and doesnt lock screen anymore.
+           */
+          set_locked_p (si, False);
+
           /* Go around the loop and wait for the next bout of idleness,
              or for the init file to change, or for a remote command to
              come in, or something.
@@ -1214,6 +1237,7 @@ main_loop (saver_info *si)
                        blurb());
 
               schedule_wakeup_event (si, retry, p->debug_p);
+              set_locked_p(si, False);
               continue;
             }
         }
@@ -1259,7 +1283,17 @@ main_loop (saver_info *si)
             p->lock_p &&                /* and locking is enabled */
             !si->locking_disabled_p &&  /* and locking is possible */
             lock_timeout == 0)          /* and locking is not timer-deferred */
+         {
+          if (p->debug_p)
+            fprintf(stderr, "going to lock screen B\n");
           set_locked_p (si, True);      /* then lock right now. */
+          ok_to_unblank = pam_passwd_valid_p();
+          if (ok_to_unblank == True)
+           {
+            set_locked_p (si, False);
+            goto DONE;
+           }
+         }
 
         /* locked_p might be true already because of the above, or because of
            the LOCK ClientMessage.  But if not, and if we're supposed to lock
@@ -1274,10 +1308,7 @@ main_loop (saver_info *si)
       }
 #endif /* !NO_LOCKING */
 
-
-      ok_to_unblank = True;
       do {
-
         check_for_leaks ("blanked A");
 	sleep_until_idle (si, False);		/* until not idle */
         check_for_leaks ("blanked B");
@@ -1287,6 +1318,12 @@ main_loop (saver_info *si)
 #ifndef NO_LOCKING
         /* Maybe unlock the screen.
          */
+        if (si->demoing_p) goto DONE; /*in demoing mode and user wants out unblankscreen */
+
+        /* This is when blank timeout has happened but lock timeout hasnt and user
+         * gets active. Simply get him out of the blank screen */
+        if (si->screen_blanked_p && !si->locked_p) goto DONE;
+
 	if (si->locked_p)
 	  {
 	    saver_screen_info *ssi = si->default_screen;
@@ -1297,7 +1334,20 @@ main_loop (saver_info *si)
 	    suspend_screenhack (si, True);
 	    XUndefineCursor (si->dpy, ssi->screensaver_window);
 
+#ifdef	HAVE_XSCREENSAVER_LOCK    
+            /*Prevents lock dialog posting on non blanked screen */
+            if (!si->screen_blanked_p)  /*locked_p is true, so blank now*/
+	      blank_screen (si);
+            if (si->screen_blanked_p) /* if blanking successful, call PAM*/
+	      {
+		set_locked_p (si, True);
+		ok_to_unblank = pam_passwd_valid_p();
+	      }
+	    else /* blanking failed, probably couldnt grab keyboard/mouse */
+	      set_locked_p (si, False);
+#else
 	    ok_to_unblank = unlock_p (si);
+#endif
 
 	    si->dbox_up_p = False;
 	    XDefineCursor (si->dpy, ssi->screensaver_window, ssi->cursor);
@@ -1321,6 +1371,7 @@ main_loop (saver_info *si)
 
 	} while (!ok_to_unblank);
 
+DONE:
 
       if (p->verbose_p)
 	fprintf (stderr, "%s: unblanking screen at %s.\n",
@@ -1377,6 +1428,11 @@ main (int argc, char **argv)
   int i;
 
   memset(si, 0, sizeof(*si));
+
+/* Initialize and point si to pw_data i.e. the lock dialog struct */
+  memset(ptr_mygtkpwd, 0, sizeof(*ptr_mygtkpwd));
+  si->pw_data = ptr_mygtkpwd;
+
   global_si_kludge = si;	/* I hate C so much... */
 
   fix_fds();
@@ -1386,7 +1442,7 @@ main (int argc, char **argv)
 
   save_argv (argc, argv);
   set_version_string (si, &argc, argv);
-  privileged_initialization (si, &argc, argv);
+/*oldplace  privileged_initialization (si, &argc, argv);*/
   hack_environment (si);
 
   shell = connect_to_server (si, &argc, argv);
@@ -1394,6 +1450,8 @@ main (int argc, char **argv)
   print_banner (si);
 
   load_init_file(si->dpy, p); /* must be before initialize_per_screen_info() */
+  privileged_initialization (si, &argc, argv);
+
   blurb_timestamp_p = p->timestamp_p;  /* kludge */
   initialize_per_screen_info (si, shell); /* also sets si->fading_possible_p */
 
@@ -1439,6 +1497,7 @@ main (int argc, char **argv)
   handle_signals (si);
 
   make_splash_dialog (si);
+  /*spawn_external_passwd_process (si);*/
 
   main_loop (si);		/* doesn't return */
   return 0;
@@ -1631,13 +1690,18 @@ handle_clientmessage (saver_info *si, XE
   Atom type = 0;
   Window window = event->xclient.window;
 
+  if (p->verbose_p) 
+     fprintf(stderr, "handle_clientmessage\n");
+
   /* Preferences might affect our handling of client messages. */
   maybe_reload_init_file (si);
+  XFlush (si->dpy);
+  XSync (si->dpy, False);
 
   if (event->xclient.message_type != XA_SCREENSAVER ||
       event->xclient.format != 32)
     {
-      bogus_clientmessage_warning (si, event);
+      /*bogus_clientmessage_warning (si, event); mali */
       return False;
     }
 
@@ -1901,10 +1965,17 @@ handle_clientmessage (saver_info *si, XE
 			    : "locking.");
 	  sprintf (buf, "LOCK ClientMessage received; %s", response);
 	  clientmessage_response (si, window, False, buf, response);
+
+          if (p->verbose_p)
+             fprintf(stderr, "going to lock screen A\n");
+
 	  set_locked_p (si, True);
+          si->emergency_lock_p = True;
 	  si->selection_mode = 0;
 	  si->demoing_p = False;
 
+          return True; /* dont set lock_id to 0, causes to go in lock in main_loop above */
+
 	  if (si->lock_id)	/* we're doing it now, so lose the timeout */
 	    {
 	      XtRemoveTimeOut (si->lock_id);
diff -urp -x '*~' driver/xscreensaver.h driver/xscreensaver.h
--- driver/xscreensaver.h	2006-02-03 23:38:06.000000000 -0800
+++ driver/xscreensaver.h	2006-09-19 17:08:15.096225000 -0700
@@ -126,6 +126,15 @@ struct saver_info {
 				   privileged user. */
 
   Window passwd_dialog;		/* The password dialog, if its up. */
+#ifdef HAVE_XSCREENSAVER_LOCK
+  pid_t passwd_pid;             /* The pid of the password dialog if
+				   we ran an external process for
+				   it. */
+  Bool external_passwd;
+  Bool at_external_passwd;	/* AT-enabled, bugid 
+				5059445(p3) screen kb and reader support
+				*/
+#endif /* HAVE_XSCREENSAVER_LOCK */
   passwd_dialog_data *pw_data;	/* Other info necessary to draw it. */
 
   int unlock_failures;		/* Counts failed login attempts while the
@@ -348,7 +357,7 @@ extern void get_screen_viewport (saver_s
 extern Bool unlock_p (saver_info *si);
 extern Bool lock_priv_init (int argc, char **argv, Bool verbose_p);
 extern Bool lock_init (int argc, char **argv, Bool verbose_p);
-extern Bool passwd_valid_p (const char *typed_passwd, Bool verbose_p);
+extern Bool passwd_valid_p (void);
 #endif /* NO_LOCKING */
 
 extern void set_locked_p (saver_info *si, Bool locked_p);
@@ -356,6 +365,109 @@ extern int move_mouse_grab (saver_info *
                             int to_screen_no);
 extern int mouse_screen (saver_info *si);
 
+/* =======================================================================
+   For lock.c
+   ======================================================================= */
+
+enum window_type { w_dialog, w_message };
+
+enum passwd_state { pw_read, pw_ok, pw_null, pw_fail, pw_cancel, pw_time };
+
+struct passwd_dialog_data {
+
+  saver_screen_info *prompt_screen;
+  int previous_mouse_x, previous_mouse_y;
+
+  enum passwd_state state;
+  char typed_passwd [80];
+
+  enum window_type  w_type;
+
+  XtIntervalId timer;
+  int i_beam;
+
+  float ratio;
+  Position x, y;
+  Dimension width;
+  Dimension height;
+  Dimension border_width;
+
+  Bool show_stars_p; /* "I regret that I have but one asterisk for my country."
+                        -- Nathan Hale, 1776. */
+
+  char *heading_label;
+  char *body_label;
+  /*
+   * For message dialog the body label may contain more than
+   * one line of text
+   */
+  char **message_body_label;
+
+  char *user_label;
+  char *passwd_label;
+  char *date_label;
+  char *user_string;
+  char *passwd_string;
+  char *login_label;
+  char *uname_label;
+
+  Bool show_uname_p;
+
+  XFontStruct *heading_font;
+  XFontStruct *body_font;
+  XFontStruct *label_font;
+  XFontStruct *passwd_font;
+  XFontStruct *date_font;
+  XFontStruct *button_font;
+  XFontStruct *uname_font;
+
+  Pixel foreground;
+  Pixel background;
+  Pixel passwd_foreground;
+  Pixel passwd_background;
+  Pixel thermo_foreground;
+  Pixel thermo_background;
+  Pixel shadow_top;
+  Pixel shadow_bottom;
+  Pixel button_foreground;
+  Pixel button_background;
+
+  Dimension logo_width;
+  Dimension logo_height;
+  Dimension thermo_width;
+  Dimension internal_border;
+  Dimension shadow_width;
+
+  Dimension passwd_field_x, passwd_field_y;
+  Dimension passwd_field_width, passwd_field_height;
+
+  Dimension login_button_x, login_button_y;
+  Dimension login_button_width, login_button_height;
+
+  Dimension thermo_field_x, thermo_field_y;
+  Dimension thermo_field_height;
+
+  Pixmap logo_pixmap;
+  Pixmap logo_clipmask;
+  int logo_npixels;
+  unsigned long *logo_pixels;
+
+  Cursor passwd_cursor;
+  Bool login_button_down_p;
+  Bool login_button_p;
+  Bool login_button_enabled_p;
+
+  Pixmap save_under;
+
+#ifdef HAVE_XSCREENSAVER_LOCK
+  /* extern passwd dialog stuff */
+  XtInputId stdout_input_id;
+  int       stdin_fd;
+  int       stdout_fd;
+  Bool      got_windowid;
+  FILE     *input_file;
+#endif
+};
 
 /* =======================================================================
    runtime privileges
diff -urp -x '*~' driver/xset.c driver/xset.c
--- driver/xset.c	2005-03-21 18:04:48.000000000 -0800
+++ driver/xset.c	2006-09-19 17:08:15.096586000 -0700
@@ -19,6 +19,7 @@
 #include <X11/Xutil.h>
 #include <X11/Xatom.h>
 #include <X11/Xos.h>
+#include <X11/Intrinsic.h>
 
 /* This file doesn't need the Xt headers, so stub these types out... */
 #undef XtPointer
